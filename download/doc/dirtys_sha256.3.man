NAME
   dirtys_sha256(3f) - [M_hashkeys] generate a SHA-256 hashing
SYNOPSIS
  function dirtys_sha256(str)

   character(len=64)            :: dirtys_sha256
   character(len=*), intent(in) :: str


DESCRIPTION

   A Fortran module for SHA-256 hashing.

   The quick and dirty routine (dirtys_sha256(3f)) operates on whatever
   bits that come in, without swapping to big-endian words, and does
   therefore not pass any of the standard tests - but works at roughly
   twice the speed. Use this if you want a good hash function but don't
   care about following the SHA-256 standard specifications.

   Note that this code will not produce the same results on big-endian
   machines and the module was only tested on a little-endian Ubuntu
   LTS 12.04 system using gfortran 4.6.3 and CygWin using Gortran 7.3.0.

OPTIONS
   str      The message to digest.

RETURNS
   dirtys_sha256   The SHA-256 digest as a string of length 64.

AUTHOR

   This routine is heavily based on the SHA-256 routines by Mikael Leetmaa
   <leetmaa@kth.se>, 2014-01-05. changes have been made to incorporate
   it into the GPF (General Purpose Fortran) framework.

   If you found this useful, please let Mikael Leetmaa know.

EXAMPLES
   Using slurp(3f) and switch(3f) from the GPF (General Purpose Fortran)
   collection to read in a file and convert it into a string, generate
   digest values for a list of files. Note that this example reads the
   entire input file into memory twice, and so requires very large
   amounts of memory if very large files are processed.

    program demo_dirty_sha256
    use,intrinsic :: iso_fortran_env, only : ERROR_UNIT
    use M_hashkeys,                   only : sha256, dirty_sha256
    use M_io,                         only : slurp
    use M_strings,                    only : switch
    implicit none
    character(len=1),allocatable :: text(:) ! array to hold file in memory
    character(len=:),allocatable :: string
    integer                      :: i
    character(len=4096)          :: filename
       do i=1,command_argument_count()  ! step through filenames on command line
          call get_command_argument(i, filename)
          call slurp(filename,text) ! allocate character array and copy file into it
          if(.not.allocated(text))then
             write(ERROR_UNIT,*)'*rever* ERROR: failed to load file '//trim(filename)
          else
             string=switch(text) ! switch array to a single character variable
             deallocate(text)    ! release memory
             write(*,*)dirty_sha256(string),len(string),trim(filename) ! write digest value
          endif
       enddo
    end program demo_dirty_sha256

  Sample output:

    FA9D11011034F1081A367D4F2F1EB909AC0849FF090A9320B6824156C5628DFD        2011 dynamic_dummy_arrays.f90
    FE48473BC7B9C13067EC2C108CB8A650A186605D5F905736D9CB9DE76E9A1A21        5444 fspiro.f90
    306CDB5BB2A8C30C711FA5D35A6A12F4FDB4F003ED77438E922B56BBA1024F49       27108 pprint.f90
