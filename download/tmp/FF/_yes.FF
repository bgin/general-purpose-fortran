$ifdef TESTPRG90
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
! this is a utility program. It is typically built using ccall(1).
!-----------------------------------------------------------------------------------------------------------------------------------
program yes                                                         ! combine yes(1),repeat(1),watch(1),xargs(1). Start with yes(1)
   use M_kracken, only : kracken, lget, sget, iget                  ! add command-line parser module
   !!use M_kracken, only : show
   use M_debug,   only : debug
   implicit none
   character(len=1024) :: string
   integer             :: ios
   integer             :: repeat
   integer             :: i
!-----------------------------------------------------------------------------------------------------------------------------------
   !!debug=.true.
   call kracken('yes','-help .false. -version .false. -repeat -1 ') ! define command arguments,default values and crack command line
!-----------------------------------------------------------------------------------------------------------------------------------
   !!call show('',.false.,0)
   call help_usage(lget('yes_help'))                                ! if -help option is present, display help text and exit
   call help_version(lget('yes_version'))                           ! if -version option is present, display version text and exit
!-----------------------------------------------------------------------------------------------------------------------------------
   string = trim(sget('yes_oo'))                                    ! get -oo STRING
   if(string.eq.' ')then                                            ! if string is blank use default
      string='y'
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   repeat=iget('yes_repeat')
!-----------------------------------------------------------------------------------------------------------------------------------
   if(repeat.eq.-1)then
      INFINITE: do                                                  ! print string in a loop until an error occurs
         write(*,'(a)',iostat=ios) trim(string)
      enddo INFINITE
   else
      REP: do i=1,repeat
         write(*,'(a)',iostat=ios) trim(string)
      enddo REP
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
contains
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$DOCUMENT VERSION
PRODUCT:        GPF (General Purpose Fortran) utilities and examples
PROGRAM:        _yes(1)
DESCRIPTION:    output a string repeatedly until killed or limit is reached
VERSION:        1.0, 20150508
AUTHOR:         John S. Urban
REPORTING BUGS: http://www.urbanjost.altervista.org/
HOME PAGE:      http://www.urbanjost.altervista.org/index.html
LICENSE:        Public Domain. This is free software: you are free to change and redistribute it.
                There is NO WARRANTY, to the extent permitted by law.
$DOCUMENT END
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$DOCUMENT HELP -file _yes.1.man
NAME
    _yes(1f) - [FUNIX] output a string repeatedly until killed or limit is reached

SYNOPSIS
    _yes [STRING[-repeat N]]|[--help|--version]

DESCRIPTION
    _yes(1) prints the command line arguments, separated by spaces and followed
    by a newline until the repeat count is reached or endlessly until it is
    killed. If no arguments are given, it prints "y" followed by a newline
    endlessly until killed. Upon a write error, _yes(1) exits with status "1".

OPTIONS
    -repeat N  specify number of times to display string
    --help     display this help and exit
    --version  output version information and exit

EXAMPLES
    Sample commands

       # repeat a command 20 times, pausing and clearing:
       _yes  date --repeat 20  |xargs -iXX  sh -c 'XX;sleep 2;clear'

REPORTING BUGS
    Report _yes bugs to <http://www.urbanjost.altervista.org/index.html>

SEE ALSO
    yes(1), repeat(1), xargs(1)
$DOCUMENT END
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
end program yes
$endif
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$ifdef UFPP_TEST
$!==================================================================================================================================
$!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
$!==================================================================================================================================
   This begins the section that will be processed by ufpp. Typically it is called by
   ufpp -system -html -i FILENAME
   if $SYSTEM commands are trusted

 UNIT TEST OF _yes

$SYSTEM mkdir -p tmp/
$SYSTEM goodbad _yes start -section 1

        Make sure test executable does not exist.
        Test executable should start with underscore and be unique or you could remove a command
$SYSTEM rm -f `which __yes 2>/dev/null||echo NOTTHERE`

        Build test program in standard location
$SYSTEM html2f90 < _yes.ff >tmp/__yes.F90
$SYSTEM ccall tmp/__yes.F90

        Execute test program
$SYSTEM [ `__yes -repeat 20|sum|sed -e 's/  */_/'` = 40541_1 ] && goodbad _yes good -section 1|| goodbad _yes bad -section 1
$SYSTEM [ `__yes this is a test|head -100|sum|sed -e 's/  */_/'` = 31080_2 ] && goodbad _yes good -section 1|| goodbad _yes bad -section 1

        Remove test source
$SYSTEM rm tmp/__yes.F90
        Remove test executable
$SYSTEM rm -f `which __yes 2>/dev/null|| echo NOTTHERE`
$!==================================================================================================================================
$!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
$!==================================================================================================================================
$ENDIF
