The VOGLE graphics library ( Very Ordinary Graphics Learning Environment )

Version 1.3.0

VOGLE is a portable public-domain device-independent C-based graphics
library from the The University of Melbourne that is loosely based on
the Silicon Graphics Iris GL library. It was also partly inspired by the
DIGS library developed at the U.S. Naval Academy under the guidance of
Prof David Rogers.

The original authors no longer actively maintain VOGLE. This version
is a modified copy of the source files for VOGLE from the FTP site of
gondwana.ecr.mu.oz.au.

This version of VOGLE has the following significant alterations:

  * To avoid name collisions with other libraries, all the C/C++ routines had the prefix "draw_" added to their names.
  * The Fortran interface was rewritten to the ISO_C_BINDING standard. Therefore, your Fortran compiler must support this part of
    the Fortran 2003 standard.

Many additional output devices are available

  * FrameMaker MIF 3.0 (Maker Interchange File) driver.
  * Adobe PDF driver.
  * HTML5 Canvas driver.
  * SVG driver.
  * A PCL5/HPGL2 driver that supports prefsize() calls.
  * Monochrome PBM (Poskazner bitmap P1 and P4 formats) and X11 bitmap driver.
  * Color PBM (Poskazner pixmap P3 and P6 formats). If you have the pbmplus package you can use it to make VOGLE appear to write
    any format pbmplus writes (assuming your system supports the popen(3c) function).
  * A clear-text CGM (Computer Graphics Metafile) driver.
  * A different (color) PostScript driver.
  * A driver for Microsoft VML (Vector Markup Language)

VOGLE is intended to produce simple graphics composed of line drawings and polygon fills in two and three dimensions. It handles
circles, curves, arcs, patches, polygons, and software text in a device independent fashion. Simple hidden line removal is also
available via polygon backfacing. Access to hardware text and double buffering of drawings depends on the driver.

VOGLE is callable from C, FORTRAN 77, Fortran 90+ , and Pascal on most platforms.

VOGLE is portable. It has been used on Cray UNICOS, SGI IRIX64 and IRIX, IBM AIX, NeXT, Digital ULTRIX and Digital Unix, Sun SunOS
and Solaris, Linux, Compaq Tru64 UNIX, HP HP-UX, and CygWin. It has been run on additional platforms including most PCs.

The original source's ownership statement

This software is public domain and may be used for any purpose commercial or otherwise. It is offered without any guarantee as to
its suitability for any purpose or as to the sanity of its writers. The authors do ask that the source is passed on to anyone that
requests a copy, and that people who get copies don't go round claiming they wrote it. Use at your own risk.

Some features are not maintained in this copy

    NB:
    My primary interest in VOGLE is that it is a vector-based graphics library that I find easy to support and port as needed for
    basic graphics work. I am only interested in a C/C++/Fortran copy for UNIX/Linux/CygWin machines at this time so the source
    here does not support the Pascal interface nor the native MS Windows environment (except via CygWin). You should examine a
    fresh copy from the original source if you are interested in VOGLE with those interfaces.

-----------------------------------------------------------------------------------------------------------------------------------
up

  * Created: 19960717

User Manual, Version 1.3.0

                                                   LIBRARY FUNCTION DESCRIPTIONS
+---------------------------------------------------------------------------------------------------------------------------------+
|Sub-Program Name                   |                                         Description                                         |
|---------------------------------------------------------------------------------------------------------------------------------|
|                                                         Device Routines                                                         |
|---------------------------------------------------------------------------------------------------------------------------------|
|vinit(device)                      |Initialise device                                                                            |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|vexit()                            |Reset window/terminal (must be last routine called)                                          |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|voutput(path)                      |Redirect output from *next* vinit to file                                                    |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|vnewdev(device)                    |Reinitialize to use new device without changing                                              |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|vgetdev(device)                    |Get name of current device                                                                   |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|pushdev(device)                    |push current device onto a stack                                                             |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|popdev(device)                     |pop device from stack created by pushdev.                                                    |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|getdepth()                         |Return number of bit planes (color planes)                                                   |
|---------------------------------------------------------------------------------------------------------------------------------|
|                                                 Routines For Setting Up Windows                                                 |
|---------------------------------------------------------------------------------------------------------------------------------|
|prefposition(x, y)                 |Specify preferred position of window                                                         |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|prefsize(width, height)            |Specify preferred width and height of window                                                 |
|---------------------------------------------------------------------------------------------------------------------------------|
|                                                        Clipping Routines                                                        |
|---------------------------------------------------------------------------------------------------------------------------------|
|clipping(onoff)                    |Turn clipping on or off                                                                      |
|---------------------------------------------------------------------------------------------------------------------------------|
|                                                         Color Routines                                                          |
|---------------------------------------------------------------------------------------------------------------------------------|
|clear()                            |Clears screen to current color                                                               |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|color(col)                         |Set current color                                                                            |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|mapcolor(indx, red, green, blue)   |Set color map index                                                                          |
|---------------------------------------------------------------------------------------------------------------------------------|
|                                                      Interactive Routines                                                       |
|---------------------------------------------------------------------------------------------------------------------------------|
|getkey()                           |Return ASCII ordinal of next key typed                                                       |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|checkkey()                         |Returns zero if no key is pressed or ASCII ordinal                                           |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|getstring(bcol, string)            |Read in a string, echoing it in current font                                                 |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|locator(xaddr, yaddr)              |Find out where cursor is                                                                     |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|slocator(xaddr, yaddr)             |Find out where cursor is in screen coordinates                                               |
|---------------------------------------------------------------------------------------------------------------------------------|
|                                                            Flushing                                                             |
|---------------------------------------------------------------------------------------------------------------------------------|
|vsetflush(yesno)                   |Set global flushing status                                                                   |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|vflush()                           |Call device flush or syncronisation routine                                                  |
|---------------------------------------------------------------------------------------------------------------------------------|
|                                                        Viewport Routines                                                        |
|---------------------------------------------------------------------------------------------------------------------------------|
|viewport(left, right, bottom, top) |Specify which part of screen to draw in                                                      |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|pushviewport()                     |Save current viewport                                                                        |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|popviewport()                      |Retrieve last viewport                                                                       |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|getviewport(left, right, bottom,   |Returns limits of current viewport in screen coordinates                                     |
|top)                               |                                                                                             |
|---------------------------------------------------------------------------------------------------------------------------------|
|                                                   Getting the aspect details                                                    |
|---------------------------------------------------------------------------------------------------------------------------------|
|getaspect()                        |Returns the ratio height over width of the display device.                                   |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|getfactors(wfact, hfact)           |Returns width over min(width of device, height of device) and height over min(width of       |
|                                   |device, height of device).                                                                   |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|getdisplaysize(w, h)               |Returns width and height of device in pixels                                                 |
|---------------------------------------------------------------------------------------------------------------------------------|
|                                                    Attribute Stack Routines                                                     |
|---------------------------------------------------------------------------------------------------------------------------------|
|pushattributes()                   |Save the current attributes on the attribute stack.                                          |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|popattributes()                    |Restore attributes to what they were at last pushattributes().                               |
|---------------------------------------------------------------------------------------------------------------------------------|
|                                                       Projection Routines                                                       |
|---------------------------------------------------------------------------------------------------------------------------------|
|ortho(left, right, bottom, top,    |Define x,y,z clipping planes.                                                                |
|near, far)                         |                                                                                             |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|ortho2(left, right, bottom, top)   |Define x and y clipping planes.                                                              |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|perspective(fov, aspect, near, far)|Specify perspective viewing pyramid                                                          |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|window(left, right, bot, top, near,|Specify a perspective viewing pyramid                                                        |
|far)                               |                                                                                             |
|---------------------------------------------------------------------------------------------------------------------------------|
|                                                      Matrix Stack Routines                                                      |
|---------------------------------------------------------------------------------------------------------------------------------|
|pushmatrix()                       |Save the current transformation matrix on the matrix stack.                                  |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|popmatrix()                        |Reinstall the last matrix pushed                                                             |
|---------------------------------------------------------------------------------------------------------------------------------|
|                                                       Viewpoint Routines                                                        |
|---------------------------------------------------------------------------------------------------------------------------------|
|polarview(dist, azim, inc, twist)  |Specify the viewer's position in polar coordinates                                           |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|up(x, y, z)                        |Specify the world up.                                                                        |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|lookat(vx, vy, vz, px, py, pz,     |Specify the viewer's position                                                                |
|twist)                             |                                                                                             |
|---------------------------------------------------------------------------------------------------------------------------------|
|                                                          Move Routines                                                          |
|---------------------------------------------------------------------------------------------------------------------------------|
|move(x, y, z)                      |Move current graphics position to (x, y, z)                                                  |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|rmove(deltax, deltay, deltaz)      |Relative move                                                                                |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|move2(x, y)                        |Move graphics position to point (x, y)                                                       |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|rmove2(deltax, deltay)             |Relative move in world units.                                                                |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|smove2(x, y)                       |Move current graphics position in screen coordinates (-1.0 to 1.0).                          |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|rsmove2(deltax, deltay)            |Relative move in screen units (-1.0 to 1.0).                                                 |
|---------------------------------------------------------------------------------------------------------------------------------|
|                                                       LineStyle Routines                                                        |
|---------------------------------------------------------------------------------------------------------------------------------|
|linewidth()                        |set line width in rasters                                                                    |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|dashcode()                         |set dash pattern length                                                                      |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|linestyle()                        |set the line dash pattern                                                                    |
|---------------------------------------------------------------------------------------------------------------------------------|
|                                                          Draw Routines                                                          |
|---------------------------------------------------------------------------------------------------------------------------------|
|draw(x, y, z)                      |Draw from current graphics position to (x, y, z)                                             |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|rdraw(deltax, deltay, deltaz)      |Relative draw                                                                                |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|draw2(x, y)                        |Draw from current graphics position to point (x, y)                                          |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|rdraw2(deltax,deltay)              |Relative draw                                                                                |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|sdraw2(x, y)                       |Draw in screen coordinates (-1.0 to 1.0).                                                    |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|rsdraw2(deltax, deltay)            |Relative draw in screen units (-1.0 to 1.0).                                                 |
|---------------------------------------------------------------------------------------------------------------------------------|
|                                                        Arcs and Circles                                                         |
|---------------------------------------------------------------------------------------------------------------------------------|
|circleprecision(nsegs)             |Set number of line segments in a circle. Default is 32.                                      |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|arc(x, y, radius, startang, endang)|Draw an arc in world units.                                                                  |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|sector(x, y, radius, startang,     |Draw a sector. Note: sectors are polygons.                                                   |
|endang)                            |                                                                                             |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|circle(x, y, radius)               |Draw a circle. Note: circles are polygons.                                                   |
|---------------------------------------------------------------------------------------------------------------------------------|
|                                                         Curve Routines                                                          |
|---------------------------------------------------------------------------------------------------------------------------------|
|curvebasis(basis)                  |Define a basis matrix for a curve.                                                           |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|curveprecision(nsegs)              |Define number of line segments used to draw a curve.                                         |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|rcurve(geom)                       |Draw a rational curve.                                                                       |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|curve(geom)                        |Draw a curve.                                                                                |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|curven(n, geom)                    |Draw n - 3 overlapping curve segments. Note: n must be at least 4.                           |
|---------------------------------------------------------------------------------------------------------------------------------|
|                                             Rectangles and General Polygon Routines                                             |
|---------------------------------------------------------------------------------------------------------------------------------|
|rect(x1, y1, x2, y2)               |Draw a rectangle.                                                                            |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|polyfill(onoff)                    |Set the polygon fill flag                                                                    |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|polyhatch(onoff)                   |Set the polygon hatch flag                                                                   |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|hatchang(angle)                    |Set the angle of the hatch lines.                                                            |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|hatchpitch(pitch)                  |Set the distance between hatch lines.                                                        |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|poly2(n, points)                   |Construct an (x, y) polygon from an array of points                                          |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|poly(n, points)                    |Construct a polygon from an array of points                                                  |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|makepoly()                         |opens polygon constructed by a series of move-draws and closed by closepoly                  |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|closepoly()                        |Terminates a polygon opened by makepoly.                                                     |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|backface(onoff)                    |Turns on culling of backfacing polygons.                                                     |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|backfacedir(clockwise)             |Sets backfacing direction to clockwise or anti-clockwise                                     |
|---------------------------------------------------------------------------------------------------------------------------------|
|                                                          Text Routines                                                          |
|---------------------------------------------------------------------------------------------------------------------------------|
|font(fontname)                     |Set the current font                                                                         |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|numchars()                         |Return number of characters in the current SOFTWARE font.                                    |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|textsize(width, height)            |Set maximum size of a character in the current SOFTWARE font.                                |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|textang(ang)                       |Set the SOFTWARE text angle.                                                                 |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|fixedwidth(onoff)                  |Turns fixedwidth mode on or off for SOFTWARE fonts.                                          |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|centertext(onoff)                  |Turns centertext mode on or off for SOFTWARE fonts.                                          |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|getcharsize(c, width, height)      |Get the width and height of a character.                                                     |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|getfontdec()                       |Return size of maximum font descender                                                        |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|getfontsize(width, height)         |Get maximum width and height of a character in a font.                                       |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|drawchar(c)                        |Draw the character c and update current position.                                            |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|drawstr(str)                       |Draw the text in string at the current position.                                             |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|strlength(str)                     |Return the length of the string s                                                            |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|boxtext(x, y, l, h, s)             |Draw the SOFTWARE string s so that it fits in the imaginary box                              |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|boxfit(x, y, l, h, s)              |resize the SOFTWARE text size so it fits in a box                                            |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|textjustify(val)                   |general text justification (C only)                                                          |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|leftjustify()                      |left justify text                                                                            |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|rightjustify()                     |right justify text                                                                           |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|xcentertext()                      |center text in the X direction                                                               |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|topjustify()                       |top justify text                                                                             |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|bottomjustify()                    |bottom justify text                                                                          |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|ycentertext()                      |center text in the Y direction                                                               |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|textslant()                        |Defines the obliqueness of the fonts.                                                        |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|textweight()                       |Defines the weight of the fonts.                                                             |
|---------------------------------------------------------------------------------------------------------------------------------|
|                                                    Transformations Routines                                                     |
|---------------------------------------------------------------------------------------------------------------------------------|
|translate(x, y, z)                 |Set up a translation.                                                                        |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|scale(x, y, z)                     |Set up scaling factors in x, y, and z axis.                                                  |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|rotate(angle, axis)                |Set up a rotation in axis axis where axis is one of 'x','y', or 'z'.                         |
|---------------------------------------------------------------------------------------------------------------------------------|
|                                                         Patch Routines                                                          |
|---------------------------------------------------------------------------------------------------------------------------------|
|patchbasis(tbasis, ubasis)         |Define the t and u basis matrices of a patch.                                                |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|patchprecision(tseg, useg)         |Set minimum number of line segments making up curves in a patch.                             |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|patchcurves(nt, nu)                |Set the number of curves making up a patch.                                                  |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|rpatch(gx, gy, gz, gw)             |Draws a rational patch in the current basis, according to the geometry matrices gx, gy, gz,  |
|                                   |and gw.                                                                                      |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|patch(gx, gy, gz)                  |Draws a patch in the current basis, according to the geometry matrices gx, gy, and gz.       |
|---------------------------------------------------------------------------------------------------------------------------------|
|                                                         Point Routines                                                          |
|---------------------------------------------------------------------------------------------------------------------------------|
|point(x, y, z)                     |Draw a point at x, y, z                                                                      |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|point2(x, y)                       |Draw a point at x, y.                                                                        |
|---------------------------------------------------------------------------------------------------------------------------------|
|                                                         Object Routines                                                         |
|---------------------------------------------------------------------------------------------------------------------------------|
|makeobj(n)                         |Commence the object number n.                                                                |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|closeobj()                         |Close the current object.                                                                    |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|genobj()                           |Returns a unique object identifier.                                                          |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|getopenobj()                       |Return the number of the current object.                                                     |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|callobj(n)                         |Draw object number n.                                                                        |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|isobj(n)                           |Returns non-zero if there is an object of number n.                                          |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|delobj(n)                          |Delete the object number n.                                                                  |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|loadobj(n, filename)               |Load the object in the file filename as object number n.                                     |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|saveobj(n, filename)               |Save object number n into file filename. Does NOT save objects called inside object n.       |
|---------------------------------------------------------------------------------------------------------------------------------|
|                                                        Double Buffering                                                         |
|---------------------------------------------------------------------------------------------------------------------------------|
|backbuffer()                       |Draw in the backbuffer. Returns -1 if the device is not up to it.                            |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|frontbuffer()                      |Draw in the front buffer. This will always work.                                             |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|swapbuffers()                      |Swap the front and back buffers.                                                             |
|---------------------------------------------------------------------------------------------------------------------------------|
|                                                        Position Routines                                                        |
|---------------------------------------------------------------------------------------------------------------------------------|
|getgp(x, y, z)                     |Gets the current graphics position                                                           |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|getgp2(x, y)                       |Gets the current graphics position                                                           |
|-----------------------------------+---------------------------------------------------------------------------------------------|
|sgetgp2(x, y)                      |Gets the current screen graphics position in screen coords (-1 to 1)                         |
+---------------------------------------------------------------------------------------------------------------------------------+
-----------------------------------------------------------------------------------------------------------------------------------
up

  * Created: 19960717

-----------------------------------------------------------------------------------------------------------------------------------

Routines For Setting Up Windows.

-----------------------------------------------------------------------------------------------------------------------------------

Some devices are basically window oriented - like sunview and X11. You can give vogle some information on the window that it will
use with these routines. These can make your code very device independent. Both routines take arguments which are in device space.
(0, 0) is the top left hand corner in device space. To have any effect these routines must be called before vinit. For the X11
device, an entry may be made in your .Xdefaults file or loaded in with the xrdb(1) command:

   xrdb <<\EOF
   ! X11 Windows fonts to use for "small" and "large" fonts
   vogle*smallfont: fixed
   vogle*largefont: 9x15
   ! title on decoration bar for the window
   vogle*title: My VOGLE program
   ! window geometry and position,
   ! overridden by prefsize(3c) and prefposition(3c)
   vogle.Geometry: =500x500-10+20
   EOF

(where you specify your geometry as you please).

-----------------------------------------------------------------------------------------------------------------------------------

prefposition(x, y)

Specify the preferred position of the window opened by the *next* vinit.

   Fortran:
        subroutine prefposition(x, y)
        integer x, y

   C:
        draw_prefposition(x, y)
             int  x, y;

   Pascal:
        procedure PrefPosition(x, y: integer)

-----------------------------------------------------------------------------------------------------------------------------------

prefsize(width, height)

Specify the preferred width and height of the window opened by the *next* vinit.

   Fortran:
        subroutine prefsize(width, height)
        integer width, height

   C:
        draw_prefsize(width, height)
             int  width, height;

   Pascal:
        procedure PrefSize(width, height: integer)

-----------------------------------------------------------------------------------------------------------------------------------
up

  * Created: 19960717

-----------------------------------------------------------------------------------------------------------------------------------

Device Routines

-----------------------------------------------------------------------------------------------------------------------------------

vinit(device)

Initialise the device.

    Fortran:
         subroutine vinit(device)
         character *(*) device

    C:
         draw_vinit(device);
         char     *device;

    Pascal:
         procedure Vinit(device: string_t)

 Note 1 :- Currently available devices are:

       INTERACTIVE DEVICES:
       --------------------
       PC   - native MSW PC driver; only tested from CygWin
       X11  - X11 windows (Black background)
       x11  - X11 windows (White background)
       tek  - tektronix 4010 and compatibles
       xtek - X11 xterm Tektronix 4010 emulator

       PRINTERS and PLOTTERS:
       ----------------------
          PostScript:
             [p]psm or [p]postscript - monochrome PostScript
             [p]psg - grayscale PostScript
             [p]psc - color PostScript
          HPGL:
             hpgl - HP Graphics language and compatibles
             [p]hpgl2 - HPGL level 2 (obeys prefsize calls)
          PCL:
             [p]pclland  - monochrome PCL5 (obeys prefsize calls)
             [p]pclport  - monochrome PCL5 (obeys prefsize calls)
             pcl5land (color PCL5 landscape)
             pcl5port (color PCL5 portrait)

       PIXMAPS (color)  and BITMAPS (monochrome)
       -----------------------------------------
       char   - An ASCII file that can be displayed to most
                xterm(1) terminal emulators that support
                color
       p1/pbm - Poskanzer (pbmplus/netplus) portable
                ASCII bitmap file
       p3/ppm - Poskanzer portable ASCII pixmap file
       p4     - Poskanzer portable binary bitmap file
       p6     - Poskanzer portable binary pixmap file
       xbm    - X11 bitmap file
       bm     - bitmap format for atobm(1)

       METAFILES
       ---------
       PRODUCT INPUT FILES:
       mif      - FrameMaker Interchange Format 3.0 (MIF) files
                  (16 colors)
       mif4     - FrameMaker Interchange Format 4.0 (MIF) files
                  (user-definable colors, but breaks a MIF rule)
       xfig     - X11 xfig(1) figure utility

       METAFILES WITH POST_PROCESSORS/CONVERTERS:
       cgmt     - a clear-text CGM (Computer Graphics Metatfile)
       gnu      - GNU plot(1) metafile
       pdf      - Adobe Public Document Format
       unixplot - Unix plot(1) metafile

       BROWSER FILES:
       canvas   - HTML5 CANVAS graphics element file
       svg      - Scalable Vector Graphics
       usemap   - HTML image map
       vml      - Microsoft Vector Markup Language

       FILES:
       vog      - Vogle low level call (debug)

       OTHER:
       ------
       fti   - SGI vector-based icons
       null  - no output

     :- Drivers I've dropped but code is there for
     ---------------------------------------------

       grwin (minGW GRwin PC interface)
       decX11 - the decstation window manager
       dxy - roland DXY plotter language
       sun - Sun workstations running sunview
       next - NeXTStep and other NeXT platforms
       apollo - Apollo workstations

     :- Drivers I've dropped but are in the original distribution
     ------------------------------------------------------------

       hercules - IBM PC hercules graphics card
       cga - IBM PC cga graphics card
       ega - IBM PC ega graphics card
       vga - IBM PC vga graphics card
       sigma - IBM PC sigma graphics card.
       mswin - IBM PC Microsoft Windows.

    Note 2 :- If device is a NULL or a null string the value
         of the environment variable "VDEVICE" is taken as the
         device type to be opened. The format of the variable is

            VDEVICE [ xsize [ ysize [ xoffset [ yoffset ] ] ]

         That is, if present xsize and ysize will be used
         in a call to prefsize(3c), and xoffset and yoffset will
         be used in a call to preposition(3c).

    Note 3 :- after vinit() it is wise to explicitly clear the screen.
    e.g.: in C
         color(BLACK);
         clear();

    or    in Fortran
         call color(BLACK)
         call clear

    or    in Pascal
         Color(BLACK);
         Clear;

    Note 4 :  Sun, X11, decX11, apollo, hercules, cga and ega support
              double buffering.


Notes:

gnu

The GNU plotutils package includes a program called plot(1) that can read in the gnu metafile and render images on an X11 display,
PNG (Portable Network Graphics) format, portable anymap format (PBM/PGM/PPM), a pseudo-GIF format that does not use LZW encoding,
the new XML-based Scalable Vector Graphics format, the format used by Adobe Illustrator, Postscript or Encapsulated Postscript
(EPS) that can be edited with idraw(1), CGM format (by default, confirming to the WebCGM profile), the format used by the xfig(1)
drawing editor, the Hewlett-Packard PCL 5 printer language, the Hewlett-Packard Graphics Language, ReGIS graphics format (which can
be displayed by the dxterm(1) terminal emulator or by a VT330 or VT340 terminal), Tektronix format (which can be displayed by the
xterm(1) terminal emulator), and device-independent GNU metafile format itself.

pdf

Popular PDF readers are the Adobe PDF viewer, which is often callable from Web browsers; the GhostScript-based gv(1) utility; or
the xpdf program.

    The xpdf(1) software , related utilities ( pdftops(1), pdftotext(1), pdfinfo(1), pdffonts(1), pdftoppm(1), pdfimages(1), xpdfrc
    (5)) and documentation are copyright 1996-2004 Glyph & Cog, LLC. at http://www.foolabs.com/xpdf/

The GhostScript-based tools can convert PDF files to PostScript as well as view the files.

cgmt

The ralcgm(1) and gplot(1) packages are two very complete CGM viewers.

ppm,pbm (and p1,p3,p4,p6)

  * p1/pbm - Poskanzer (pbmplus/netplus) portable ASCII bitmap file
  * p3/ppm - Poskanzer portable ASCII pixmap file
  * p4 - Poskanzer portable binary bitmap file
  * p6 - Poskanzer portable binary pixmap file

The NetPBM package is available for almost every platform and lets you convert the Poskanzer portable pixmap (PPM) files to just
about any pixmap or bitmap format, including PNG, JPEG, GIF/PseudoGIF, BPM, ..... Other popular pixmap products such as
ImageMagick, gv, ... can read PPM files, convert them, and often edit them.

HTML

The vml, canvas, svg, and usemap drivers are primarily used to generate graphics for inclusion in HTML documents. Browsers such as
Opera, Safari, Foxfire, and Chrome can easily incorporate graphics generated using the SVG (Scalable Vector Graphics) format or the
HTML5 CANVAS element.

usemap

This driver writes out the edges of any polygon in a format that can be used with an HTML image map; if the same sizes are used a
plot generated with the ppm driver; you will have clickable regions in your pixmap when converted to a GIF image.

If the polygons overlap you need to reverse the order of the polygon definitions in the output file. The numeric field in the<AREA>
titles should help.

vml

The VML format can be read in by any MicroSoft Office 2000+ product and MicroSoft's web browser Internet Explorer. If the plots
contain more than about 9766 vectors MicroSoft Word starts choking (still true in 2005), but otherwise this is a very nice way to
generate input for MicroSoft products.

I generally use this on a machine running MicroSoft Windows by installing CygWin with the X11 options (and ralcgm, the GhostScript
software, the GNU plotutils packages and netpbm).

xfig

The xfig(1) command can be used to edit graphics generated with the VOGLE graphics library; and to convert the xfig(1)-format file
to many other output formats. If you are generating pixmaps with the PPM driver and want to use them as image maps in your HTML
documents the usemap driver can be used.

If you have xfig(1) installed, you will find that calling fig2dev(1) allows you to generate many output formats from a single file,
including LaTex and encapsulated PostScript.

xfig(1) is an X11 Windows application that can be used to interactively edit figures. The HELP utility of xfig(1) provides a
description of the xfig(1) file format (as well as a user guide and many other documents).

Unfortunately, the manual indicates the user defined colors must be defined before any other Fig objects. By default, 16 colors are
defined. If undefined colors are used they are assigned a dash pattern or a fill pattern to help distinguish them. Use of hardware
dash and VOGLE software dash could get confusing.

Also, in the current driver version all lines are drawn as a series of move-draw vectors, which can make the files relatively very
large.

multiple pages appear to only work with the PostScript and PDF drivers of xfig(1); and even then pages must be all positive numbers
from left to right and top to bottom, printing all pages in a rectangular area.

Alternatively, could use depth to keep up to 999 pages separate

-----------------------------------------------------------------------------------------------------------------------------------

vexit()

Reset the window/terminal (must be the last VOGLE routine called)


    Fortran:
         subroutine vexit

    C:
         draw_vexit()

    Pascal:
         procedure Vexit;

-----------------------------------------------------------------------------------------------------------------------------------

voutput(path)

Redirect output from *next* vinit() to file given by path. This routine only applies to device drivers that write to stdout e.g.
PostScript and hpgl.

The special file names are

  * - is standard output
  * + is standard error
  * |command will create a pipe to "command"

If the open of the file fails, an attempt is made to append to file "VOUTPUT". If this fails, standard output is used.

When vinit() is called if voutput() has not been called then the environment variable VOUTPUT is checked and if it is defined and
not a null string then voutput() is called with the VOUTPUT variable's value.

A common use of the |command option is to automatically call programs that convert PPM files to other common pixmap formats or
converts the GNU metafile to other formats (typically via the GNU plotutils plot program).

    Fortran:
         subroutine voutput(path)
         character*(*) path

    C:
         draw_voutput(path)
              char *path;

    Pascal:
         procedure Voutput(path: string_t)

-----------------------------------------------------------------------------------------------------------------------------------

vnewdev(device)

Reinitialize VOGLE to use a new device without changing attributes, viewport etc. (eg. window and viewport specifications)

    Fortran:
         subroutine vnewdev(device)
         character *(*) device

    C:
         draw_vnewdev(device)
              char *device;

    Pascal:
         VnewDev(device: string_t)

-----------------------------------------------------------------------------------------------------------------------------------

vgetdev(device)

Gets the name of the current VOGLE device. The C version of the routine also returns a pointer to it's argument.

    Fortran:
         subroutine vgetdev(device)
         character *(*) device

    C:
         char * draw_vgetdev(device)
              char *device;

    Pascal:
         procedure VgetDev(var device: string_t)

-----------------------------------------------------------------------------------------------------------------------------------

getdepth()

Returns the number of bit planes (or color planes) for a particular device. The number of colors displayable by the device is then
2**(nplanes); ie. if nplanes=1,then there are two colors (black and white).

    Fortran:
         integer function  getdepth()

    C:
         int
         draw_getdepth()

    Pascal:
         function GetDepth(): integer;

-----------------------------------------------------------------------------------------------------------------------------------

pushdev()

Initialize a new device without changing attributes, viewport etc, but save the previously initialised device on a stack.

Note, this is intended to completely change the device, it won't work if you pushdev the same device that you are already running.
(This will be fixed at a later date).


    Fortran:
         subroutine pushdev(device)
         character *(*) device

    C:
         draw_pushdev(device)
         char *device;

    Pascal:
         PushDev(device: string_t)

-----------------------------------------------------------------------------------------------------------------------------------

popdev()

Pops a device off the device stack and reinstates the previously pushed device.

     Fortran:
          subroutine popdev()

     C:
          draw_popdev()

     Pascal:
          PopDev

-----------------------------------------------------------------------------------------------------------------------------------
up

  * Created: 19960717

-----------------------------------------------------------------------------------------------------------------------------------

Move Routines.

-----------------------------------------------------------------------------------------------------------------------------------

move(x, y, z)

Move current graphics position to (x, y, z). (x, y, z) is a point in world coordinates.

    Fortran:
         subroutine move(x, y, z)
         real x, y, z

    C:
         draw_move(x, y, z)
              float     x, y, z;

    Pascal:
         procedure Move(x, y, z: real)

-----------------------------------------------------------------------------------------------------------------------------------

rmove(deltax, deltay, deltaz)

Relative move. deltax, deltay, and deltaz are offsets in world units.

    Fortran:
         subroutine rmove(deltax, deltay, deltaz)
         real deltax, deltay, deltaz

    C:
         draw_rmove(deltax,deltay)
              float   deltax, deltay, deltaz;

    Pascal:
         procedure Rmove(deltax, deltay, deltaz: real)

-----------------------------------------------------------------------------------------------------------------------------------

move2(x, y)

Move graphics position to point (x, y). (x, y) is a point in world coordinates.

    Fortran:
         subroutine move2(x, y)
         real x, y

    C:
         draw_move2(x, y)
              float     x, y;

    Pascal:
         procedure Move2(x, y: real)

-----------------------------------------------------------------------------------------------------------------------------------

rmove2(deltax, deltay)

Relative move2. deltax and deltay are offsets in world units.

    Fortran:
         subroutine rmove2(deltax, deltay)
         real deltax, deltay

    C:
         draw_rmove2(deltax, deltay)
              float     deltax, deltay;

    Pascal:
         procedure Rmove2(deltax, deltay: real)

-----------------------------------------------------------------------------------------------------------------------------------

smove2(x, y)

Move current graphics position in screen coordinates (-1.0 to 1.0).

    Fortran:
         subroutine smove2(x, y)
         real x, y

    C:
         draw_smove2(x, y)
              float     x, y;

    Pascal:
         procedure Smove2(x, y: real)

-----------------------------------------------------------------------------------------------------------------------------------

rsmove2(deltax, deltay)

Relative smove2. deltax, and deltay are offsets in screen units (-1.0 to 1.0).

    Fortran:
         subroutine rsmove2(deltax, deltay)
         real deltax, deltay

    C:
         draw_rsmove2(deltax, deltay)
              float     deltax, deltay;

    Pascal:
         procedure Rsmove2(deltax, deltay: real)

-----------------------------------------------------------------------------------------------------------------------------------
up

  * Created: 19960717

-----------------------------------------------------------------------------------------------------------------------------------

Drawing Routines.

-----------------------------------------------------------------------------------------------------------------------------------

draw(x, y, z)

Draw from current graphics position to (x, y, z). (x, y, z) is a point in world coordinates.

    Fortran:
         subroutine draw(x, y, z)
         real x, y, z

    C:
         draw_draw(x, y, z)
              float     x, y, z;

    Pascal:
         procedure Draw(x, y, z: real)

-----------------------------------------------------------------------------------------------------------------------------------

rdraw(deltax, deltay, deltaz)

Relative draw. deltax, deltay, and deltaz are offsets in world units.

    Fortran:
         subroutine rdraw(deltax, deltay, deltaz)
         real deltax, deltay, deltaz

    C:
         draw_rdraw(deltax, deltay, deltaz)
              float   deltax, deltay, deltaz;

    Pascal:
         procedure Rdraw(deltax, deltay, deltaz: real)

-----------------------------------------------------------------------------------------------------------------------------------

draw2(x, y)

Draw from current graphics position to point (x, y). (x, y) is a point in world coordinates.

    Fortran:
         subroutine draw2(x, y)
         real x, y

    C:
         draw_draw2(x, y)
              float     x, y;

    Pascal:
         procedure Draw2(x, y: real)

-----------------------------------------------------------------------------------------------------------------------------------

rdraw2(deltax,deltay)

Relative draw2. deltax and deltay are offsets in world units.

    Fortran:
         subroutine rdraw2(deltax, deltay)
         real deltax, deltay

    C:
         draw_rdraw2(deltax, deltay)
              float   deltax, deltay;

    Pascal:
         procedure Rdraw2(deltax, deltay: real)

-----------------------------------------------------------------------------------------------------------------------------------

sdraw2(x, y)

Draw in screen coordinates (-1.0 to 1.0).

    Fortran:
         subroutine sdraw2(x, y)
         real x, y

    C:
         draw_sdraw2(x, y)
              float     x, y;

    Pascal:
         procedure Sdraw2(x, y: real)

-----------------------------------------------------------------------------------------------------------------------------------

rsdraw2(deltax, deltay)

Relative sdraw2. delatx and deltay are in screen units (-1.0 to 1.0).

    Fortran:
         subroutine rsdraw2(deltax, deltay)
         real deltax, deltay
    C:
         draw_rsdraw2(deltax, deltay)
              float     deltax, deltay;

    Pascal:
         procedure Rsdraw2(deltax, deltay: real)

-----------------------------------------------------------------------------------------------------------------------------------
up

  * Created: 19960717

-----------------------------------------------------------------------------------------------------------------------------------

Rectangles and General Polygon Routines.

A polygon is composed of a number of coplanar line segments connected end to end to form a closed shape.

In VOGLE curves are estimated by a series of line segments, and thus may be included easily into polygons.

-----------------------------------------------------------------------------------------------------------------------------------

Regular
    A polygon with all sides and interior angles the same. Regular polygons are always convex. See Regular Polygons
Irregular
    Each side may a different length, each angle may be a different measure. The opposite of a regular polygon. See Irregular
    Polygons
Convex
    All interior angles less than 180 ,and all vertices 'point outwards' away from the interior. The opposite of concave. Regular
    polygons are always convex. See Convex Polygons
Concave
    One or more interior angles greater than 180 . Some vertices push 'inwards' towards the interior of the polygon. The opposite
    of convex.
Self-intersecting or Crossed
    A polygon where one or more sides crosses back over another side, creating multiple smaller polygons. Most of the properties
    and theorems concerning polygons do not apply to this shape. It is best considered as several separate polygons.
    A polygon that in not self-intersecting in this way is called a simple polygon.

-----------------------------------------------------------------------------------------------------------------------------------
polygons
-----------------------------------------------------------------------------------------------------------------------------------

rect(x1, y1, x2, y2)

Draw a rectangle. Note: rectangles are regarded as polygons, so if polyfill or polyhatch has been called with 1, the rectangle will
be filled or hatched accordingly.

   Fortran:
      subroutine rect(x1, y1, x2, y2)
      REAL x1, y1, x1, y2
   C:
      draw_rect(x1, y1, x2, y2)
      float x1, y1, x2, y2;

   Pascal:
      procedure Rect(x1, y1, x2, y2: real)

rect

polyfill(onoff)

Set the polygon fill flag. This will always turn off hatching. A non-zero integer or LOGICAL .true. turns polyfill on.

   Fortran:
      subroutine polyfill(onoff)
      logical onoff
   C:
      draw_polyfill(onoff)
      int  onoff;
   Pascal:
      procedure PolyFill(onoff: boolean)

polyfill
-----------------------------------------------------------------------------------------------------------------------------------

polyhatch(onoff)

Set the polygon hatch flag. This will always turn off fill. A non-zero integer or LOGICAL .true. turns polyhatch on. Note that
hatched polygons must initially be defined parallel to the X-Y plane.

   Fortran:
      subroutine polyhatch(onoff)
      logical onoff
   C:
      draw_polyhatch(onoff)
      int onoff;

   Pascal:
      procedure PolyHatch(onoff: boolean)

polyhatch
-----------------------------------------------------------------------------------------------------------------------------------

hatchang(angle)

Set the angle of the hatch lines. The angle is in degrees. Zero degrees is on the negative X axis. Positive values are
counterclockwise. The value is 0 at program initialization. The last value set is retained even if hatching is not active or is
turned on and off.

   Fortran:
      subroutine hatchang(angle)
      real angle
   C:
      draw_hatchang(angle)
      float angle;

   Pascal:
      procedure HatchAng(angle: real)

polyhatch
-----------------------------------------------------------------------------------------------------------------------------------

hatchpitch(pitch)

Set the distance between hatch lines. The distance is measured in window units (as opposed to viewport or device units).

   Fortran:
      subroutine hatchpitch(pitch)
      real pitch
   C:
      draw_hatchpitch(pitch)
      float pitch;

   Pascal:
      procedure HatchPitch(pitch: real)

polyhatch
-----------------------------------------------------------------------------------------------------------------------------------

poly2(n, points)

Construct an (x, y) polygon from an array of points provided by the user.

   Fortran:
      subroutine poly2(n, points)
      integer n
      real points(2, n)
   C:
      draw_poly2(n, points)
      int n;
      float  points[][2];
   Pascal:
      procedure Poly2(n: integer; points: Poly2_array_t)

-----------------------------------------------------------------------------------------------------------------------------------

poly(n, points)

Construct a polygon from an array of points provided by the user.

   Fortran:
      subroutine poly(n, points)
      integer n
      real points(3, n)
   C:
      draw_poly(n, points)
         int n;
         float points[][3];

   Pascal:
      procedure Poly(n: integer; points: Poly3_array_t)

-----------------------------------------------------------------------------------------------------------------------------------

makepoly()

makepoly opens up a polygon which will then be constructed by a series of move-draws and closed by a closepoly.

   Fortran:
      subroutine makepoly
   C:
      draw_makepoly()
   Pascal:
      procedure MakePoly

-----------------------------------------------------------------------------------------------------------------------------------

closepoly()

Terminates a polygon opened by makepoly.

   Fortran:
      subroutine closepoly
   C:
      draw_closepoly()
   Pascal:
      procedure ClosePoly

-----------------------------------------------------------------------------------------------------------------------------------

backface(onoff)

Turns on culling of backfacing polygons. A polygon is backfacing if it's orientation in *screen* coords is clockwise, unless a call
to backfacedir is made.

   Fortran:
      subroutine backface(onoff)
      logical onoff
   C:
      draw_backface(onoff)
      int  onoff;
   Pascal:
      procedure BackFace(onoff: boolean)

-----------------------------------------------------------------------------------------------------------------------------------

backfacedir(clockwise)

Sets the backfacing direction to clockwise or anti-clockwise depending on whether clockwise is 1 or 0. 1 = clockwise (in screen
coords) 0 = anticlockwise.

   Fortran:
      subroutine backfacedir(clockwise)
      integer clockwise

   C:
      draw_backfacedir(clockwise)
      int  clockwise;
   Pascal:
      procedure BackFaceDir(clockwise: boolean)

-----------------------------------------------------------------------------------------------------------------------------------
up

  * Created: 19960717

-----------------------------------------------------------------------------------------------------------------------------------

Arcs and Circles

When creating arcs and sectors note that angles are measured in degrees; where zero(0) is the positive X axis in a right-handed
Cartesian coordinate system and positive angles sweep counterclockwise. If filling sectors or circles (As described in the section
on polygons) hatch pitch is measured in world coordinates and is initially set to 0.1. The intial hatch angle is zero(0).

-----------------------------------------------------------------------------------------------------------------------------------

circleprecision(nsegs)

Set the number of line segments making up a circle. Default is currently 32. The number of segments in an arc or sector is
calculated from the variable "nsegs" according to the span of the arc or sector.

   Fortran:
        subroutine circleprecision(nsegs)
        integer   nsegs
   C:
        draw_circleprecision(nsegs)
             int  nsegs;

   Pascal:
        procedure CirclePrecision(nsegs: integer)

circleprecision

circles are drawn with various circle precision values.

-----------------------------------------------------------------------------------------------------------------------------------

arc(x, y, radius, startang, endang)

Draw an arc. x, y, and radius are values in world units.

   Fortran:
        subroutine arc(x, y, radius, startang, endang)
        REAL x, y, radius, startang, endang
   C:
        draw_arc(x, y, radius, startang, endang)
             float  x, y, radius;
             float  startang, endang;

   Pascal:
        procedure Arc(x, y, radius, startang, endang: real)

Angles are in degrees, positive measured counterclockwise from the +X axis. The current position after the arc is drawn is at the
end of the arc.

arc

The arcs are drawn; followed by a draw to the arc center (using "draw2(X,Y)").

-----------------------------------------------------------------------------------------------------------------------------------

sector(x, y, radius, startang, endang)

Draw a sector. x, y, and radius are values in world units. Note: sectors are regarded as polygons, so if polyfill or polyhatch has
been called with 1, the sectors will be filled or hatched accordingly.

   Fortran:
        subroutine sector(x, y, radius, startang, endang)
        REAL x, y, radius, startang, endang
   C:
        draw_sector(x, y, radius, startang, endang)
             float  x, y, radius;
             float  startang, endang;

   Pascal:
        procedure Sector(x, y, radius, startang, endang: real)

sector
-----------------------------------------------------------------------------------------------------------------------------------

circle(x, y, radius)

Draw a circle. x, y, and radius are values in world units. Note: circles are regarded as polygons, so if polyfill or polyhatch has
been called with 1, the circle will be filled or hatched accordingly. x and y real coordinates in user units.

   Fortran:
        subroutine circle(x, y, radius)
        REAL x, y, radius
   C:
        draw_circle(x, y, radius)
             float     x, y, radius;

   Pascal:
        procedure Circle(x, y, radius: real)

circle

circles are drawn with polygon fill and hatch fill options. Multiple calls were used to create the filled, crosshatched and
outlined circle.

-----------------------------------------------------------------------------------------------------------------------------------
up

  * Created: 19960717

-----------------------------------------------------------------------------------------------------------------------------------

Point Routines.

points are drawn with the current color and linewidth. Points are currently device-specific and may appear as circles, squares, or
not at all; as they are generated by a zero-length vector using the hardware line style.

-----------------------------------------------------------------------------------------------------------------------------------

point(x, y, z)

Draw a point at x, y, z

   Fortran:
        subroutine point(x, y, z)
        real x, y, z
   C:
        draw_point(x, y, z)
             real x, y, z;
   Pascal:
        procedure Point(x, y, z: real)

-----------------------------------------------------------------------------------------------------------------------------------

point2(x, y)

Draw a point at x, y.

   Fortran:
        subroutine point2(x, y)
        real x, y
   C:
        draw_point2(x, y)
             float     x, y;
   Pascal:
        procedure Point2(x, y: real)

points
-----------------------------------------------------------------------------------------------------------------------------------
up

  * Created: 19960717

-----------------------------------------------------------------------------------------------------------------------------------

Curve Routines.

-----------------------------------------------------------------------------------------------------------------------------------

curvebasis(basis)

Define a basis matrix for a curve.

    Fortran:
         subroutine curvebasis(basis)
         real basis(4,4)
    C:
         draw_curvebasis(basis)
              float     basis[4][4];

    Pascal:
         procedure CurveBasis(basis: Matrix44_t)

-----------------------------------------------------------------------------------------------------------------------------------

curveprecision(nsegs)

Define the number of line segments used to draw a curve.

    Fortran:
         subroutine curveprecision(nsegs)
         integer nsegs
    C:
         draw_curveprecision(nsegs)
              int  nsegs;

    Pascal:
         procedure CurvePrecision(nsegs: integer)

-----------------------------------------------------------------------------------------------------------------------------------

rcurve(geom)

Draw a rational curve.

    Fortran:
         subroutine rcurve(geom)
         real geom(4,4)
    C:
         draw_rcurve(geom)
              float     geom[4][4];

    Pascal:
         procedure Rcurve(geom: Matrix44_t)

-----------------------------------------------------------------------------------------------------------------------------------

curve(geom)

Draw a curve.

    Fortran:
         subroutine curve(geom)
         real geom(3,4)
    C:
         draw_curve(geom)
              float     geom[4][3];

    Pascal:
         procedure Curve(geom: Matrix43_t)

-----------------------------------------------------------------------------------------------------------------------------------

curven(n, geom)

Draw n - 3 overlapping curve segments. Note: n must be at least 4.

    Fortran:
         subroutine curven(n, geom)
         integer n
         real geom(3,n)
    C:
         draw_curven(n, geom)
              int  n;
              float     geom[][3];

    Pascal:
         procedure Curven(n: integer; geom: GeomMat_t)

-----------------------------------------------------------------------------------------------------------------------------------
up

  * Created: 19960717

-----------------------------------------------------------------------------------------------------------------------------------

Text Routines.

-----------------------------------------------------------------------------------------------------------------------------------

VOGLE supports hardware and software fonts. The software fonts are based on the character set digitized by Dr Allen V. Hershey
while working at the U. S. National Bureau of Standards. Exactly what hardware fonts are supported depends on the device, but it is
guaranteed that the names "large" and "small" will result in something readable. For X11 displays the default large and small fonts
used by the program can be overridden by placing the following defaults in the ~/.Xdefaults file:

  vogle.smallfont: X11-font-name
  vogle.largefont: X11-font-name

It is noted here that text is always assumed to be drawn parallel to the (x, y) plane, using whatever the current z coordinate is.
The following software fonts are supported:

   astrology       cursive         cyrillic        futura.l
   futura.m        gothic.eng      gothic.ger      gothic.ita
   greek           markers         math.low        math.upp
   meteorology     music           script          symbolic
   times.g         times.i         times.ib        times.r
   times.rb        japanese

A markers font "markers" is also provided for doing markers - you need to have centertext mode on for this to give sensible results
when placing the markers.

If the environment variable "VFONTLIB" is set VOGLE looks for the software fonts in the directory given by this value.

the default font is futura.l

text
-----------------------------------------------------------------------------------------------------------------------------------

font(fontname)

Set the current font

   Fortran:
        subroutine font(fontname)
        character*(*) fontname
   C:
        draw_font(fontname)
             char *fontname

   Pascal:
        procedure Font(fontname: string_t)

WHEN ASK FOR NON-EXISTENT FONT, PROGRAM STOPS


-----------------------------------------------------------------------------------------------------------------------------------

numchars()

Return the number of characters in the current font. Applicable only to software fonts.

   Fortran:
        integer function numchars
   C:
        int draw_numchars()

   Pascal:
        function NumChars: integer;

-----------------------------------------------------------------------------------------------------------------------------------

textsize(width, height)

Set the maximum size of a character in the current font. Width and height are values in world units. This only applies to software
text. This must be done after the font being scaled is loaded. To keep text of different sizes aligned along the same baseline not
that you typically need to subtrace the decender height from the Y position

   Fortran:
        subroutine textsize(width, height)
        real width, height
   C:
        draw_textsize(width, height)
                    float     width, height;

   Pascal:
        procedure TextSize(width, height: real)

text
-----------------------------------------------------------------------------------------------------------------------------------

textang(ang)

Set the text angle. This angles strings and chars. This routine only affects software text. Angle is in degrees

   Fortran:
        subroutine textang(ang)
        real ang
   C:
        draw_textang(ang)
             float     ang;

   Pascal:
        procedure TexTang(ang: real)

text
-----------------------------------------------------------------------------------------------------------------------------------

fixedwidth(onoff)

Turns fixedwidth text on or off. Non-zero (.true.) causes all text to be printed with a fixed width for each character. Otherwise,
the text is spaced proportionally, where each character has a unique width less than or equal to the current fixed font width. This
routine only affects software text.

The default at program initialization is fixedwidth(.false.)

   Fortran:
        subroutine fixedwidth(onoff)
        logical onoff
   C:
        draw_fixedwidth(onoff)
             int onoff;

   Pascal:
        procedure FixedWidth(onoff: boolean)

text
-----------------------------------------------------------------------------------------------------------------------------------

centertext(onoff)

Turns centertext text on or off. Non-zero (.true.) is on. This centers strings and chars. This routine only affects software text.

   Fortran:
        subroutine centertext(onoff)
        logical onoff
   C:
        draw_centertext(onoff)
             int onoff;

   Pascal:
        procedure CenterText(onoff: boolean)

text
-----------------------------------------------------------------------------------------------------------------------------------

getcharsize(c, width, height)

Get the width and height of a character. At the moment the height returned is always that of the difference between the maximum
descender and ascender.

   Fortran:
        subroutine getcharsize(c, width, height)
        character*1 c
        real width, height
   C:
        draw_getcharsize(c, width, height)
             char c;
             float     *width, *height;

   Pascal:
        procedure GetCharSize(c: char; var width, height: real)

-----------------------------------------------------------------------------------------------------------------------------------

getfontdec(dec)

Get the descender size of a character in a font.

   Fortran:
        real function getfontdec
   C:
        float
        draw_getfontdec()

   Pascal:
        function NumChars: real;

-----------------------------------------------------------------------------------------------------------------------------------

getfontsize(width, height)

Get the maximum width and height of a character in a font.

   Fortran:
        subroutine getfontsize(width, height)
        real width, height
   C:
        draw_getfontsize(width, height)
             float     *width, *height;

   Pascal:
        procedure GetFontSize(var width, height: real)

-----------------------------------------------------------------------------------------------------------------------------------

drawchar(c)

Draw the character c. The current graphics position represents the bottom left hand corner of the character space.

   Fortran:
        subroutine drawchar(c)
        character c
   C:
        draw_drawchar(str)
             char c;

   Pascal:
        procedure DrawChar(c: char)

-----------------------------------------------------------------------------------------------------------------------------------

drawstr(str)

Draw the text in string at the current position.

   Fortran:
        subroutine drawstr(str)
        character*(*) str
   C:
        draw_drawstr(str)
             char *str;
   Pascal:
        procedure DrawStr(str: string_t)

-----------------------------------------------------------------------------------------------------------------------------------

strlength(str)

Return the length of the string s in world units.

   Fortran:
        real function strlength(str)
        character*(*) str
   C:
        float
        draw_strlength(char *str)

   Pascal:
        function StrLength(str: string_t): real;

-----------------------------------------------------------------------------------------------------------------------------------

boxtext(x, y, l, h, s)

Draw the string s so that it fits in the imaginary box defined with bottom left hand corner at (x, y), length l, and height h. This
only applies to software text.

   Fortran:
        subroutine boxtext(x, y, l, h, s)
        real x, y, l, h, s
   C:
        draw_boxtext(x, y, l, h, s)
             float     x, y, l, h, s;

   Pascal:
        procedure BoxText(x, y, l, h: real; s: string_t)

text
-----------------------------------------------------------------------------------------------------------------------------------

boxfit(l, h, nchars)

Set scale for text so that a string of the biggest characters in the font will fit in a box l by h. l and h are real values in
world dimensions. This only applies to software text.

   Fortran:
        subroutine boxfit(l, h, nchars)
        real l, h
        integer nchars
   C:
        draw_boxfit(l, h, nchars)
             float     l, h
             int  nchars

   Pascal:
        procedure BoxFit(l, h: real; nchars: integer)

-----------------------------------------------------------------------------------------------------------------------------------

textjustify(val)

General (direct) control of text justification. The value of val is made up of the logical OR of the following predefined constants
in vogle.h (FOR C and Fortran only). V_LEFT, V_RIGHT, V_XCENTERED, V_TOP, V_BOTTOM, V_YCENTERED. Centering takes priority, as does
RIGHT and TOP justification (if you were silly enough to set it to V_LEFT|V_RIGHT for example that is). A value of 0 (zero) (in all
languages) resets the textjustification to the default.

   Fortran:
       subroutine textjustify(val)
       character(kind=c_short) :: ival
       character(kind=c_char)  :: val

       ! from Fortran, use IANY() to OR the array of options, and CHAR()
       ! to convert the integer result to a C_CHAR type. KIND C_CHAR is
       ! defined by loading a the intrinsic module for C bindings ("USE ISO_C_BINDING").
       ival=iany([V_XCENTERED,V_YCENTERED])
       val=char(ival)
       call textjustify(val)

   C:
       draw_textjustify(val)
          char val;

   Pascal:
       procedure TextJustify(val: integer)

text
-----------------------------------------------------------------------------------------------------------------------------------

leftjustify()

Left justifies text. The text string will begin at the current position and extend to the notional right. Right justification and X
centering are turned off.

    Fortran:
        subroutine leftjustify

    C:
        draw_leftjustify()

    Pascal:
        procedure LeftJustify

text
-----------------------------------------------------------------------------------------------------------------------------------

rightjustify()

Right justifies text. The text string will begin at a point to the notional left of the current position and finish at the current
position. Left justification and X centering are turned off.

   Fortran:
       subroutine rightjustify

   C:
       draw_rightjustify()

   Pascal:
       procedure RightJustify

text
-----------------------------------------------------------------------------------------------------------------------------------

xcentertext()

Centers text in the X direction. The text string will begin at a point to the notional left of the current position and finish at a
point to the right of the current position. Left justification and Right justification are turned off.

   Fortran:
       subroutine xcentertext

   C:
       draw_xcentertext()

   Pascal:
       procedure XcenterText

text
-----------------------------------------------------------------------------------------------------------------------------------

topjustify()

Top justifies text. The text string will be drawn with it's upper edge aligned with the current Y position. Bottom justification
and Y centering are turned off.

    Fortran:
        subroutine topjustify

    C:
        draw_topjustify()

    Pascal:
        procedure TopJustify

text
-----------------------------------------------------------------------------------------------------------------------------------

bottomjustify()

Bottom justifies text. The text string will be drawn with it's lower edge aligned with the current Y position. Top justification
and Y centering are turned off.

   Fortran:
       subroutine bottomjustify

   C:
       draw_bottomjustify()

   Pascal:
       procedure BottomJustify

text
-----------------------------------------------------------------------------------------------------------------------------------

ycentertext()

Centers text in the Y direction. The text string will so that it's center line is aligned with the current y position. Top
justification and Bottom justification are turned off.

   Fortran:
       subroutine ycentertext
   C:
       draw_ycentertext()

   Pascal:
       procedure YcenterText

text
-----------------------------------------------------------------------------------------------------------------------------------

textslant()

Defines the obliqueness of the fonts. This is a simplistic method that allows you to generate italicized versions of the software
fonts. The x- values of the software font coordinates after the current textsize() values are applied are multiplied by (1+val).

Note that this means the same value tilts the characters less the taller the characters are relative to their width.

Generally, practical values are generally between -1 and 1 times the

   Fortran:
       subroutine textslant(var)
       real var
   C:
       draw_textslant(float var)

   Pascal:
       procedure TextSlant()


-----------------------------------------------------------------------------------------------------------------------------------

textweight()

Defines the weight of the fonts. Currently, the predefined constants in C and Fortran are V_NORMAL and V_BOLD; which correspond to
0 and 1. This is not the same as using linethickess to change the appearance of a software font. The font is redrawn multiple times
with a slight offset to create the bold appearance.

   Fortran:
       subroutine textweight(ival)
       integer ival
   C:
       draw_textweight(int ival)

   Pascal:
       procedure TextWeight(ival: integer)

text
-----------------------------------------------------------------------------------------------------------------------------------
up

  * Created: 19960717

Line Style Routines

-----------------------------------------------------------------------------------------------------------------------------------

Linestyles are specified by giving a nominal length of a single dash and a character string consisting of 1's and 0's (zeros) that
specify when to draw a dash and when not to draw a dash. Linestyles will follow curves and "go around" corners. If a linestyle is
set or reset, the accumulated information as to where on a curve (or line) a dash is to be draw is also reset.

For example, with a nominal view of -1 to 1, setting the dash length to 0.5, and the linestyle to '11010' would draw a line(or
curve) with a 1.0 unit solid part, followed by a 0.5 unit blank part followed by a 0.5 unit solid part followed by a 0.5 unit blank
part. The linestyle would then repeat itself.

The dash sizes are affected by the current viewport/transformation scaling factors, meaning that in perspective, the dashes look
smaller the farther away they are.

-----------------------------------------------------------------------------------------------------------------------------------

linewidth(rasters)

Set the current line width in units of 1/10,000 of the X size of the display surface

   Fortran:
        subroutine linewidth(iwidth)
        integer iwidth

   C:
        draw_linewidth(iwidth)
             int     iwidth;

   Pascal:
        procedure LineWidth(iwidth: integer)

linewidth
-----------------------------------------------------------------------------------------------------------------------------------

dashcode(dashlen)

Set the current dash length (in world units) to be dashlen.

   Fortran:
        subroutine dashcode(dashlen)
        real dashlen

   C:
        draw_dashcode(dashlen)
             float     dashlen;

   Pascal:
        procedure DashCode(dashlen: real)

dashcode

The sample graphic shows a line segment being drawn using the same linestyle except the dashcode is being changed. Note that the
dashcode is in world units,

-----------------------------------------------------------------------------------------------------------------------------------

linestyle(style)

Set the current linestyle to style. Linestyles are specified by giving a nominal length of a single dash and a character string
consisting of 1's and 0's (zeros) that specify when to draw a dash and when not to draw a dash. "1" is for a dash , "0" is for a
gap. Linestyles will follow curves and "go around" corners.

To reset to a solid line style, enter a linestyle of "". If a linestyle is set or reset, the accumulated information as to where on
a curve (or line) a dash is to be draw is also reset.

   Fortran:
        subroutine linestyle(style)
        character *(*) style

   C:
        draw_linestyle(style)
             char *style;

   Pascal:
        procedure LineStyle(style: string_t)


linestyle
-----------------------------------------------------------------------------------------------------------------------------------
up

  * Created: 19960717

-----------------------------------------------------------------------------------------------------------------------------------

Color Routines

-----------------------------------------------------------------------------------------------------------------------------------

clear()

Clears the screen to the current color.

   Fortran:
        subroutine clear
   C:
        draw_clear()
   Pascal:
        procedure Clear

-----------------------------------------------------------------------------------------------------------------------------------

color(col)

Set the current color. The standard colors are as follows:

      black  =  0  red      =  1  green  =  2  yellow  =  3
      blue   =  4  magenta  =  5  cyan   =  6  white   =  7

   Fortran:
        subroutine color(col)
        integer col
   C:
        draw_color(col)
             int  col;
   Pascal:
        procedure Color

color
-----------------------------------------------------------------------------------------------------------------------------------

mapcolor(indx, red, green, blue)

Set the color map index indx to the color represented by (red, green, blue). If the device has no color map this call does nothing.

rgb values are in the range of 0 to 255.

   Fortran:
        subroutine mapcolor(indx, red, green, blue)
        integer indx, red, green, blue
   C:
        draw_mapcolor(indx, red, green, blue)
             int  indx, red, green, blue;

   Pascal:
        procedure MapColor(indx, red, green, blue: integer)

mapcolor
-----------------------------------------------------------------------------------------------------------------------------------
up

  * Created: 19960717

-----------------------------------------------------------------------------------------------------------------------------------

Clipping Routines.

-----------------------------------------------------------------------------------------------------------------------------------

clipping(onoff)

Turn clipping on or off. Non-zero is considered on. Note: on some devices turning clipping off may not be a good idea.

    Fortran:
         subroutine clipping(onoff)
         logical onoff
    C:
         draw_clipping(onoff)
              int  onoff;

    Pascal:
         procedure Clipping(onoff: boolean)

-----------------------------------------------------------------------------------------------------------------------------------
up

  * Created: 19960717

-----------------------------------------------------------------------------------------------------------------------------------

Interactive Routines.

-----------------------------------------------------------------------------------------------------------------------------------

getkey()

Return the ASCII ordinal of the next key typed at the keyboard. If the device has no keyboard getkey returns -1.

    Fortran:
         integer function getkey
    C:
         int draw_getkey()

    Pascal:
         function GetKey(): integer;

-----------------------------------------------------------------------------------------------------------------------------------

checkkey()

Returns zero if no key is pressed or the ASCII ordinal of the key that was pressed.

    Fortran:
         integer function checkkey()
    C:
         int draw_checkkey()

    Pascal:
         function CheckKey(): integer;

-----------------------------------------------------------------------------------------------------------------------------------

getstring(bcol, string)

Read in a string, echoing it in the current font, using the current color and the current transformation. bcol is the background
color which is used for erasing characters after a backspace or a delete key is received. Getstring interprets the Backspace key
(ASCII 8) and the Del key (ASCII 127) as erasing characters. An EOT (ASCII 4) or a Carriage return (ASCII 13) will terminate input.
Getstring returns the number of characters read. Getstring does not check for overflow in the input buffer string

    Fortran:
         integer function getstring(bcol, string)
         integer bcol
         character *(*) string
    C:
         int draw_getstring(bcol, string)
              int  bcol;
              char *string;

    Pascal:
function GetString(bcol: integer; var string: string_t): integer;

-----------------------------------------------------------------------------------------------------------------------------------

locator(xaddr, yaddr)

Find out where the cursor is. xaddr and yaddr are set to the current location in world coordinates. The function returns a bit
pattern which indicates which buttons are being held down eg. if mouse buttons 1 and 3 are down locator returns binary 101 (decimal
7). The function returns -1 if the device has no locator capability. Note: if you have been doing a lot of 3-D transformations
xaddr and yaddr may not make a lot of sense. In this case use slocator.

    Fortran:
         integer function locator(xaddr, yaddr)
         real xaddr, yaddr
    C:
         int draw_locator(xaddr, yaddr)
              float     *xaddr, *yaddr;

    Pascal:
         function Locator(var xaddr, yaddr: real): integer;

-----------------------------------------------------------------------------------------------------------------------------------

slocator(xaddr, yaddr)

Find out where the cursor is. xaddr and yaddr are set to the current location in screen coordinates. The return value of the
function is set up in the same way as with locator. If the device has no locator device slocator returns -1.

    Fortran:
         integer function slocator(xaddr, yaddr)
         real xaddr, yaddr
    C:
         int draw_slocator(xaddr, yaddr)
              float     *xaddr, *yaddr;

    Pascal:
         function Slocator(var xaddr, yaddr: real): integer;

-----------------------------------------------------------------------------------------------------------------------------------
up

  * Created: 19960717

-----------------------------------------------------------------------------------------------------------------------------------

Flushing

-----------------------------------------------------------------------------------------------------------------------------------

On some devices (particularly X11) considerable speedups in display can be achieved by not flushing each graphics primitive call to
the actual display until necessary. VOGL automatically delays flushing in the following cases:

  * Within a callobj() call.
  * Within curves and patches.
  * Within Hershey software text.
  * When double buffering (the flush is only done within swapbuffers).

There are two user routines that can be used to control flushing.

-----------------------------------------------------------------------------------------------------------------------------------

vsetflush(yesno)

Set global flushing status. If yesno = 0 (.false.) then don't do any flushing (except in swapbuffers(), or vflush()). If yesno = 1
(.true.) then do the flushing as described above.

    Fortran:
         subroutine vsetflush(yesno)
         logical yesno

    C:
         void draw_vsetflush(yesno)
              int  yesno;

    Pascal:
         procedure VsetFlush(yesno: boolean);

-----------------------------------------------------------------------------------------------------------------------------------

vflush()

Call the device flush or syncronisation routine. This forces a flush.

    Fortran:
         subroutine vflush

    C:
         void draw_vflush();

    Pascal:
         procedure Vflush;

-----------------------------------------------------------------------------------------------------------------------------------
up

  * Created: 19960717

-----------------------------------------------------------------------------------------------------------------------------------

Viewport Routines.

-----------------------------------------------------------------------------------------------------------------------------------

viewport(left, right, bottom, top)

Specify which part of the screen to draw in. Left, right, bottom, and top are real values in screen coordinates (-1.0 to 1.0).

    Fortran:
         subroutine viewport(left, right, bottom, top)
         real left, right, bottom, top

    C:
         draw_viewport(left, right, bottom, top)
              float      left, right, bottom, top;

    Pascal:
         procedure ViewPort(left, right, bottom, top: real);

-----------------------------------------------------------------------------------------------------------------------------------

pushviewport()

Save current viewport.

    Fortran:
         subroutine pushviewport

    C:
         draw_pushviewport()

    Pascal:
         procedure PushViewPort;

-----------------------------------------------------------------------------------------------------------------------------------

popviewport()

Retrieve last viewport.

    Fortran:
         subroutine popviewport

    C:
         draw_popviewport()

    Pascal:
         procedure PopViewPort;

-----------------------------------------------------------------------------------------------------------------------------------

getviewport(left, right, bottom, top)

Returns the left, right, bottom and top limits of the current viewport in screen coordinates (-1.0 to 1.0).

    Fortran:
         subroutine getviewport(left, right, bottom, top)
         real left, right, bottom, top

    C:
         draw_getviewport(left, right, bottom, top)
              float      *left, *right, *bottom, *top;

    Pascal:
         procedure GetViewPort(var left, right, bottom, top: real)

-----------------------------------------------------------------------------------------------------------------------------------

expandviewport()

When Vogle does viewport calculations, it will normally begin by using the largest square it can fit onto the actual display
device. This call says to use the whole device... however you must then take into account any distortion that will occur due to the
non square mapping. Thus, a viewport of (-1.0, 1.0, -1.0, 1.0) will map into the whole display device.

    Fortran:
        subroutine expandviewport

    C:
        draw_expandviewport()

    Pascal:
        procedure ExpandViewport

-----------------------------------------------------------------------------------------------------------------------------------

unexpandviewport()

Does the reverse of expandviewport. Basically, it returns vogle to using the largest square of the device for it's viewport
calculations.

    Fortran:
        subroutine unexpandviewport

    C:
        draw_unexpandviewport()

    Pascal:
        procedure UnExpandViewport

-----------------------------------------------------------------------------------------------------------------------------------
up

  * Created: 19960717

-----------------------------------------------------------------------------------------------------------------------------------

Getting the aspect details

-----------------------------------------------------------------------------------------------------------------------------------

Often the screen is not perfectly square and it would be nice to use the extra space without having to turn clipping off. The
following routines are provided to get the values needed to adjust the calls to viewport, etc as needed.

-----------------------------------------------------------------------------------------------------------------------------------

getaspect()

Returns the ratio height over width of the display device.

    Fortran:
         real function getaspect()

    C:
         float draw_getaspect()

    Pascal:
         function GetAspect(): real;

-----------------------------------------------------------------------------------------------------------------------------------

getfactors(wfact, hfact)

Returns wfact as the width over min(width of device, height of device) and hfact as the height over min(width of device, height of
device).

    Fortran:
         subroutine getfactors(w, h)
         real w, h

    C:
         draw_getfactors(w, h)
              float     *w, *h;

    Pascal:
         procedure GetFactors(var w, h: real)

-----------------------------------------------------------------------------------------------------------------------------------

getdisplaysize(w, h)

Returns the width and height of the device in pixels in w and h respectively.

    Fortran:
         subroutine getdisplaysize(w, h)
         real w, h

    C:
         draw_getdisplaysize(w, h)
              float     *w, *h;

    Pascal:
         procedure GetDisplaySize(var w, h: real)

-----------------------------------------------------------------------------------------------------------------------------------
up

  * Created: 19960717

-----------------------------------------------------------------------------------------------------------------------------------

Attribute Stack Routines

-----------------------------------------------------------------------------------------------------------------------------------

The attribute stack contains details such as current color, filling, hatching, centered, fixedwidth, text height, text width, and
the current font. If you need to prevent object calls from changing these, use pushattributes before the call and popattributes
after.

-----------------------------------------------------------------------------------------------------------------------------------

pushattributes()

Save the current attributes on the attribute stack.

    Fortran:
         subroutine pushattributes

    C:
         draw_pushattributes()

    Pascal:
         procedure PushAttributes;

-----------------------------------------------------------------------------------------------------------------------------------

popattributes()

Restore the attributes to what they were at the last pushattributes().

    Fortran:
         subroutine popattributes

    C:
         draw_popattributes()

    Pascal:
         procedure PopAttributes;

-----------------------------------------------------------------------------------------------------------------------------------
up

  * Created: 19960717

-----------------------------------------------------------------------------------------------------------------------------------

Projection Routines.

-----------------------------------------------------------------------------------------------------------------------------------

All the projection routines define a new transformation matrix, and consequently the world units. Parallel projections are defined
by ortho or ortho2. Perspective projections can be defined by perspective and window.

fobjvws
-----------------------------------------------------------------------------------------------------------------------------------

ortho(left, right, bottom, top, near, far)

Define x (left, right), y (bottom, top), and z (near, far) clipping planes. The near and far clipping planes are actually specified
as distances along the line of sight. These distances can also be negative. The actual location of the clipping planes is z =
-near_d and z = -far_d.

    Fortran:
         subroutine ortho(left, right, bottom, top, near_d, far_d)
         real left, right, bottom, top, near_d, far_d

    C:
         draw_ortho(left, right, bottom, top, near_d, far_d)
              float     left, right, bottom, top, near_d, far_d;

    Pascal:
     procedure Ortho(left, right, bottom, top, near_d, far_d: real)

-----------------------------------------------------------------------------------------------------------------------------------

ortho2(left, right, bottom, top)

Define x (left, right), and y (bottom, top) clipping planes.

    Fortran:
         subroutine ortho2(left, right, bottom, top)
         real left, right, bottom, top

    C:
         draw_ortho2(left, right, bottom, top)
              float     left, right, bottom, top;

    Pascal:
         procedure Ortho2(left, right, bottom, top: real)

-----------------------------------------------------------------------------------------------------------------------------------

perspective(fov, aspect, near, far)

Specify a perspective viewing pyramid in world coordinates by giving a field of view, aspect ratio and the distance from the eye of
the near and far clipping plane.

    Fortran:
         subroutine perspective(fov, aspect, near, far)
         real fov, aspect, near, far

    C:
         draw_perspective(fov, aspect, near, far)
              float     fov, aspect, near, far;

    Pascal:
         procedure Perspective(fov, aspect, near, far: real)

-----------------------------------------------------------------------------------------------------------------------------------

window(left, right, bot, top, near, far)

Specify a perspective viewing pyramid in world coordinates by giving the rectangle closest to the eye (ie. at the near clipping
plane) and the distances to the near and far clipping planes.

    Fortran:
         subroutine window(left, right, bot, top, near, far)
         real left, right, bot, top, near, far

    C:
         draw_window(left, right, bot, top, near, far)
              float     left, right, bot, top, near, far;


    Pascal:
         procedure Window(left, right, bot, top, near, far: real)

-----------------------------------------------------------------------------------------------------------------------------------
up

  * Created: 19960717

-----------------------------------------------------------------------------------------------------------------------------------

Matrix Stack Routines.

-----------------------------------------------------------------------------------------------------------------------------------

pushmatrix()

Save the current transformation matrix on the matrix stack.

    Fortran:
         subroutine pushmatrix

    C:
         draw_pushmatrix()

    Pascal:
         procedure PushMatrix

-----------------------------------------------------------------------------------------------------------------------------------

popmatrix()

Retrieve the last matrix pushed and make it the current transformation matrix.

    Fortran:
         subroutine popmatrix

    C:
         draw_popmatrix()

    Pascal:
         procedure PopMatrix

-----------------------------------------------------------------------------------------------------------------------------------
up

  * Created: 19960717

-----------------------------------------------------------------------------------------------------------------------------------

Viewpoint Routines.

-----------------------------------------------------------------------------------------------------------------------------------

Viewpoint routines alter the current transformation matrix.

-----------------------------------------------------------------------------------------------------------------------------------

polarview(dist, azim, inc, twist)

Specify the viewer's position in polar coordinates by giving the distance from the viewpoint to the world origin, the azimuthal
angle in the x-y plane, measured from the y-axis, the incidence angle in the y-z plane, measured from the z-axis, and the twist
angle about the line of sight.

    Fortran:
         subroutine polarview(dist, azim, inc, twist)
         real dist, azim, inc, twist

    C:
         draw_polarview(dist, azim, inc, twist)
              float     dist, azim, inc, twist;

    Pascal:
         procedure PolarView(dist, azim, inc, twist: real)

-----------------------------------------------------------------------------------------------------------------------------------

up(x, y, z)

Specify the world up. This can be used to prevent lookat's sometimes annoying habit of turning everything upside down due to the
line of sight crossing the appropriate axis.

    Fortran:
         subroutine up(x, y, z)
         real x, y, z

    C:
         draw_up(x, y, z)
              float     x, y, z;

    Pascal:
         procedure Up(x, y, z: real)

-----------------------------------------------------------------------------------------------------------------------------------

lookat(vx, vy, vz, px, py, pz, twist)

Specify the viewer's position by giving a viewpoint and a reference point in world coordinates. A twist about the line of sight may
also be given.

    Fortran:
         subroutine lookat(vx, vy, vz, px, py, pz, twist)
         real vx, vy, vz, px, py, pz, twist

    C:
         draw_lookat(vx, vy, vz, px, py, pz, twist)
              float     vx, vy, vz, px, py, pz, twist;

    Pascal:
         procedure LookAt(vx, vy, vz, px, py, pz, twist: real)

-----------------------------------------------------------------------------------------------------------------------------------
up

  * Created: 19960717

-----------------------------------------------------------------------------------------------------------------------------------

Transformations Routines.

-----------------------------------------------------------------------------------------------------------------------------------

All transformations are cumulative, so if you rotate something and then do a translate you are translating relative to the rotated
axes. If you need to preserve the current transformation matrix use pushmatrix(), do the drawing, and then call popmatrix() to get
back where you were before.

When doing transformations, ensure your objects remain in the viewing volume or they will be clipped. See routines such as ortho(3)
for more information.

transformations
-----------------------------------------------------------------------------------------------------------------------------------

translate(x, y, z)

Set up a translation.

   Fortran:
      subroutine translate(x, y, z)
      real x, y, z
   C:
      draw_translate(x, y, z)
      float     x, y, z;
   Pascal:
      procedure Translate(x, y, z: real)

-----------------------------------------------------------------------------------------------------------------------------------

scale(x, y, z)

Set up scaling factors in x, y, and z axis.

    Fortran:
         subroutine scale(x, y, z)
         real x, y, z
    C:
         draw_scale(x, y, z)
              float     x, y, z;
    Pascal:
         procedure Scale(x, y, z: real)

-----------------------------------------------------------------------------------------------------------------------------------

rotate(angle, axis)

Set up a rotation in axis axis. Where axis is one of 'x', 'y', or 'z'.

    Fortran:
         subroutine rotate(angle, axis)
         real angle
         character axis
    C:
         draw_rotate(angle, axis)
              float     angle;
              char axis;
    Pascal:
         procedure Rotate(angle: real; axis: char)

-----------------------------------------------------------------------------------------------------------------------------------
up

  * Created: 19960717

-----------------------------------------------------------------------------------------------------------------------------------

Patch Routines.

-----------------------------------------------------------------------------------------------------------------------------------

patchbasis(tbasis, ubasis)

Define the t and u basis matrices of a patch.

    Fortran:
         subroutine patchbasis(tbasis, ubasis)
         real tbasis(4, 4), ubasis(4, 4)
    C:
         draw_patchbasis(tbasis, ubasis)
              float     tbasis[4][4], ubasis[4][4];

    Pascal:
         procedure PatchBasis(tbasis, ubasis: Matrix44_t)

-----------------------------------------------------------------------------------------------------------------------------------

patchprecision(tseg, useg)

Set the minimum number of line segments making up curves in a patch.

    Fortran:
         subroutine patchprecision(tseg, useg)
         integer tseg, useg
    C:
         draw_patchprecision(tseg, useg)
              int     tseg, useg;

    Pascal:
         procedure PatchPrecision(tseg, useg: integer)

-----------------------------------------------------------------------------------------------------------------------------------

patchcurves(nt, nu)

Set the number of curves making up a patch.

    Fortran:
         subroutine patchcurves(nt, nu)
         integer nt, nu
    C:
         draw_patchcurves(nt, nu)
              int     nt, nu;

    Pascal:
         procedure PatchCurves(nt, nu: integer)

-----------------------------------------------------------------------------------------------------------------------------------

rpatch(gx, gy, gz, gw)

Draws a rational patch in the current basis, according to the geometry matrices gx, gy, gz, and gw.

    Fortran:
         subroutine rpatch(gx, gy, gz, gw)
         real  gx(4,4), gy(4,4), gz(4,4), gw(4,4)
    C:
         draw_rpatch(gx, gy, gz, gw)
             float  gx[4][4], gy[4][4], gz[4][4], gw[4][4];

    Pascal:
         procedure Rpatch(gx, gy, gz, gw: Matrix44_t)

-----------------------------------------------------------------------------------------------------------------------------------

patch(gx, gy, gz)

Draws a patch in the current basis, according to the geometry matrices gx, gy, and gz.

    Fortran:
         subroutine patch(gx, gy, gz)
         real  gx(4,4), gy(4,4), gz(4,4)
    C:
         draw_patch(gx, gy, gz)
              float  gx[4][4], gy[4][4], gz[4][4];

    Pascal:
         procedure Patch(gx, gy, gz: Matrix44_t)

-----------------------------------------------------------------------------------------------------------------------------------
up

  * Created: 19960717

-----------------------------------------------------------------------------------------------------------------------------------

Object Routines

-----------------------------------------------------------------------------------------------------------------------------------

Objects are graphical entities created by the drawing routines called between makeobj and closeobj. Objects may be called from
within other objects. When an object is created most of the calculations required by the drawing routines called within it are done
up to where the calculations involve the current transformation matrix. So if you need to draw the same thing several times on the
screen but in different places it is faster to use objects than to call the appropriate drawing routines each time. Objects also
have the advantage of being saveable to a file, from where they can be reloaded for later reuse. Routines which draw or move in
screen coordinates, or change device, cannot be included in objects.

linewidth
-----------------------------------------------------------------------------------------------------------------------------------

makeobj(n)

Commence the object number n.

   Fortran:
        subroutine makeobj(n)
        integer n
   C:
        draw_makeobj(n)
             int  n;
   Pascal:
        procedure MakeObj(n: integer)

-----------------------------------------------------------------------------------------------------------------------------------

closeobj()

Close the current object.

   Fortran:
        subroutine closeobj()
   C:
        draw_closeobj()
   Pascal:
        procedure CloseObj

-----------------------------------------------------------------------------------------------------------------------------------

genobj()

Returns a unique object identifier.

   Fortran:
        integer function genobj()
   C:
        int
        draw_genobj()
   Pascal:
        function GenObj: integer

-----------------------------------------------------------------------------------------------------------------------------------


getopenobj()

Return the number of the current object.

   Fortran:
        integer function getopenobj()
   C:
        int
        draw_getopenobj()
   Pascal:
        function GetOpenObj: integer

-----------------------------------------------------------------------------------------------------------------------------------

callobj(n)

Draw object number n.

   Fortran:
        subroutine callobj(n)
        integer n
   C:
        draw_callobj(n)
             int  n;
   Pascal:
        procedure CallObj(n: integer)

-----------------------------------------------------------------------------------------------------------------------------------

isobj(n)

Returns non-zero if there is an object of number n.

   Fortran:
        logical function isobj(n)
        integer n
   C:
        int
        draw_isobj(n)
             int  n;
   Pascal:
        function IsObj(n: integer): boolean;

-----------------------------------------------------------------------------------------------------------------------------------


delobj(n)

Delete the object number n.

   Fortran:
        subroutine delobj(n)
        integer n
   C:
        draw_delobj(n)
             Object    n;
   Pascal:
        procedure DelObj(n: integer);

-----------------------------------------------------------------------------------------------------------------------------------

loadobj(n, filename)

Load the object in the file "filename" as object number n.

   Fortran:
        subroutine loadobj(n, filename)
        integer n
        character*(*) filename
   C:
        draw_loadobj(n, filename)
             int     n;
             char    *filename;
   Pascal:
        procedure LoadObj(n: integer; filename: string_t)

-----------------------------------------------------------------------------------------------------------------------------------

saveobj(n, filename)

Save the object number n into the file filename. This call does not save objects called inside object n.

   Fortran:
        saveobj(n, filename)
        integer   n
        character*(*) filename
   C:
        draw_saveobj(n, filename)
             int  n;
             char *filename;
   Pascal:
        procedure SaveObj(n: integer; filename: string_t)

-----------------------------------------------------------------------------------------------------------------------------------
up

  * Created: 19960717

-----------------------------------------------------------------------------------------------------------------------------------

Double Buffering.

-----------------------------------------------------------------------------------------------------------------------------------

Where possible VOGLE allows for front and back buffers to enable things like animation and smooth updating of the screen. The
routine backbuffer is used to initialise double buffering.

-----------------------------------------------------------------------------------------------------------------------------------

backbuffer()

Make VOGLE draw in the backbuffer. Returns -1 if the device is not up to it.

    Fortran:
         integer function backbuffer

    C:
         draw_backbuffer()

    Pascal:
         function BackBuffer:integer

-----------------------------------------------------------------------------------------------------------------------------------

frontbuffer()

Make VOGLE draw in the front buffer. This will always work.

    Fortran:
         subroutine frontbuffer

    C:
         draw_frontbuffer()

    Pascal:
         procedure FrontBuffer

-----------------------------------------------------------------------------------------------------------------------------------

swapbuffers()

Swap the front and back buffers.

    Fortran:
         subroutine swapbuffers

    C:
         draw_swapbuffers()

    Pascal:
         procedure SwapBuffers

-----------------------------------------------------------------------------------------------------------------------------------
up

  * Created: 19960717

-----------------------------------------------------------------------------------------------------------------------------------

Position Routines.

-----------------------------------------------------------------------------------------------------------------------------------

getgp(x, y, z)

Gets the current graphics position in world coords.

    Fortran:
         subroutine getgp(x, y, z)
         real x, y, z

    C:
         draw_getgp(x, y, z)
              float *x, *y, *z;

    Pascal:
         procedure GetGp(var x, y, z: real)

-----------------------------------------------------------------------------------------------------------------------------------

getgpt(x, y, z,w)

Gets the current transformed graphics position in world coords.

    Fortran:
         subroutine getgpt(x, y, z, w)
         real x, y, z, w

    C:
         draw_getgpt(x, y, z, w)
            float *x, *y, *z, *w;

    Pascal:
         procedure GetGpT(var x, y, z, w: real)

-----------------------------------------------------------------------------------------------------------------------------------

getgp2(x, y)

Gets the current graphics position in world coords.

    Fortran:
         subroutine getgp2(x, y)
         real x, y

    C:
         draw_getgp2(x, y)
              float *x, *y;

    Pascal:
         procedure GetGp2(var x, y: real)

-----------------------------------------------------------------------------------------------------------------------------------

sgetgp2(x, y)

Gets the current screen graphics position in screen coords (-1 to 1)

    Fortran:
         subroutine sgetgp2(x, y)
         real x, y

    C:
         draw_sgetgp2(x, y)
              float *x, *y;

    Pascal:
         procedure SgetGp2(var x, y: real)

-----------------------------------------------------------------------------------------------------------------------------------
up

  * Created: 19960717

VOGLE Author Contacts

VOGLE is a public domain library that originates from The University of Melbourne.

The source files for VOGLE (and VORT and VOPL and ...) can be accessed via FTP of gondwana.ecr.mu.oz.au.

Email:

    echidna@ecr.mu.oz.au

New Vogle mailing list:

    vogle@ecr.mu.oz.au
    (vogle-request@ecr.mu.oz.au to get placed on the list).

Snail mail correspondence and alcoholic beverages should be directed to:


    The Software Support Programmer
    Department Of Engineering Computer Resources
    Faculty Of Engineering
    University Of Melbourne Vic 3052
    Australia


-----------------------------------------------------------------------------------------------------------------------------------
BUGS

We had to make up the font names based on some books of type faces.

Polygon hatching will give unexpected results unless the polygon is initially defined in the X-Y plane.

Double buffering isn't supported on all devices.

We don't recommend the use of the smove/sdraw routines.

The yobbarays may be turned on or they may be turned off.

When creating an object, current position and text size are not actually changed so almost any query routine to get position or
font size or whatever will not work properly.

-----------------------------------------------------------------------------------------------------------------------------------
