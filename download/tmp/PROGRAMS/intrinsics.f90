subroutine help_version(l_version)
implicit none
character(len=*),parameter     :: ident="@(#)help_version(3f): prints version information"
logical,intent(in)             :: l_version
character(len=:),allocatable   :: help_text(:)
integer                        :: i
logical                        :: stopit=.false.
stopit=.false.
if(l_version)then
help_text=[ CHARACTER(LEN=128) :: &
'@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>',&
'@(#)PROGRAM:        intrinsics(1)>',&
'@(#)DESCRIPTION:    output source for man(1) pages of Fortran intrinsics>',&
'@(#)VERSION:        2.0, 20170305>',&
'@(#)AUTHOR:         John S. Urban>',&
'@(#)REPORTING BUGS: http://www.urbanjost.altervista.org/>',&
'@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>',&
'@(#)LICENSE:        Public Domain. This is free software: you are free to change and redistribute it.>',&
'@(#)                There is NO WARRANTY, to the extent permitted by law.>',&
'@(#)COMPILED:       Sat, Nov 10th, 2018 6:04:05 PM>',&
'']
   WRITE(*,'(a)')(trim(help_text(i)(5:len_trim(help_text(i))-1)),i=1,size(help_text))
   stop ! if -version was specified, stop
endif
end subroutine help_version
!-----------------------------------------------------------------------------------------------------------------------------------
subroutine help_usage(l_help)
implicit none
character(len=*),parameter     :: ident="@(#)help_usage(3f): prints help information"
logical,intent(in)             :: l_help
character(len=:),allocatable :: help_text(:)
integer                        :: i
logical                        :: stopit=.false.
stopit=.false.
if(l_help)then
help_text=[ CHARACTER(LEN=128) :: &
'NAME                                                                            ',&
'    intrinsics(1f) - [FUNIX] output text versions of Fortran intrinsic man(1) pages',&
'                                                                                ',&
'SYNOPSIS                                                                        ',&
'    intrinsics [--help|--version]                                               ',&
'                                                                                ',&
'DESCRIPTION                                                                     ',&
'    This program outputs all the source of the man(1) pages of the Fortran intrinsics procedures.',&
'                                                                                ',&
'OPTIONS                                                                         ',&
'    --help     display this help and exit                                       ',&
'    --version  output version information and exit                              ',&
'                                                                                ',&
'EXAMPLES                                                                        ',&
'    Sample commands                                                             ',&
'                                                                                ',&
'       intrinsics >x;vi x                                                       ',&
'                                                                                ',&
'']
   WRITE(*,'(a)')(trim(help_text(i)),i=1,size(help_text))
   stop ! if -help was specified, stop
endif
end subroutine help_usage
!-----------------------------------------------------------------------------------------------------------------------------------
!>
!!##NAME
!!     intrinsics(1f) - [FUNIX] output text versions of Fortran intrinsic man(1) pages
!!
!!##SYNOPSIS
!!
!!     intrinsics [--help|--version]
!!
!!##DESCRIPTION
!!     This program outputs all the source of the man(1) pages of the Fortran intrinsics procedures.
!!
!!##OPTIONS
!!     --help     display this help and exit
!!     --version  output version information and exit
!!
!!##EXAMPLES
!!
!!     Sample commands
!!
!!        intrinsics >x;vi x
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
program intrinsics_man_pages
use ISO_FORTRAN_ENV, only : io => OUTPUT_UNIT
use M_kracken,only : kracken, lget                                   ! add command-line parser module
implicit none
                                                               ! define command arguments, default values and crack command line
   call kracken('intrinsics','-help .false. -version .false.')
   call help_usage(lget('intrinsics_help'))                    ! if -help option is present, display help text and exit
   call help_version(lget('intrinsics_version'))               ! if -version option is present, display version text and exit
!-----------------------------------------------------------------------------------------------------------------------------------
write(io,'(a)')'NAME'
write(io,'(a)')'   intrinsics(7f) - [FORTRAN]intrinsic man(1) pages'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Got tired of not having the Fortran intrinsics available as man(1) pages,'
write(io,'(a)')'   especially when looking at code in the vim(1) editor and wanting to use the'
write(io,'(a)')'   "K" command to evoke the man(1) page.'
write(io,'(a)')''
write(io,'(a)')'   So, as a start I took the closest thing I knew, which was descriptions on the'
write(io,'(a)')'   Fortran Wiki, and am slowly turning them into man(1) pages and sometimes'
write(io,'(a)')'   altering them.'
write(io,'(a)')''
write(io,'(a)')'   *Note*: In many cases the descriptions of these intrinsics were originally'
write(io,'(a)')'   taken from the [[GFortran|GNU Fortran]] manual to make descriptions'
write(io,'(a)')'   on the Fortran Wiki by Jason Blevins (which were then used to start this'
write(io,'(a)')'   collection). Like the Fortran Wiki itself, the [[GFortran|GNU Fortran]]'
write(io,'(a)')'   manual is licensed under the [[GNU Free Documentation License]].'
write(io,'(a)')''
write(io,'(a)')'   These are at the state of "good enough considering the alternative is nothing",'
write(io,'(a)')'   but are still actively being completed.'
write(io,'(a)')''
write(io,'(a)')'CONTENTS'
write(io,'(a)')''
write(io,'(a)')'Inquiry intrinsic functions'
write(io,'(a)')''
write(io,'(a)')'The result of an inquiry function depends on the properties of its'
write(io,'(a)')'principal argument, not on the value of the argument. The value of the'
write(io,'(a)')'argument does not have to be defined.'
write(io,'(a)')''
write(io,'(a)')'   * [[allocated]]--Status of an allocatable entity'
write(io,'(a)')'   * [[associated]]--Status of a pointer or pointer/target pair'
write(io,'(a)')'   * [[bit_size]]--Bit size inquiry function'
write(io,'(a)')'   * [[command_argument_count]]--Get number of command line arguments'
write(io,'(a)')'   * [[digits]]--Significant digits function'
write(io,'(a)')'   * [[epsilon]]--Epsilon function'
write(io,'(a)')'   * [[extends_type_of]]--Type extension inquiry'
write(io,'(a)')'   * [[huge]]--Largest number of a kind'
write(io,'(a)')'   * [[is_contiguous]]--True if and only if an object is contiguous'
write(io,'(a)')'   * [[kind]]--Kind of an entity'
write(io,'(a)')'   * [[lbound]]--Lower dimension bounds of an array'
write(io,'(a)')'   * [[len]]--Length of a character entity'
write(io,'(a)')'   * [[maxexponent]]--Maximum exponent of a real kind'
write(io,'(a)')'   * [[minexponent]]--Minimum exponent of a real kind'
write(io,'(a)')'   * [[new_line]]--New line character'
write(io,'(a)')'   * [[precision]]--Decimal precision of a real kind'
write(io,'(a)')'   * [[present]]--Determine whether an optional dummy argument is specified'
write(io,'(a)')'   * [[radix]]--Base of a model number'
write(io,'(a)')'   * [[range]]--Decimal exponent range of a real kind'
write(io,'(a)')'   * [[same_type_as]]--Query dynamic types for equality'
write(io,'(a)')'   * [[shape]]--Determine the shape of an array'
write(io,'(a)')'   * [[size]]--Determine the size of an array'
write(io,'(a)')'   * [[tiny]]--Smallest positive number of a real kind'
write(io,'(a)')'   * [[ubound]]--Upper dimension bounds of an array'
write(io,'(a)')''
write(io,'(a)')'Math functions'
write(io,'(a)')''
write(io,'(a)')'   * [[abs]]--Absolute value'
write(io,'(a)')'   * [[acos]]--Arccosine function'
write(io,'(a)')'   * [[acosh]]--Inverse hyperbolic cosine function'
write(io,'(a)')'   * [[asin]]--Arcsine function'
write(io,'(a)')'   * [[asinh]]--Inverse hyperbolic sine function'
write(io,'(a)')'   * [[atan]]--Arctangent function'
write(io,'(a)')'   * [[atan2]]--Arctangent function'
write(io,'(a)')'   * [[atanh]]--Inverse hyperbolic tangent function'
write(io,'(a)')'   * [[bessel_j0]]--Bessel function of the first kind of order 0'
write(io,'(a)')'   * [[bessel_j1]]--Bessel function of the first kind of order 1'
write(io,'(a)')'   * [[bessel_jn]]--Bessel function of the first kind'
write(io,'(a)')'   * [[bessel_y0]]--Bessel function of the second kind of order 0'
write(io,'(a)')'   * [[bessel_y1]]--Bessel function of the second kind of order 1'
write(io,'(a)')'   * [[bessel_yn]]--Bessel function of the second kind'
write(io,'(a)')'   * [[cos]]--Cosine function'
write(io,'(a)')'   * [[cosh]]--Hyperbolic cosine function'
write(io,'(a)')'   * [[erf]]--Error function'
write(io,'(a)')'   * [[erfc]]--Complementary error function'
write(io,'(a)')'   * [[erfc_scaled]]--Error function'
write(io,'(a)')'   * [[gamma]]--Gamma function'
write(io,'(a)')'   * [[hypot]]--Euclidean distance function'
write(io,'(a)')'   * [[log]]--Logarithm function'
write(io,'(a)')'   * [[log10]]--Base 10 logarithm function'
write(io,'(a)')'   * [[log_gamma]]--Logarithm of the Gamma function'
write(io,'(a)')'   * [[sin]]--Sine function'
write(io,'(a)')'   * [[sinh]]--Hyperbolic sine function'
write(io,'(a)')'   * [[sqrt]]--Square-root function'
write(io,'(a)')'   * [[tan]]--Tangent function'
write(io,'(a)')'   * [[tanh]]--Hyperbolic tangent function'
write(io,'(a)')''
write(io,'(a)')'   * [[aimag]]--Imaginary part of complex number'
write(io,'(a)')'   * [[aint]]--Truncate to a whole number'
write(io,'(a)')'   * [[anint]]--Nearest whole number'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'   * [[achar]]--Character in ASCII collating sequence'
write(io,'(a)')'   * [[adjustl]]--Left adjust a string'
write(io,'(a)')'   * [[adjustr]]--Right adjust a string'
write(io,'(a)')'   * [[all]]--All values in MASK along DIM are true'
write(io,'(a)')'   * [[any]]--Any value in MASK along DIM is true'
write(io,'(a)')'   * [[atomic_add]]--Atomic ADD operation'
write(io,'(a)')'   * [[atomic_and]]--Atomic bitwise AND operation'
write(io,'(a)')'   * [[atomic_cas]]--Atomic compare and swap'
write(io,'(a)')'   * [[atomic_define]]--Setting a variable atomically'
write(io,'(a)')'   * [[atomic_fetch_add]]--Atomic ADD operation with prior fetch'
write(io,'(a)')'   * [[atomic_fetch_and]]--Atomic bitwise AND operation with prior fetch'
write(io,'(a)')'   * [[atomic_fetch_or]]--Atomic bitwise OR operation with prior fetch'
write(io,'(a)')'   * [[atomic_fetch_xor]]--Atomic bitwise XOR operation with prior fetch'
write(io,'(a)')'   * [[atomic_or]]--Atomic bitwise OR operation'
write(io,'(a)')'   * [[atomic_ref]]--Obtaining the value of a variable atomically'
write(io,'(a)')'   * [[atomic_xor]]--Atomic bitwise OR operation'
write(io,'(a)')'   * [[bge]]--Bitwise greater than or equal to'
write(io,'(a)')'   * [[bgt]]--Bitwise greater than'
write(io,'(a)')'   * [[ble]]--Bitwise less than or equal to'
write(io,'(a)')'   * [[blt]]--Bitwise less than'
write(io,'(a)')'   * [[btest]]--Bit test function'
write(io,'(a)')'   * [[c_associated]]--Status of a C pointer'
write(io,'(a)')'   * [[c_funloc]]--Obtain the C address of a procedure'
write(io,'(a)')'   * [[c_f_procpointer]]--Convert C into Fortran procedure pointer'
write(io,'(a)')'   * [[c_f_pointer]]--Convert C into Fortran pointer'
write(io,'(a)')'   * [[c_loc]]--Obtain the C address of an object'
write(io,'(a)')'   * [[c_sizeof]]--Size in bytes of an expression'
write(io,'(a)')'   * [[ceiling]]--Integer ceiling function'
write(io,'(a)')'   * [[char]]--Character conversion function'
write(io,'(a)')'   * [[cmplx]]--Complex conversion function'
write(io,'(a)')'   * [[co_broadcast]]--Copy a value to all images the current set of images'
write(io,'(a)')'   * [[co_max]]--Maximal value on the current set of images'
write(io,'(a)')'   * [[co_min]]--Minimal value on the current set of images'
write(io,'(a)')'   * [[co_reduce]]--Reduction of values on the current set of images'
write(io,'(a)')'   * [[co_sum]]--Sum of values on the current set of images'
write(io,'(a)')'   * [[compiler_options]]--Options passed to the compiler'
write(io,'(a)')'   * [[compiler_version]]--Compiler version string'
write(io,'(a)')'   * [[conjg]]--Complex conjugate function'
write(io,'(a)')'   * [[count]]--Count function'
write(io,'(a)')'   * [[cpu_time]]--CPU elapsed time in seconds'
write(io,'(a)')'   * [[cshift]]--Circular shift elements of an array'
write(io,'(a)')'   * [[date_and_time]]--Date and time subroutine'
write(io,'(a)')'   * [[dble]]--Double conversion function'
write(io,'(a)')'   * [[dim]]--Positive difference'
write(io,'(a)')'   * [[dot_product]]--Dot product function'
write(io,'(a)')'   * [[dprod]]--Double product function'
write(io,'(a)')'   * [[dshiftl]]--Combined left shift'
write(io,'(a)')'   * [[dshiftr]]--Combined right shift'
write(io,'(a)')'   * [[eoshift]]--End-off shift elements of an array'
write(io,'(a)')'   * [[event_query]]--Query whether a coarray event has occurred'
write(io,'(a)')'   * [[execute_command_line]]--Execute a shell command'
write(io,'(a)')'   * [[exp]]--Exponential function'
write(io,'(a)')'   * [[exponent]]--Exponent function'
write(io,'(a)')'   * [[float]]--Convert integer to default real'
write(io,'(a)')'   * [[floor]]--Integer floor function'
write(io,'(a)')'   * [[fraction]]--Fractional part of the model representation'
write(io,'(a)')'   * [[get_command]]--Get the entire command line'
write(io,'(a)')'   * [[get_command_argument]]--Get command line arguments'
write(io,'(a)')'   * [[get_environment_variable]]--Get an environmental variable'
write(io,'(a)')'   * [[iachar]]--Code in ASCII collating sequence'
write(io,'(a)')'   * [[iall]]--Bitwise and of array elements'
write(io,'(a)')'   * [[iand]]--Bitwise logical and'
write(io,'(a)')'   * [[iany]]--Bitwise or of array elements'
write(io,'(a)')'   * [[ibclr]]--Clear bit'
write(io,'(a)')'   * [[ibits]]--Bit extraction'
write(io,'(a)')'   * [[ibset]]--Set bit'
write(io,'(a)')'   * [[ichar]]--Character-to-integer conversion function'
write(io,'(a)')'   * [[ieor]]--Bitwise logical exclusive or'
write(io,'(a)')'   * [[image_index]]--Cosubscript to image index conversion'
write(io,'(a)')'   * [[index]]--Position of a substring within a string'
write(io,'(a)')'   * [[int]]--Convert to integer type'
write(io,'(a)')'   * [[ior]]--Bitwise logical inclusive or'
write(io,'(a)')'   * [[iparity]]--Bitwise exclusive or of array elements'
write(io,'(a)')'   * [[is_iostat_end]]--Test for end-of-file value'
write(io,'(a)')'   * [[is_iostat_eor]]--Test for end-of-record value'
write(io,'(a)')'   * [[ishft]]--Shift bits'
write(io,'(a)')'   * [[ishftc]]--Shift bits circularly'
write(io,'(a)')'   * [[co_lbound]]--Lower codimension bounds of an array'
write(io,'(a)')'   * [[leadz]]--Number of leading zero bits of an integer'
write(io,'(a)')'   * [[len_trim]]--Length of a character entity without trailing blank characters'
write(io,'(a)')'   * [[lge]]--Lexical greater than or equal'
write(io,'(a)')'   * [[lgt]]--Lexical greater than'
write(io,'(a)')'   * [[lle]]--Lexical less than or equal'
write(io,'(a)')'   * [[llt]]--Lexical less than'
write(io,'(a)')'   * [[logical]]--Convert to logical type'
write(io,'(a)')'   * [[maskl]]--Left justified mask'
write(io,'(a)')'   * [[maskr]]--Right justified mask'
write(io,'(a)')'   * [[matmul]]--matrix multiplication'
write(io,'(a)')'   * [[max]]--Maximum value of an argument list'
write(io,'(a)')'   * [[maxloc]]--Location of the maximum value within an array'
write(io,'(a)')'   * [[maxval]]--Maximum value of an array'
write(io,'(a)')'   * [[merge]]--Merge variables'
write(io,'(a)')'   * [[merge_bits]]--Merge of bits under mask'
write(io,'(a)')'   * [[min]]--Minimum value of an argument list'
write(io,'(a)')'   * [[minloc]]--Location of the minimum value within an array'
write(io,'(a)')'   * [[minval]]--Minimum value of an array'
write(io,'(a)')'   * [[mod]]--Remainder function'
write(io,'(a)')'   * [[modulo]]--Modulo function'
write(io,'(a)')'   * [[move_alloc]]--Move allocation from one object to another'
write(io,'(a)')'   * [[mvbits]]--Move bits from one integer to another'
write(io,'(a)')'   * [[nearest]]--Nearest representable number'
write(io,'(a)')'   * [[nint]]--Nearest whole number'
write(io,'(a)')'   * [[not]]--Logical negation'
write(io,'(a)')'   * [[norm2]]--Euclidean vector norm'
write(io,'(a)')'   * [[null]]--Function that returns an disassociated pointer'
write(io,'(a)')'   * [[num_images]]--Number of images'
write(io,'(a)')'   * [[pack]]--Pack an array into an array of rank one'
write(io,'(a)')'   * [[parity]]--Reduction with exclusive or'
write(io,'(a)')'   * [[popcnt]]--Number of bits set'
write(io,'(a)')'   * [[poppar]]--Parity of the number of bits set'
write(io,'(a)')'   * [[product]]--Product of array elements'
write(io,'(a)')'   * [[random_number]]--Pseudo-random number'
write(io,'(a)')'   * [[random_seed]]--Initialize a pseudo-random number sequence'
write(io,'(a)')'   * [[rank]]--Rank of a data object'
write(io,'(a)')'   * [[real]]--Convert to real type'
write(io,'(a)')'   * [[repeat]]--Repeated string concatenation'
write(io,'(a)')'   * [[reshape]]--Function to reshape an array'
write(io,'(a)')'   * [[rrspacing]]--Reciprocal of the relative spacing'
write(io,'(a)')'   * [[scale]]--Scale a real value'
write(io,'(a)')'   * [[scan]]--Scan a string for the presence of a set of characters'
write(io,'(a)')'   * [[selected_char_kind]]--Choose character kind'
write(io,'(a)')'   * [[selected_int_kind]]--Choose integer kind'
write(io,'(a)')'   * [[selected_real_kind]]--Choose real kind'
write(io,'(a)')'   * [[set_exponent]]--Set the exponent of the model'
write(io,'(a)')'   * [[shifta]]--Right shift with fill'
write(io,'(a)')'   * [[shiftl]]--Left shift'
write(io,'(a)')'   * [[shiftr]]--Right shift'
write(io,'(a)')'   * [[sign]]--Sign copying function'
write(io,'(a)')'   * [[sngl]]--Convert double precision real to default real'
write(io,'(a)')'   * [[spacing]]--Smallest distance between two numbers of a given type'
write(io,'(a)')'   * [[spread]]--Add a dimension to an array'
write(io,'(a)')'   * [[storage_size]]--Storage size in bits'
write(io,'(a)')'   * [[sum]]--Sum of array elements'
write(io,'(a)')'   * [[system_clock]]--Time function'
write(io,'(a)')'   * [[this_image]]--Cosubscript index of this image'
write(io,'(a)')'   * [[trailz]]--Number of trailing zero bits of an integer'
write(io,'(a)')'   * [[transfer]]--Transfer bit patterns'
write(io,'(a)')'   * [[transpose]]--Transpose an array of rank two'
write(io,'(a)')'   * [[trim]]--Remove trailing blank characters of a string'
write(io,'(a)')'   * [[co_ubound]]--Upper codimension bounds of an array'
write(io,'(a)')'   * [[unpack]]--Store the elements of a vector in an array of higher rank'
write(io,'(a)')'   * [[verify]]--Scan a string for the absence of a set of characters'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'   INTRINSICS_PROJECT(7f) - [FORTRAN] intrinsic man(1) pages'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   This is a project to provide a standard set of man(1) pages for Fortran'
write(io,'(a)')'   and the Fortran intrinsics, ultimately with a working example program'
write(io,'(a)')'   for each intrinsic.'
write(io,'(a)')''
write(io,'(a)')'   The manpage source is maintained as a single flat-text file'
write(io,'(a)')'   (intrinsics.ff) which is run thru ufpp(1) and filters like txt2man(1)'
write(io,'(a)')'   to create the program intrinsics(1f). That program generates all'
write(io,'(a)')'   the text as plain text as well as being used as the source for the'
write(io,'(a)')'   man(1) pages. The program intrinsics(1f) is very useful for scanning'
write(io,'(a)')'   for keywords.'
write(io,'(a)')''
write(io,'(a)')'   Note that the vim(1) editor will call up a man(1) page for a word if'
write(io,'(a)')'   the letter "K" is pressed over the word.'
write(io,'(a)')''
write(io,'(a)')'   Integration with the editor is a powerful tool when inspecting code'
write(io,'(a)')'   that uses unfamiliar procedures and to verify correct usage when'
write(io,'(a)')'   creating code.'
write(io,'(a)')''
write(io,'(a)')'   *Note*: In many cases the descriptions of these intrinsics were'
write(io,'(a)')'   originally taken from the [[GFortran|GNU Fortran]] manual to make'
write(io,'(a)')'   descriptions on the Fortran Wiki by Jason Blevins (which were then'
write(io,'(a)')'   used to start this collection). Like the Fortran Wiki itself, the'
write(io,'(a)')'   [[GFortran|GNU Fortran]] manual is licensed under the [[GNU Free'
write(io,'(a)')'   Documentation License]].'
write(io,'(a)')''
write(io,'(a)')'   These documents are at the state of "good enough considering the'
write(io,'(a)')'   alternative is nothing", but are still actively being completed.'
write(io,'(a)')''
write(io,'(a)')'INTRINSICS SECTION'
write(io,'(a)')''
write(io,'(a)')'  XXXXX  XX  XXX XXXXXXX XXXXXX   XXXXX  XX  XXX  XXXXX   XXXXX    XXXX   XXXXX'
write(io,'(a)')'    X     X   X  X  X  X  X    X    X     X   X  X     X    X     X    X X     X'
write(io,'(a)')'    X     XX  X     X     X    X    X     XX  X  X          X    X       X'
write(io,'(a)')'    X     XX  X     X     X    X    X     XX  X  X          X    X       X'
write(io,'(a)')'    X     X X X     X     XXXXX     X     X X X   XXXXX     X    X        XXXXX'
write(io,'(a)')'    X     X  XX     X     X  X      X     X  XX        X    X    X             X'
write(io,'(a)')'    X     X  XX     X     X  X      X     X  XX        X    X    X             X'
write(io,'(a)')'    X     X   X     X     X   X     X     X   X  X     X    X     X    X X     X'
write(io,'(a)')'  XXXXX  XXX  X    XXX   XXX  XX  XXXXX  XXX  X   XXXXX   XXXXX    XXXX   XXXXX'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     ABS(3f) - [INTRINSIC:NUMERIC] Absolute value'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'   result = ABS(A)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   ABS(A) computes the absolute value of A.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')'  A  - the type of the argument shall be an INTEGER, REAL, or'
write(io,'(a)')'       COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')'   The return value is of the same type and kind as the argument except'
write(io,'(a)')'   the return value is REAL for a COMPLEX argument.'
write(io,'(a)')''
write(io,'(a)')'   If A is of type INTEGER or REAL, the value of the result is |A|; if A is'
write(io,'(a)')'   COMPLEX with value (X, Y), the result is equal to a processor-dependent'
write(io,'(a)')'   approximation to SQRT(X**2 + Y**2) computed without undue overflow'
write(io,'(a)')'   or underflow.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'     program demo_abs'
write(io,'(a)')'     integer :: i = -1, iout'
write(io,'(a)')'     real :: x = -1.e0, xout, zout'
write(io,'(a)')'     complex :: z = (-3.e0,4.e0)'
write(io,'(a)')'        write(*,*)''INPUTS:'',i,x,z'
write(io,'(a)')'        iout = abs(i)'
write(io,'(a)')'        xout = abs(x)'
write(io,'(a)')'        zout = abs(z)'
write(io,'(a)')'        write(*,*)''OUTPUTS:'',iout,xout,zout'
write(io,'(a)')'        ! 3 - 4 -5 right triangle test :'
write(io,'(a)')'        write(*,*)''The abs() of (3.0,4.0) should be 5.0'',abs((3.0,4.0))'
write(io,'(a)')'     end program demo_abs'
write(io,'(a)')'  Results:'
write(io,'(a)')''
write(io,'(a)')'    INPUTS:   -1  -1.00000000    (-3.00000000,4.00000000)'
write(io,'(a)')'    OUTPUTS:   1   1.00000000      5.00000000'
write(io,'(a)')'    The abs() of (3.0,4.0) should be 5.0   5.00000000'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Elemental function'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     ACHAR(3f) - [INTRINSIC:CHARACTER] returns a character in a specified position in the ASCII collating sequence'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'   result = ACHAR(I [, KIND])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   ACHAR(I) returns the character located at position I in the ASCII'
write(io,'(a)')'   collating sequence.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I     - the type shall be INTEGER.'
write(io,'(a)')'   KIND  - (optional) an INTEGER initialization expression'
write(io,'(a)')'           indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type CHARACTER with a length of one. If the'
write(io,'(a)')'   KIND argument is present, the return value is of the specified kind'
write(io,'(a)')'   and of the default kind otherwise.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_achar'
write(io,'(a)')'      character c'
write(io,'(a)')'      c = achar(32)'
write(io,'(a)')'    end program demo_achar'
write(io,'(a)')''
write(io,'(a)')'NOTE'
write(io,'(a)')''
write(io,'(a)')'   see [[ichar]] for a discussion of converting between numerical'
write(io,'(a)')'   values and formatted string representations.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later, with KIND argument Fortran 2003 and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Elemental function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[char]], [[iachar]], [[ichar]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     ACOS(3f) - [INTRINSIC:TRIGONOMETRIC] Arccosine function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'   result = ACOS(X)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   ACOS(X) computes the arccosine of X (inverse of cos(x)).'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type shall be REAL with a magnitude that is'
write(io,'(a)')'        less than one.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of the same type and kind as X.'
write(io,'(a)')'   The real part of the result is in radians and lies in the range'
write(io,'(a)')''
write(io,'(a)')'   0 <= ACOS(X) <= PI.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_acos'
write(io,'(a)')'      real(8) :: x = 0.866_8'
write(io,'(a)')'      x = acos(x)'
write(io,'(a)')'    end program demo_acos'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later, for a complex argument [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Elemental function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'Inverse function: [[cos]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     ACOSH(3f) - [INTRINSIC:TRIGONOMETRIC] Inverse hyperbolic cosine function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = acosh(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   ACOSH(X) computes the inverse hyperbolic cosine of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - the type shall be REAL or COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value has the same type and kind as X.'
write(io,'(a)')'   If X is complex, the imaginary part of the result is in radians and lies between'
write(io,'(a)')''
write(io,'(a)')'      0 <= AIMAG(ACOSH(X)) <= PI.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_acosh'
write(io,'(a)')'      real(8), dimension(3) :: x = (/ 1.0, 2.0, 3.0 /)'
write(io,'(a)')'      write (*,*) acosh(x)'
write(io,'(a)')'    end program demo_acosh'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Elemental function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'Inverse function: [[cosh]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     ADJUSTL(3f) - [INTRINSIC:CHARACTER] Left adjust a string'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = ADJUSTL(STRING)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   ADJUSTL(STRING) will left adjust a string by removing leading spaces.'
write(io,'(a)')'   Spaces are inserted at the end of the string as needed.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   STRING  - the type shall be CHARACTER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type CHARACTER and of the same kind as'
write(io,'(a)')'   STRING where leading spaces are removed and the same number of'
write(io,'(a)')'   spaces are inserted on the end of STRING.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_adjustl'
write(io,'(a)')'      character(len=20) :: str = ''   gfortran'''
write(io,'(a)')'      str = adjustl(str)'
write(io,'(a)')'      print *, str'
write(io,'(a)')'    end program demo_adjustl'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Elemental function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[adjustr]], [[trim]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     ADJUSTR(3f) - [INTRINSIC:CHARACTER] Right adjust a string'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = ADJUSTR(STRING)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   ADJUSTR(STRING) will right adjust a string by removing trailing spaces.'
write(io,'(a)')'   Spaces are inserted at the start of the string as needed.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   STRING  - the type shall be CHARACTER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type CHARACTER and of the same kind as'
write(io,'(a)')'   STRING where trailing spaces are removed and the same number of'
write(io,'(a)')'   spaces are inserted at the start of STRING.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_adjustr'
write(io,'(a)')'      character(len=20) :: str = ''gfortran'''
write(io,'(a)')'      str = adjustr(str)'
write(io,'(a)')'      print *, str'
write(io,'(a)')'    end program demo_adjustr'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Elemental function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[adjustl]], [[trim]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     AIMAG(3f) - [INTRINSIC:NUMERIC] Imaginary part of complex number'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = AIMAG(Z)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   AIMAG(Z) yields the imaginary part of complex argument Z.'
write(io,'(a)')'   The IMAG(Z) and IMAGPART(Z) intrinsic functions are provided'
write(io,'(a)')'   for compatibility with G77, and their use in new code is'
write(io,'(a)')'   strongly discouraged.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   Z  - The type of the argument shall be COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type REAL with the'
write(io,'(a)')'   kind type parameter of the argument.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_aimag'
write(io,'(a)')'      complex(4) z4'
write(io,'(a)')'      complex(8) z8'
write(io,'(a)')'      z4 = cmplx(1.e0_4, 0.e0_4)'
write(io,'(a)')'      z8 = cmplx(0.e0_8, 1.e0_8)'
write(io,'(a)')'      print *, aimag(z4), dimag(z8)'
write(io,'(a)')'    end program demo_aimag'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Elemental function'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     AINT(3f) - [INTRINSIC:NUMERIC] Truncate to a whole number'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = AINT(A [, KIND])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   AINT(A [, KIND]) truncates its argument to a whole number.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   A     - the type of the argument shall be REAL.'
write(io,'(a)')'   KIND  - (optional) an INTEGER initialization expression'
write(io,'(a)')'           indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type REAL with the kind type parameter of the'
write(io,'(a)')'   argument if the optional KIND is absent; otherwise, the kind type'
write(io,'(a)')'   parameter will be given by KIND. If the magnitude of X is less'
write(io,'(a)')'   than one, aint(x) returns zero. If the magnitude is equal to or'
write(io,'(a)')'   greater than one then it returns the largest whole number that does'
write(io,'(a)')'   not exceed its magnitude. The sign is the same as the sign of X.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_aint'
write(io,'(a)')'      real(4) x4'
write(io,'(a)')'      real(8) x8'
write(io,'(a)')'      x4 = 1.234E0_4'
write(io,'(a)')'      x8 = 4.321_8'
write(io,'(a)')'      print *, aint(x4), dint(x8)'
write(io,'(a)')'      x8 = aint(x4,8)'
write(io,'(a)')'    end program demo_aint'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Elemental function'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     ALL(3f) - [INTRINSIC:TRANSFORMATIONAL FUNCTION] determines if all the values are true'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = ALL(MASK [, DIM])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Logical conjunction of elements of MASK along dimension DIM.'
write(io,'(a)')''
write(io,'(a)')'   "ALL(MASK [, DIM])" determines if all the values are true in MASK'
write(io,'(a)')'   in the array along dimension DIM.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   MASK  - shall be a logical array. That is,'
write(io,'(a)')'           the type of the argument shall be LOGICAL and it shall'
write(io,'(a)')'           not be scalar.'
write(io,'(a)')'   DIM   - (optional) DIM shall be a scalar integer with a value'
write(io,'(a)')'           that lies between one and the rank of MASK.'
write(io,'(a)')'           The corresponding actual argument shall not be an optional'
write(io,'(a)')'           dummy argument.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   "ALL(MASK)" returns a scalar value of type LOGICAL where the kind'
write(io,'(a)')'   type parameter is the same as the kind type parameter of MASK. If'
write(io,'(a)')'   DIM is present, then ALL(MASK, DIM) returns an array with the rank'
write(io,'(a)')'   of MASK minus 1. The shape is determined from the shape of MASK'
write(io,'(a)')'   where the DIM dimension is elided.'
write(io,'(a)')''
write(io,'(a)')'    1. ALL(MASK) is true if all elements of MASK are true.'
write(io,'(a)')'       It also is true if MASK has zero size; otherwise, it is false.'
write(io,'(a)')''
write(io,'(a)')'    2. If the rank of MASK is one, then ALL(MASK, DIM) is equivalent'
write(io,'(a)')'       to ALL(MASK). If the rank is greater than one, then ALL(MASK,'
write(io,'(a)')'       DIM) is determined by applying ALL to the array sections.'
write(io,'(a)')''
write(io,'(a)')'    4. Result Characteristics. The result is of type logical with the same'
write(io,'(a)')'       kind type parameter as MASK. It is scalar'
write(io,'(a)')'       if DIM is absent or n = 1; otherwise, the result has rank n - 1 and'
write(io,'(a)')'       shape [d1 , d2 , . . . , dDIM-1 , dDIM+1 , . . . , dn ] where [d1 ,'
write(io,'(a)')'       d2 , . . . , dn ] is the shape of MASK.'
write(io,'(a)')''
write(io,'(a)')'    5. Result Value.'
write(io,'(a)')''
write(io,'(a)')'       Case (i):     The result of ALL (MASK) has the value true if all'
write(io,'(a)')'                     elements of MASK are true or if MASK has'
write(io,'(a)')'                     size zero, and the result has value false if any element'
write(io,'(a)')'                     of MASK is false.'
write(io,'(a)')''
write(io,'(a)')'       Case (ii):    If MASK has rank one, ALL(MASK,DIM) is equal to'
write(io,'(a)')'                     ALL(MASK). Otherwise, the value of element'
write(io,'(a)')'                     (s1 , s2 , . . . , sDIM-1 , sDIM+1 , . . . , sn ) of ALL'
write(io,'(a)')'                     (MASK, DIM) is equal to ALL (MASK (s1 , s2 , . . . ,'
write(io,'(a)')'                     sDIM-1 , :, sDIM+1 , . . . , sn )).'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_all'
write(io,'(a)')'      logical l'
write(io,'(a)')'      l = all((/.true., .true., .true./))'
write(io,'(a)')'      print *, l'
write(io,'(a)')'      call section'
write(io,'(a)')'    contains'
write(io,'(a)')'       subroutine section'
write(io,'(a)')'          integer a(2,3), b(2,3)'
write(io,'(a)')'          a = 1'
write(io,'(a)')'          b = 1'
write(io,'(a)')'          b(2,2) = 2'
write(io,'(a)')'          print *, all(a .eq. b, 1)'
write(io,'(a)')'          print *, all(a .eq. b, 2)'
write(io,'(a)')'       end subroutine section'
write(io,'(a)')'    end program demo_all'
write(io,'(a)')''
write(io,'(a)')'  Case (i):'
write(io,'(a)')''
write(io,'(a)')'     The value of ALL ([.TRUE., .FALSE., .TRUE.]) is false.'
write(io,'(a)')''
write(io,'(a)')'  Case (ii):'
write(io,'(a)')'                            1|3|5'
write(io,'(a)')'     If B is the array      -+-+-'
write(io,'(a)')'                            2|4|6'
write(io,'(a)')''
write(io,'(a)')'                            0|3|5'
write(io,'(a)')'     and C is the array     -+-+-'
write(io,'(a)')'                            7|4|8'
write(io,'(a)')''
write(io,'(a)')'     then ALL (B /= C, DIM = 1) is'
write(io,'(a)')'        [true, false, false]'
write(io,'(a)')'     and ALL (B /= C, DIM = 2) is'
write(io,'(a)')'        [false, false].'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')'   Transformational function.'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'   free_source_form(7f) - [FORTRAN] syntax of free source form statements, comments, and continuation lines'
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'   [label] statement [! comment]'
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'  There are two source forms: free and fixed. Fixed-format is generally'
write(io,'(a)')'  considered deprecated but is commonly encountered in older codes,'
write(io,'(a)')'  as all FORTRAN pre-Fortran90 was fixed-form. All new code should be'
write(io,'(a)')'  generated as free-format without some overwhelming reason, such as'
write(io,'(a)')'  the need to use fixed-form INCLUDE files, or where it is required to'
write(io,'(a)')'  be compatible with very old compilers.'
write(io,'(a)')''
write(io,'(a)')'  Free form and fixed form may not be mixed in the same program unit.'
write(io,'(a)')'  The means for specifying the source form of a program unit are'
write(io,'(a)')'  processor dependent. Most commonly, if the file ends if .F or .f it'
write(io,'(a)')'  is assumed to be fixed-form; a suffix of .f90 or .F90 indicates the'
write(io,'(a)')'  file is free-format.'
write(io,'(a)')''
write(io,'(a)')'  In free source form there are no restrictions on where a statement (or'
write(io,'(a)')'  portion of a statement) may appear within a line. A line may contain'
write(io,'(a)')'  zero characters. If a line consists entirely of characters of default'
write(io,'(a)')'  kind, it may contain at most 132 characters. If a line contains any'
write(io,'(a)')'  character that is not of default kind, the maximum number of characters'
write(io,'(a)')'  allowed on the line is processor dependent.'
write(io,'(a)')''
write(io,'(a)')'  BLANK CHARACTERS IN FREE FORM'
write(io,'(a)')''
write(io,'(a)')'  In free source form blank characters shall not appear within'
write(io,'(a)')'  lexical tokens other than in a character context or in a format'
write(io,'(a)')'  specification. Blanks may be inserted freely between tokens to improve'
write(io,'(a)')'  readability; for example, blanks may occur between the tokens that form'
write(io,'(a)')'  a complex literal constant. A sequence of blank characters outside of'
write(io,'(a)')'  a character context is equivalent to a single blank character.'
write(io,'(a)')''
write(io,'(a)')'  A blank shall be used to separate names, constants, or labels from'
write(io,'(a)')'  adjacent keywords, names, constants, or labels. For example, the'
write(io,'(a)')'  blanks after REAL, READ, 30, and DO are required in the following:'
write(io,'(a)')''
write(io,'(a)')'    >   REAL X'
write(io,'(a)')'    >   READ 10'
write(io,'(a)')'    >   30 DO K=1,3'
write(io,'(a)')''
write(io,'(a)')'  One or more blanks shall be used to separate adjacent keywords except'
write(io,'(a)')'  in the following cases, where blanks are optional:'
write(io,'(a)')''
write(io,'(a)')'  Adjacent keywords where separating blanks are optional'
write(io,'(a)')''
write(io,'(a)')'    >   ALL STOP           >   END IF'
write(io,'(a)')'    >   BLOCK DATA         >   END MODULE'
write(io,'(a)')'    >   DOUBLE PRECISION   >   END INTERFACE'
write(io,'(a)')'    >   ELSEIF             >   END PROCEDURE'
write(io,'(a)')'    >   ELSE WHERE         >   END PROGRAM'
write(io,'(a)')'    >   END ASSOCIATE      >   END SELECT'
write(io,'(a)')'    >   END BLOCK          >   END SUBMODULE'
write(io,'(a)')'    >   END BLOCK DATA     >   END SUBROUTINE'
write(io,'(a)')'    >   END CRITICAL       >   END TYPE'
write(io,'(a)')'    >   END DO             >   END WHERE'
write(io,'(a)')'    >   END ENUM           >   GO TO'
write(io,'(a)')'    >   END FILE           >   IN OUT'
write(io,'(a)')'    >   END FORALL         >   SELECT CASE'
write(io,'(a)')'    >   END FUNCTION       >   SELECT TYPE'
write(io,'(a)')''
write(io,'(a)')'  FREE FORM COMMENTARY'
write(io,'(a)')''
write(io,'(a)')'  The character "!" initiates a comment except where it appears within'
write(io,'(a)')'  a character context. The comment'
write(io,'(a)')'  extends to the end of the line. If the first nonblank character on'
write(io,'(a)')'  a line is an "!", the line is a comment line. Lines containing only'
write(io,'(a)')'  blanks or containing no characters are also comment lines. Comments may'
write(io,'(a)')'  appear anywhere in a program unit and may precede the first statement'
write(io,'(a)')'  of a program unit or may follow the last statement of a program'
write(io,'(a)')'  unit. Comments have no effect on the interpretation of the program unit.'
write(io,'(a)')''
write(io,'(a)')'       NOTE 3.6'
write(io,'(a)')'       This part of ISO/IEC 1539 does not restrict the number of'
write(io,'(a)')'       consecutive comment lines.'
write(io,'(a)')''
write(io,'(a)')'  FREE FORM STATEMENT CONTINUATION'
write(io,'(a)')''
write(io,'(a)')'  The character "&" is used to indicate that the current statement is'
write(io,'(a)')'  continued on the next line that is not a'
write(io,'(a)')'  comment line. Comment lines cannot be continued; an "&" in a comment'
write(io,'(a)')'  has no effect. Comments may occur within a continued statement. When'
write(io,'(a)')'  used for continuation, the "&" is not part of the statement. No line'
write(io,'(a)')'  shall contain a single "&" as the only nonblank character or as the'
write(io,'(a)')'  only nonblank character before an "!" that initiates a comment.'
write(io,'(a)')''
write(io,'(a)')'  If a noncharacter context is to be continued, an "&" shall be the last'
write(io,'(a)')'  nonblank character on the line, or the last'
write(io,'(a)')'  nonblank character before an "!". There shall be a later line that is'
write(io,'(a)')'  not a comment; the statement is continued on the next such line. If'
write(io,'(a)')'  the first nonblank character on that line is an "&", the statement'
write(io,'(a)')'  continues at the next character position following that "&"; otherwise,'
write(io,'(a)')'  it continues with the first character position of that line.'
write(io,'(a)')''
write(io,'(a)')'  If a lexical token is split across the end of a line, the first nonblank'
write(io,'(a)')'  character on the first following noncomment'
write(io,'(a)')'  line shall be an "&" immediately followed by the successive characters'
write(io,'(a)')'  of the split token.'
write(io,'(a)')''
write(io,'(a)')'  If a character context is to be continued, an "&" shall be the last'
write(io,'(a)')'  nonblank character on the line and shall not be'
write(io,'(a)')'  followed by commentary. There shall be a later line that is not a'
write(io,'(a)')'  comment; an "&" shall be the first nonblank character on the next such'
write(io,'(a)')'  line and the statement continues with the next character following that'
write(io,'(a)')'  "&".'
write(io,'(a)')''
write(io,'(a)')'  FREE FORM STATEMENT TERMINATION'
write(io,'(a)')''
write(io,'(a)')'  If a statement is not continued, a comment or the end of the line'
write(io,'(a)')'  terminates the statement.'
write(io,'(a)')''
write(io,'(a)')'  A statement may alternatively be terminated by a ";" character that'
write(io,'(a)')'  appears other than in a character context'
write(io,'(a)')'  or in a comment. The ";" is not part of the statement. After a ";"'
write(io,'(a)')'  terminator, another statement may appear on the same line, or begin'
write(io,'(a)')'  on that line and be continued. A sequence consisting only of zero'
write(io,'(a)')'  or more blanks and one or more ";" terminators, in any order, is'
write(io,'(a)')'  equivalent to a single ";" terminator.'
write(io,'(a)')''
write(io,'(a)')'  FREE FORM STATEMENTS'
write(io,'(a)')''
write(io,'(a)')'  A label may precede any statement not forming part of another statement'
write(io,'(a)')'  (Note that no Fortran statement begins with a digit).'
write(io,'(a)')''
write(io,'(a)')'  It is strongly suggested that numeric labels only be used on CONTINUE'
write(io,'(a)')'  statements and for labeling FORMAT statements.'
write(io,'(a)')''
write(io,'(a)')'  A statement shall not have more than 255 continuation lines.'
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_free_source_form'
write(io,'(a)')'   use,intrinsic :: iso_fortran_env, only : ERROR_UNIT, &'
write(io,'(a)')'                                            INPUT_UNIT, &'
write(io,'(a)')'                                            OUTPUT_UNIT ! access computing environment'
write(io,'(a)')'   use iso_fortran_env, only : int8, int32, int64'
write(io,'(a)')'   implicit none'
write(io,'(a)')'   integer,parameter  :: dp=kind(0.0d0)'
write(io,'(a)')'   real(kind=dp),save :: x(10)=0.0_dp'
write(io,'(a)')'   character(len=255) :: filename'
write(io,'(a)')'   logical            :: lval'
write(io,'(a)')'   integer            :: ier'
write(io,'(a)')'   integer            :: i_myloop'
write(io,'(a)')'   integer            :: i, j, k'
write(io,'(a)')'   character(len=*),parameter    :: VERSION=''1.0'''
write(io,'(a)')'   character(len=:), allocatable :: mystring'
write(io,'(a)')'      call usage()'
write(io,'(a)')'      filename=''my file'''
write(io,'(a)')'      print *, "filename=", trim(filename)'
write(io,'(a)')'   !-----------------------------------------------------------------------'
write(io,'(a)')'      MYLOOP: do I_MYLOOP=1,10  ! DO loop'
write(io,'(a)')'         cycle MYLOOP           ! start next pass of loop'
write(io,'(a)')'         exit  MYLOOP           ! go to next statment after corresponding ENDDO'
write(io,'(a)')'      enddo MYLOOP'
write(io,'(a)')'   !-----------------------------------------------------------------------'
write(io,'(a)')'      block'
write(io,'(a)')'         character(len=1) :: c'
write(io,'(a)')'         mystring=trim(filename)'
write(io,'(a)')'         do i=1,len(mystring)'
write(io,'(a)')'            c=mystring(i:i)'
write(io,'(a)')'            select case (c)'
write(io,'(a)')'             CASE (''a'' : ''j'');            WRITE(*,*)c, '' :One of the first ten letters'''
write(io,'(a)')'             CASE (''l'' : ''p'', ''u'' : ''y''); WRITE(*,*)c, '' :One of l, m, n, o, p, u, v, w, x, y'''
write(io,'(a)')'             CASE (''z'', ''q'' : ''t'');       WRITE(*,*)c, '' :One of z, q, r, s, t'''
write(io,'(a)')'             CASE DEFAULT'
write(io,'(a)')'               WRITE(ERROR_UNIT,*)c, '' :Other characters, which may not be letters'''
write(io,'(a)')'            end select'
write(io,'(a)')'         enddo'
write(io,'(a)')'         write(*,*)signum([10,20,0,-100])'
write(io,'(a)')'         ! mine(3f) is a function that does I/O. Do not use in an I/O statement'
write(io,'(a)')'         x=mine(100.40)'
write(io,'(a)')'      endblock'
write(io,'(a)')'   !-----------------------------------------------------------------------'
write(io,'(a)')'   contains'
write(io,'(a)')'   ! An integer signum function:'
write(io,'(a)')'   elemental integer function signum (n)'
write(io,'(a)')'   integer,intent(in) :: n'
write(io,'(a)')'     select case (n)'
write(io,'(a)')'      case (:-1); signum =    1'
write(io,'(a)')'      case (0);   signum = 0'
write(io,'(a)')'      case (1:);  signum = 1'
write(io,'(a)')'     end select'
write(io,'(a)')'   end function signum'
write(io,'(a)')'   !-------------------------------------------------------------------------------'
write(io,'(a)')'   function mine(xx) result(yy) ! note when RESULT used, function name has no type'
write(io,'(a)')'   implicit none'
write(io,'(a)')'   real :: xx'
write(io,'(a)')'   real :: yy'
write(io,'(a)')'     write(*,*)''VALUE='',xx'
write(io,'(a)')'     yy=xx'
write(io,'(a)')'   end function mine'
write(io,'(a)')'   !-------------------------------------------------------------------------------'
write(io,'(a)')'   subroutine usage()'
write(io,'(a)')'   character(len=80),allocatable :: help_text(:)'
write(io,'(a)')'   integer                       :: i'
write(io,'(a)')'     help_text=[ &'
write(io,'(a)')'     &''12345678901234567890123456789012345678901234567890123456789012345678901234567890'',&'
write(io,'(a)')'     &''This is example help text for the example program                               '',&'
write(io,'(a)')'     &''                                                                                '',&'
write(io,'(a)')'     &''                                                                                '',&'
write(io,'(a)')'     &''                                                                                '']'
write(io,'(a)')'     WRITE(*,''(a)'')(help_text(i),i=1,size(help_text))'
write(io,'(a)')'   end subroutine usage'
write(io,'(a)')'   !-------------------------------------------------------------------------------'
write(io,'(a)')'   end program demo_free_source_form'
write(io,'(a)')'   !-------------------------------------------------------------------------------'
write(io,'(a)')'NAME'
write(io,'(a)')'  DEALLOCATE(7f) - [FORTRAN:STATEMENT] causes allocated variables and targets to be deallocated'
write(io,'(a)')''
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'  DEALLOCATE(allocate-object-list [,STAT=stat-variable][,ERRMSG=errmsg-variable] )'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'  The DEALLOCATE statement causes allocatable variables to be deallocated;'
write(io,'(a)')'  it causes pointer targets to be deallocated and the pointers to be'
write(io,'(a)')'  disassociated.'
write(io,'(a)')''
write(io,'(a)')'  An allocate-object shall not depend on the value, bounds, allocation'
write(io,'(a)')'  status, or association status of another allocate-object in the same'
write(io,'(a)')'  DEALLOCATE statement; it also shall not depend on the value of the'
write(io,'(a)')'  stat-variable or errmsg-variable in the same DEALLOCATE statement.'
write(io,'(a)')''
write(io,'(a)')'  The status of objects that were not successfully allocated or'
write(io,'(a)')'  deallocated can be individually checked with the intrinsic functions'
write(io,'(a)')'  ALLOCATED or ASSOCIATED.'
write(io,'(a)')''
write(io,'(a)')'OPTIONS'
write(io,'(a)')''
write(io,'(a)')'    allocated-object-list    Each allocate-object is a nonprocedure'
write(io,'(a)')'                             pointer or an allocatable variable.'
write(io,'(a)')''
write(io,'(a)')'    STAT=stat-variable       If the STAT= specifier appears, successful'
write(io,'(a)')'                             execution of the ALLOCATE or DEALLOCATE'
write(io,'(a)')'                             statement causes the stat-variable'
write(io,'(a)')'                             to become defined with a value of zero.'
write(io,'(a)')''
write(io,'(a)')'                             If an error condition occurs during'
write(io,'(a)')'                             execution of a DEALLOCATE statement that'
write(io,'(a)')'                             does not contain the STAT= specifier, error'
write(io,'(a)')'                             termination is initiated.'
write(io,'(a)')''
write(io,'(a)')'    ERRMSG=errmsg-variable   If an error condition occurs during execution'
write(io,'(a)')'                             of an ALLOCATE or DEALLOCATE statement, the'
write(io,'(a)')'                             processor assigns an explanatory message to'
write(io,'(a)')'                             errmsg-variable. If no such condition occurs,'
write(io,'(a)')'                             the processor does not change the value of'
write(io,'(a)')'                             the errmsg-variable.'
write(io,'(a)')''
write(io,'(a)')'   No dealloc-opt shall appear more than once in a given DEALLOCATE statement'
write(io,'(a)')''
write(io,'(a)')'   The errmsg-variable and stat-variable cannot be allocated or'
write(io,'(a)')'   deallocated elsewhere in the statement or otherwise depend of any'
write(io,'(a)')'   allocatable object in the statement.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'   An example of a DEALLOCATE statement is:'
write(io,'(a)')''
write(io,'(a)')'         DEALLOCATE (X, B)'
write(io,'(a)')''
write(io,'(a)')'DEALLOCATION OF ALLOCATABLE VARIABLES'
write(io,'(a)')''
write(io,'(a)')'   Deallocating an unallocated allocatable variable causes an error'
write(io,'(a)')'   condition in the DEALLOCATE statement.  Deallocating an allocatable'
write(io,'(a)')'   variable with the TARGET attribute causes the pointer association'
write(io,'(a)')'   status of any pointer associated with it to become undefined.'
write(io,'(a)')''
write(io,'(a)')'   When the execution of a procedure is terminated by execution of a'
write(io,'(a)')'   RETURN or END statement, an unsaved allocatable local variable of'
write(io,'(a)')'   the procedure retains its allocation and definition status if it'
write(io,'(a)')'   is a function result variable or a subobject thereof; otherwise,'
write(io,'(a)')'   it is deallocated.'
write(io,'(a)')''
write(io,'(a)')'   When a BLOCK construct terminates, an unsaved allocatable local'
write(io,'(a)')'   variable of the construct is deallocated.'
write(io,'(a)')''
write(io,'(a)')'   If an executable construct references a function whose result is either'
write(io,'(a)')'   allocatable or a structure with a subobject that is allocatable,'
write(io,'(a)')'   and the function reference is executed, an allocatable result and'
write(io,'(a)')'   any subobject that is an allocated allocatable entity in the result'
write(io,'(a)')'   returned by the function is deallocated after execution of the'
write(io,'(a)')'   innermost executable construct containing the reference.'
write(io,'(a)')''
write(io,'(a)')'   If a function whose result is either allocatable or a structure with'
write(io,'(a)')'   an allocatable subobject is referenced in the specification part'
write(io,'(a)')'   of a scoping unit or BLOCK construct, and the function reference'
write(io,'(a)')'   is executed, an allocatable result and any subobject that is an'
write(io,'(a)')'   allocated allocatable entity in the result returned by the function'
write(io,'(a)')'   is deallocated before execution of the executable constructs of the'
write(io,'(a)')'   scoping unit or block.'
write(io,'(a)')''
write(io,'(a)')'   When a procedure is invoked, any allocated allocatable object that'
write(io,'(a)')'   is an actual argument corresponding to an INTENT (OUT) allocatable'
write(io,'(a)')'   dummy argument is deallocated; any allocated allocatable object that'
write(io,'(a)')'   is a subobject of an actual argument corresponding to an INTENT (OUT)'
write(io,'(a)')'   dummy argument is deallocated.'
write(io,'(a)')''
write(io,'(a)')'   When an intrinsic assignment statement (7.2.1.3) is executed,'
write(io,'(a)')'   any noncoarray allocated allocatable subobject of the variable is'
write(io,'(a)')'   deallocated before the assignment takes place.'
write(io,'(a)')''
write(io,'(a)')'   When a variable of derived type is deallocated, any allocated'
write(io,'(a)')'   allocatable subobject is deallocated.'
write(io,'(a)')''
write(io,'(a)')'   If an allocatable component is a subobject of a finalizable object,'
write(io,'(a)')'   that object is finalized before the component is automatically'
write(io,'(a)')'   deallocated.'
write(io,'(a)')''
write(io,'(a)')'   The effect of automatic deallocation is the same as that of a'
write(io,'(a)')'   DEALLOCATE statement without a dealloc-opt-list.'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'   There is implicit synchronization of all images in association with'
write(io,'(a)')'   each DEALLOCATE statement that deallocates one or more coarrays. On'
write(io,'(a)')'   each image, execution of the segment (8.5.1) following the statement'
write(io,'(a)')'   is delayed until all other images have executed the same statement'
write(io,'(a)')'   the same number of times. If the coarray is a dummy argument, its'
write(io,'(a)')'   ultimate argument (12.5.2.3) shall be the same coarray on every image.'
write(io,'(a)')''
write(io,'(a)')'   There is also an implicit synchronization of all images in association'
write(io,'(a)')'   with the deallocation of a coarray or coarray subcomponent caused by'
write(io,'(a)')'   the execution of a RETURN or END statement or the termination of a'
write(io,'(a)')'   BLOCK construct.'
write(io,'(a)')''
write(io,'(a)')'    In the following example:'
write(io,'(a)')''
write(io,'(a)')'       > SUBROUTINE PROCESS'
write(io,'(a)')'       >   REAL, ALLOCATABLE :: TEMP(:)'
write(io,'(a)')'       >'
write(io,'(a)')'       >   REAL, ALLOCATABLE, SAVE :: X(:)'
write(io,'(a)')'       >   ...'
write(io,'(a)')'       > END SUBROUTINE PROCESS'
write(io,'(a)')''
write(io,'(a)')'    on return from subroutine PROCESS, the allocation status of X is'
write(io,'(a)')'    preserved because X has the SAVE attribute. TEMP does not have the'
write(io,'(a)')'    SAVE attribute, so it will be deallocated if it was allocated. On'
write(io,'(a)')'    the next invocation of PROCESS, TEMP will have an allocation status'
write(io,'(a)')'    of unallocated.'
write(io,'(a)')''
write(io,'(a)')'DEALLOCATION OF POINTER TARGETS'
write(io,'(a)')''
write(io,'(a)')'   If a pointer appears in a DEALLOCATE statement, its association status'
write(io,'(a)')'   shall be defined. Deallocating a pointer'
write(io,'(a)')'    that is disassociated or whose target was not created by an ALLOCATE'
write(io,'(a)')'    statement causes an error condition in the DEALLOCATE statement. If a'
write(io,'(a)')'    pointer is associated with an allocatable entity, the pointer shall'
write(io,'(a)')'    not be deallocated.'
write(io,'(a)')''
write(io,'(a)')'   If a pointer appears in a DEALLOCATE statement, it shall be associated'
write(io,'(a)')'   with the whole of an object that was'
write(io,'(a)')'    created by allocation. Deallocating a pointer target causes the'
write(io,'(a)')'    pointer association status of any other pointer that is associated'
write(io,'(a)')'    with the target or a portion of the target to become undefined.'
write(io,'(a)')''
write(io,'(a)')'   If an ALLOCATE or DEALLOCATE statement with a coarray'
write(io,'(a)')'   allocate-object is executed when one or more images has initiated'
write(io,'(a)')'   termination of execution, the stat-variable becomes defined with the'
write(io,'(a)')'   processor-dependent positive integer value of the constant STAT STOPPED'
write(io,'(a)')'   IMAGE from the intrinsic module ISO_FORTRAN_ENV (13.8.2).  If any other'
write(io,'(a)')'   error condition occurs during execution of the ALLOCATE or DEALLOCATE'
write(io,'(a)')'   statement, the stat-variable becomes defined with a processor-dependent'
write(io,'(a)')'   positive integer value different from STAT STOPPED IMAGE. In either'
write(io,'(a)')'   case, each allocate-object has a processor-dependent status:'
write(io,'(a)')''
write(io,'(a)')'       * each allocate-object that was successfully allocated shall have'
write(io,'(a)')'         an allocation status of allocated or a pointer association'
write(io,'(a)')'         status of associated;'
write(io,'(a)')'       * each allocate-object that was successfully deallocated shall'
write(io,'(a)')'         have an allocation status of unallocated or a pointer association'
write(io,'(a)')'         status of disassociated;'
write(io,'(a)')'       * each allocate-object that was not successfully allocated or'
write(io,'(a)')'         deallocated shall retain its previous allocation status or'
write(io,'(a)')'         pointer association status.'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     ALLOCATED(3f) - [INTRINSIC:ARRAY INQUIRY] Status of an allocatable entity'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   * result = ALLOCATED(ARRAY)'
write(io,'(a)')'   * result = ALLOCATED(SCALAR)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   ALLOCATED(ARRAY) and ALLOCATED(SCALAR) check the allocation status of'
write(io,'(a)')'   ARRAY and SCALAR, respectively.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   ARRAY   - the argument shall be an ALLOCATABLE array.'
write(io,'(a)')'   SCALAR  - the argument shall be an ALLOCATABLE scalar.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is a scalar LOGICAL with the default logical'
write(io,'(a)')'   kind type parameter. If the argument is allocated then the result'
write(io,'(a)')'   is .true.; otherwise, it returns .false..'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_allocated'
write(io,'(a)')'      integer :: i = 4'
write(io,'(a)')'      real(4), allocatable :: x(:)'
write(io,'(a)')'      if (allocated(x) .eqv. .false.) allocate(x(i))'
write(io,'(a)')'    end program demo_allocated'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later. Note, the scalar= keyword and allocatable'
write(io,'(a)')'   scalar entities are available in Fortran 2003 and later.'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[move_alloc]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     anint(3f) - [INTRINSIC:NUMERIC] Nearest whole number'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = anint(a [, kind])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   anint(a [, kind]) rounds its argument to the nearest whole number.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   A     - the type of the argument shall be REAL.'
write(io,'(a)')'   KIND  - (optional) an INTEGER initialization expression'
write(io,'(a)')'           indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type real with the kind type parameter of the'
write(io,'(a)')'   argument if the optional KIND is absent; otherwise, the kind type'
write(io,'(a)')'   parameter will be given by KIND. If A is greater than zero,'
write(io,'(a)')'   anint(a) returns aint(x + 0.5). If A is less than or equal to'
write(io,'(a)')'   zero then it returns aint(x - 0.5).'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_anint'
write(io,'(a)')'      real(4) x4'
write(io,'(a)')'      real(8) x8'
write(io,'(a)')'      x4 = 1.234E0_4'
write(io,'(a)')'      x8 = 4.321_8'
write(io,'(a)')'      print *, anint(x4), dnint(x8)'
write(io,'(a)')'      x8 = anint(x4,8)'
write(io,'(a)')'    end program demo_anint'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     any(3f) - [INTRINSIC:TRANSFORMATIONAL FUNCTION] determines if any of the values in the logical array are true.'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = any(mask [, dim])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   ANY(MASK [, DIM]) determines if any of the values in the logical'
write(io,'(a)')'   array MASK along dimension DIM are .TRUE..'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   MASK  - the type of the argument shall be LOGICAL and'
write(io,'(a)')'           it shall not be scalar.'
write(io,'(a)')'   DIM   - (optional) DIM shall be a scalar integer with a value'
write(io,'(a)')'           that lies between one and the rank of MASK.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   ANY(MASK) returns a scalar value of type LOGICAL where the kind'
write(io,'(a)')'   type parameter is the same as the kind type parameter of MASK. If'
write(io,'(a)')'   DIM is present, then ANY(MASK, DIM) returns an array with the rank'
write(io,'(a)')'   of MASK minus 1. The shape is determined from the shape of MASK'
write(io,'(a)')'   where the DIM dimension is elided.'
write(io,'(a)')''
write(io,'(a)')'   1. ANY(MASK) is true if any element of MASK is true; otherwise, it'
write(io,'(a)')'      is false. It also is false if MASK has zero size.'
write(io,'(a)')''
write(io,'(a)')'   2. If the rank of MASK is one, then ANY(MASK, DIM) is equivalent'
write(io,'(a)')'      to ANY(MASK). If the rank is greater than one, then ANY(MASK,'
write(io,'(a)')'      DIM) is determined by applying ANY to the array sections.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_any'
write(io,'(a)')'      logical l'
write(io,'(a)')'      l = any((/.true., .true., .true./))'
write(io,'(a)')'      print *, l'
write(io,'(a)')'      call section'
write(io,'(a)')'      contains'
write(io,'(a)')'        subroutine section'
write(io,'(a)')'          integer a(2,3), b(2,3)'
write(io,'(a)')'          a = 1'
write(io,'(a)')'          b = 1'
write(io,'(a)')'          b(2,2) = 2'
write(io,'(a)')'          print *, any(a .eq. b, 1)'
write(io,'(a)')'          print *, any(a .eq. b, 2)'
write(io,'(a)')'        end subroutine section'
write(io,'(a)')'    end program demo_any'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     asin(3f) - [INTRINSIC:TRIGONOMETRIC] Arcsine function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = asin(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   asin(x) computes the arcsine of its X (inverse of sin(x)).'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type shall be either REAL and a magnitude that is less'
write(io,'(a)')'        than or equal to one or be COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of the same type and kind as X.'
write(io,'(a)')'   The real part of the result is in radians and lies in the'
write(io,'(a)')'   range -PI/2 <= asin(x) <= PI/2.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_asin'
write(io,'(a)')'      real(8) :: x = 0.866_8'
write(io,'(a)')'      x = asin(x)'
write(io,'(a)')'    end program demo_asin'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later, for a complex argument [[Fortran 2008]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   Inverse function: [[sin]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     asinh(3f) - [INTRINSIC:TRIGONOMETRIC] Inverse hyperbolic sine function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'    result = asinh(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   asinh(x) computes the inverse hyperbolic sine of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type shall be REAL or COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of the same type and kind as X. If X is complex,'
write(io,'(a)')'   the imaginary part of the result is in radians and lies between -PI/2'
write(io,'(a)')'   <= AIMAG(ASINH(X)) <= PI/2.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_asinh'
write(io,'(a)')'     real(8), dimension(3) :: x = (/ -1.0, 0.0, 1.0 /)'
write(io,'(a)')'     write (*,*) asinh(x)'
write(io,'(a)')'   end program demo_asinh'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'Inverse function: [[sinh]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     associated(3f) - [INTRINSIC] Status of a pointer or pointer/target pair'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = associated(pointer [, target])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   associated(pointer [, target]) determines the status of the pointer'
write(io,'(a)')'   POINTER or if POINTER is associated with the target TARGET.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   POINTER  - POINTER shall have the POINTER attribute'
write(io,'(a)')'              and it can be of any type.'
write(io,'(a)')'   TARGET   - (Optional) TARGET shall be a pointer or'
write(io,'(a)')'              a target. It must have the same type, kind type parameter, and'
write(io,'(a)')'              array rank as POINTER.'
write(io,'(a)')''
write(io,'(a)')'   The association status of neither POINTER nor TARGET shall be'
write(io,'(a)')'   undefined.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')' associated(pointer) returns a scalar value of type logical(4). There are'
write(io,'(a)')' several cases:'
write(io,'(a)')''
write(io,'(a)')' 1. When the optional TARGET is not present then'
write(io,'(a)')'    associated(pointer) is true if POINTER is associated with a'
write(io,'(a)')'    target; otherwise, it returns false.'
write(io,'(a)')''
write(io,'(a)')' 2. If TARGET is present and a scalar target, the result is true if'
write(io,'(a)')'    TARGET is not a zero-sized storage sequence and the target'
write(io,'(a)')'    associated with POINTER occupies the same storage units. If'
write(io,'(a)')'    POINTER is disassociated, the result is false.'
write(io,'(a)')''
write(io,'(a)')' 3. If TARGET is present and an array target, the result is true if'
write(io,'(a)')'    TARGET and POINTER have the same shape, are not zero-sized'
write(io,'(a)')'    arrays, are arrays whose elements are not zero-sized storage'
write(io,'(a)')'    sequences, and TARGET and POINTER occupy the same storage'
write(io,'(a)')'    units in array element order.'
write(io,'(a)')''
write(io,'(a)')'    As in case 2, the result is false, if POINTER is disassociated.'
write(io,'(a)')''
write(io,'(a)')' 4. If TARGET is present and an scalar pointer, the result is true'
write(io,'(a)')'    if TARGET is associated with POINTER, the target associated'
write(io,'(a)')'    with TARGET are not zero-sized storage sequences and occupy the'
write(io,'(a)')'    same storage units.'
write(io,'(a)')''
write(io,'(a)')'    The result is false, if either TARGET or POINTER is'
write(io,'(a)')'    disassociated.'
write(io,'(a)')''
write(io,'(a)')' 5. If TARGET is present and an array pointer, the result is true if'
write(io,'(a)')'    target associated with POINTER and the target associated with'
write(io,'(a)')'    TARGET have the same shape, are not zero-sized arrays, are'
write(io,'(a)')'    arrays whose elements are not zero-sized storage sequences, and'
write(io,'(a)')'    TARGET and POINTER occupy the same storage units in array'
write(io,'(a)')'    element order. The result is false, if either TARGET or'
write(io,'(a)')'    POINTER is disassociated.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_associated'
write(io,'(a)')'       implicit none'
write(io,'(a)')'       real, target  :: tgt(2) = (/1., 2./)'
write(io,'(a)')'       real, pointer :: ptr(:)'
write(io,'(a)')'       ptr => tgt'
write(io,'(a)')'       if (associated(ptr)     .eqv. .false.) call abort'
write(io,'(a)')'       if (associated(ptr,tgt) .eqv. .false.) call abort'
write(io,'(a)')'    end program demo_associated'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[null]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     atan(3f) - [INTRINSIC:TRIGONOMETRIC] Arctangent function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   * result = atan(x)'
write(io,'(a)')'   * result = atan(y, x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   atan(x) computes the arctangent of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  X  - The type shall be REAL or COMPLEX; if Y is present, X'
write(io,'(a)')'       shall be REAL.'
write(io,'(a)')'  Y  - Shall be of the same type and kind as X.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of the same type and kind as X.'
write(io,'(a)')'   If Y is present, the result is identical to atan2(y,x).'
write(io,'(a)')'   Otherwise, it the arcus tangent of X, where the real part of'
write(io,'(a)')'   the result is in radians and lies in the range'
write(io,'(a)')''
write(io,'(a)')'   -PI/2 <= atan(x) <= PI/2.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_atan'
write(io,'(a)')'     real(8) :: x = 2.866_8'
write(io,'(a)')'     x = atan(x)'
write(io,'(a)')'   end program demo_atan'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later; for a complex argument and for two arguments [[Fortran 2008]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[atan2]], [[tan]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     atan2(3f) - [INTRINSIC:TRIGONOMETRIC] Arctangent function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = atan2(y, x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   atan2(y, x) computes the arctangent of the complex number'
write(io,'(a)')''
write(io,'(a)')'      X + i Y.'
write(io,'(a)')''
write(io,'(a)')'   This function can be used to transform from Cartesian into polar'
write(io,'(a)')'   coordinates and allows to determine the angle in the correct quadrant.'
write(io,'(a)')'   To convert from Cartesian Coordinates (x,y) to polar coordinates'
write(io,'(a)')''
write(io,'(a)')'   (r,theta):'
write(io,'(a)')'   $$'
write(io,'(a)')'   \begin{aligned}'
write(io,'(a)')'   r &= \sqrt{x**2 + y**2} \\'
write(io,'(a)')'   \theta &= \tan**{-1}(y / x)'
write(io,'(a)')'   \end{aligned}'
write(io,'(a)')'   $$'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   Y  - The type shall be REAL.'
write(io,'(a)')'   X  - The type and kind type parameter shall be the same as Y.'
write(io,'(a)')'If Y is zero, then X must be nonzero.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value has the same type and kind type parameter as Y.'
write(io,'(a)')'   It is the principal value of the complex number (X + i, Y). If'
write(io,'(a)')'   X is nonzero, then it lies in the range -PI <= atan(x) <= PI.'
write(io,'(a)')'   The sign is positive if Y is positive. If Y is zero, then'
write(io,'(a)')'   the return value is zero if X is strictly positive, PI if'
write(io,'(a)')'   X is negative and Y is positive zero (or the processor does'
write(io,'(a)')'   not handle signed zeros), and -PI if X is negative and'
write(io,'(a)')'   Y is negative zero. Finally, if X is zero, then the'
write(io,'(a)')'   magnitude of the result is PI/2.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_atan2'
write(io,'(a)')'     real(4) :: x = 1.e0_4, y = 0.5e0_4'
write(io,'(a)')'     x = atan2(y,x)'
write(io,'(a)')'   end program demo_atan2'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     atanh(3f) - [INTRINSIC:TRIGONOMETRIC] Inverse hyperbolic tangent function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = atanh(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   atanh(x) computes the inverse hyperbolic tangent of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type shall be REAL or COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value has same type and kind as X. If X is'
write(io,'(a)')'   complex, the imaginary part of the result is in radians and lies between'
write(io,'(a)')''
write(io,'(a)')'   -PI/2 <= AIMAG(ATANH(X)) <= PI/2.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_atanh'
write(io,'(a)')'      real, dimension(3) :: x = (/ -1.0, 0.0, 1.0 /)'
write(io,'(a)')'      write (*,*) atanh(x)'
write(io,'(a)')'    end program demo_atanh'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'Inverse function: [[tanh]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'    pointers(7f) - [FORTRAN] Pointers and targets methods'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   In Fortran, the concept of pointers differs from that in C-like'
write(io,'(a)')'   languages. A Fortran 90 pointer does not merely store the memory address'
write(io,'(a)')'   of a target variable; it also contains additional descriptive information'
write(io,'(a)')'   such as the target''s rank, the upper and lower bounds of each dimension,'
write(io,'(a)')'   and even strides through memory. This allows a Fortran 90 pointer to'
write(io,'(a)')'   point at submatrices.'
write(io,'(a)')''
write(io,'(a)')'   Fortran 90 pointers are "associated" with well-defined "target"'
write(io,'(a)')'   variables, via either the pointer assignment operator (=>) or an'
write(io,'(a)')'   ALLOCATE statement. When appearing in expressions, pointers are always'
write(io,'(a)')'   dereferenced; no "pointer arithmetic" is possible.'
write(io,'(a)')'EXAMPLES'
write(io,'(a)')''
write(io,'(a)')'  The following example illustrates the concept:'
write(io,'(a)')''
write(io,'(a)')'   module SomeModule'
write(io,'(a)')'      implicit none'
write(io,'(a)')'    contains'
write(io,'(a)')'       elemental function A(x) result(res)'
write(io,'(a)')'           integer :: res'
write(io,'(a)')'           integer, intent(IN) :: x'
write(io,'(a)')'           res = x + 1'
write(io,'(a)')'       end function'
write(io,'(a)')'   end module SomeModule'
write(io,'(a)')''
write(io,'(a)')'   program demo_pointers'
write(io,'(a)')'      use SomeModule, DoSomething => A'
write(io,'(a)')'      implicit none'
write(io,'(a)')''
write(io,'(a)')'      !Declare variables'
write(io,'(a)')'      integer, parameter :: m = 3, n = 3'
write(io,'(a)')'      integer, pointer :: p(:)=>null(), q(:,:)=>null()'
write(io,'(a)')'      integer, allocatable, target :: A(:,:)'
write(io,'(a)')'      integer :: istat = 0, i, j'
write(io,'(a)')'      character(80) :: fmt'
write(io,'(a)')''
write(io,'(a)')'   !  Write format string for matrices'
write(io,'(a)')'   !  (/ A / A, " = [", 3( "[",3(i2, 1x), "]" / 5x), "]" )'
write(io,'(a)')'      write (fmt, ''("(/ A / A, "" = ["", ", i0, "( ""["",", i0, "(i2, 1x), ""]"" / 5x), ""]"" )")'') m, n'
write(io,'(a)')''
write(io,'(a)')'      allocate(A(m, n), q(m, n), stat = istat)'
write(io,'(a)')'      if (istat /= 0) stop ''Error during allocation of A and q'''
write(io,'(a)')''
write(io,'(a)')'   !  Matrix A is:'
write(io,'(a)')'   !  A = [[ 1  4  7 ]'
write(io,'(a)')'   !       [ 2  5  8 ]'
write(io,'(a)')'   !       [ 3  6  9 ]'
write(io,'(a)')'   !       ]'
write(io,'(a)')'      A = reshape([(i, i = 1, size(A))], shape(A))'
write(io,'(a)')'      q = A'
write(io,'(a)')''
write(io,'(a)')'      write(*, fmt) "Matrix A is:", "A", ((A(i, j), j = 1, size(A, 2)), i = 1, size(A, 1))'
write(io,'(a)')''
write(io,'(a)')'   !  p will be associated with the first column of A'
write(io,'(a)')'      p => A(:, 1)'
write(io,'(a)')''
write(io,'(a)')'   !  This operation on p has a direct effect on matrix A'
write(io,'(a)')'      p = p ** 2'
write(io,'(a)')''
write(io,'(a)')'   !  This will end the association between p and the first column of A'
write(io,'(a)')'      nullify(p)'
write(io,'(a)')''
write(io,'(a)')'   !  Matrix A becomes:'
write(io,'(a)')'   !  A = [[ 1  4  7 ]'
write(io,'(a)')'   !       [ 4  5  8 ]'
write(io,'(a)')'   !       [ 9  6  9 ]'
write(io,'(a)')'   !       ]'
write(io,'(a)')'      write(*, fmt) "Matrix A becomes:", "A", ((A(i, j), j = 1, size(A, 2)), i = 1, size(A, 1))'
write(io,'(a)')''
write(io,'(a)')'   !  Perform some array operation'
write(io,'(a)')'      q = q + A'
write(io,'(a)')''
write(io,'(a)')'   !  Matrix q becomes:'
write(io,'(a)')'   !  q = [[ 2  8 14 ]'
write(io,'(a)')'   !       [ 6 10 16 ]'
write(io,'(a)')'   !       [12 12 18 ]'
write(io,'(a)')'   !       ]'
write(io,'(a)')'      write(*, fmt) "Matrix q becomes:", "q", ((q(i, j), j = 1, size(A, 2)), i = 1, size(A, 1))'
write(io,'(a)')''
write(io,'(a)')'   !  Use p as an ordinary array'
write(io,'(a)')'      allocate (p(1:m*n), stat = istat)'
write(io,'(a)')'      if (istat /= 0) stop ''Error during allocation of p'''
write(io,'(a)')''
write(io,'(a)')'   !  Perform some array operation'
write(io,'(a)')'      p = reshape(DoSomething(A + A ** 2), shape(p))'
write(io,'(a)')''
write(io,'(a)')'   !  Array operation:'
write(io,'(a)')'   !      p(1) = 3'
write(io,'(a)')'   !      p(2) = 21'
write(io,'(a)')'   !      p(3) = 91'
write(io,'(a)')'   !      p(4) = 21'
write(io,'(a)')'   !      p(5) = 31'
write(io,'(a)')'   !      p(6) = 43'
write(io,'(a)')'   !      p(7) = 57'
write(io,'(a)')'   !      p(8) = 73'
write(io,'(a)')'   !      p(9) = 91'
write(io,'(a)')'      write(*, ''("Array operation:" / (4x,"p(",i0,") = ",i0))'') (i, p(i), i = 1, size(p))'
write(io,'(a)')''
write(io,'(a)')'      deallocate(A, p, q, stat = istat)'
write(io,'(a)')'      if (istat /= 0) stop ''Error during deallocation'''
write(io,'(a)')''
write(io,'(a)')'   end program demo_pointers'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     atomic_add(3f) - [INTRINSIC] Atomic ADD operation'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   call atomic_add (atom, value [, stat])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   atomic_add(atom, value) atomically adds the value of VAR to the'
write(io,'(a)')'   variable ATOM. When STAT is present and the invocation was'
write(io,'(a)')'   successful, it is assigned the value 0. If it is present and the'
write(io,'(a)')'   invocation has failed, it is assigned a positive value; in particular,'
write(io,'(a)')'   for a coindexed ATOM, if the remote image has stopped, it is'
write(io,'(a)')'   assigned the value of iso_fortran_env''s stat_stopped_image and if'
write(io,'(a)')'   the remote image has failed, the value stat_failed_image.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  ATOM   - Scalar coarray or coindexed variable of integer'
write(io,'(a)')'  type with atomic_int_kind kind.'
write(io,'(a)')'  VALUE  - Scalar of the same type as ATOM. If the kind'
write(io,'(a)')'  is different, the value is converted to the kind of ATOM.'
write(io,'(a)')'  STAT   - (optional) Scalar default-kind integer variable.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_atomic_add'
write(io,'(a)')'     use iso_fortran_env'
write(io,'(a)')'     integer(atomic_int_kind) :: atom[*]'
write(io,'(a)')'     call atomic_add (atom[1], this_image())'
write(io,'(a)')'   end program demo_atomic_add'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[TS 18508]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'Atomic subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[atomic_define]], [[atomic_fetch_add]], [[iso_fortran_env]],'
write(io,'(a)')'   [[atomic_and]], [[atomic_or]], [[atomic_xor]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     atomic_and(3f) - [INTRINSIC:ATOMIC:BIT MANIPULATION] Atomic bitwise AND operation'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'call atomic_and(atom, value [, stat])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   atomic_and(atom, value) atomically defines ATOM with the bitwise'
write(io,'(a)')'   AND between the values of ATOM and VALUE. When STAT is present'
write(io,'(a)')'   and the invocation was successful, it is assigned the value 0. If it'
write(io,'(a)')'   is present and the invocation has failed, it is assigned a positive'
write(io,'(a)')'   value; in particular, for a coindexed ATOM, if the remote image has'
write(io,'(a)')'   stopped, it is assigned the value of iso_fortran_env''s'
write(io,'(a)')'   stat_stopped_image and if the remote image has failed, the value'
write(io,'(a)')'   stat_failed_image.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  ATOM  - Scalar coarray or coindexed variable of integer type with'
write(io,'(a)')'          atomic_int_kind kind.'
write(io,'(a)')'  VALUE  - Scalar of the same type as ATOM. If the kind is'
write(io,'(a)')'           different, the value is converted to the kind of ATOM.'
write(io,'(a)')'  STAT  - (optional) Scalar default-kind integer variable.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_atomic_and'
write(io,'(a)')'     use iso_fortran_env'
write(io,'(a)')'     integer(atomic_int_kind) :: atom[*]'
write(io,'(a)')'     call atomic_and(atom[1], int(b''10100011101''))'
write(io,'(a)')'   end program demo_atomic_and'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[TS 18508]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'Atomic subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[atomic_define]], [[atomic_fetch_and]], [[iso_fortran_env]],'
write(io,'(a)')'   [[atomic_add]], [[atomic_or]], [[atomic_xor]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     atomic_cas(3f) - [INTRINSIC] Atomic compare and swap'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   call atomic_cas (atom, old, compare, new [, stat])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   atomic_cas compares the variable ATOM with the value of COMPARE;'
write(io,'(a)')'   if the value is the same, ATOM is set to the value of'
write(io,'(a)')'   NEW. Additionally, OLD is set to the value of ATOM that was used'
write(io,'(a)')'   for the comparison. When STAT is present and the invocation was'
write(io,'(a)')'   successful, it is assigned the value 0. If it is present and the'
write(io,'(a)')'   invocation has failed, it is assigned a positive value; in particular,'
write(io,'(a)')'   for a coindexed ATOM, if the remote image has stopped, it is'
write(io,'(a)')'   assigned the value of iso_fortran_env''s stat_stopped_image and if'
write(io,'(a)')'   the remote image has failed, the value stat_failed_image.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  ATOM     - Scalar coarray or coindexed variable of either integer type'
write(io,'(a)')'             with atomic_int_kind kind or logical type with'
write(io,'(a)')'             atomic_logical_kind kind.'
write(io,'(a)')'  OLD      - Scalar of the same type and kind as ATOM.'
write(io,'(a)')'  COMPARE  - Scalar variable of the same type and kind as ATOM.'
write(io,'(a)')'  NEW      - Scalar variable of the same type as ATOM. If kind is'
write(io,'(a)')'             different, the value is converted to the kind of ATOM.'
write(io,'(a)')'  STAT     - (optional) Scalar default-kind integer variable.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_atomic_cas'
write(io,'(a)')'     use iso_fortran_env'
write(io,'(a)')'     logical(atomic_logical_kind) :: atom[*], prev'
write(io,'(a)')'     call atomic_cas(atom[1], prev, .false., .true.))'
write(io,'(a)')'   end program demo_atomic_cas'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[TS 18508]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'Atomic subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[atomic_define]], [[atomic_ref]], [[iso_fortran_env]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     atomic_define(3f) - [INTRINSIC] Setting a variable atomically'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   call atomic_define (atom, value [, stat])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   atomic_define(atom, value) defines the variable ATOM with the'
write(io,'(a)')'   value VALUE atomically. When STAT is present and the invocation'
write(io,'(a)')'   was successful, it is assigned the value 0. If it is present and the'
write(io,'(a)')'   invocation has failed, it is assigned a positive value; in particular,'
write(io,'(a)')'   for a coindexed ATOM, if the remote image has stopped, it is'
write(io,'(a)')'   assigned the value of iso_fortran_env''s stat_stopped_image and if'
write(io,'(a)')'   the remote image has failed, the value stat_failed_image.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  ATOM   - Scalar coarray or coindexed variable of either integer type'
write(io,'(a)')'           with atomic_int_kind kind or logical type with'
write(io,'(a)')'           atomic_logical_kind kind.'
write(io,'(a)')'  VALUE  - Scalar of the same type as ATOM. If the kind is'
write(io,'(a)')'           different, the value is converted to the kind of ATOM.'
write(io,'(a)')'  STAT   - (optional) Scalar default-kind integer variable.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_atomic_define'
write(io,'(a)')'     use iso_fortran_env'
write(io,'(a)')'     integer(atomic_int_kind) :: atom[*]'
write(io,'(a)')'     call atomic_define(atom[1], this_image())'
write(io,'(a)')'   end program demo_atomic_define'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later; with STAT, [[TS 18508]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Atomic subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[atomic_ref]], [[atomic_cas]], [[iso_fortran_env]],'
write(io,'(a)')'   [[atomic_add]], [[atomic_and]], [[atomic_or]], [[atomic_xor]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     atomic_fetch_add(3f) - [INTRINSIC] Atomic ADD operation with prior fetch'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'call atomic_fetch_add(atom, value, old [, stat])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   atomic_fetch_add(atom, value, old) atomically stores the value of'
write(io,'(a)')'   ATOM in OLD and adds the value of VAR to the variable'
write(io,'(a)')'   ATOM. When STAT is present and the invocation was successful, it'
write(io,'(a)')'   is assigned the value 0. If it is present and the invocation has'
write(io,'(a)')'   failed, it is assigned a positive value; in particular, for a'
write(io,'(a)')'   coindexed ATOM, if the remote image has stopped, it is assigned the'
write(io,'(a)')'   value of iso_fortran_env''s stat_stopped_image and if the remote'
write(io,'(a)')'   image has failed, the value stat_failed_image.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  ATOM  - Scalar coarray or coindexed variable of integer type with'
write(io,'(a)')'          atomic_int_kind kind. atomic_logical_kind kind.'
write(io,'(a)')'  VALUE  - Scalar of the same type as ATOM. If the kind is'
write(io,'(a)')'           different, the value is converted to the kind of ATOM.'
write(io,'(a)')'  OLD    - Scalar of the same type and kind as ATOM.'
write(io,'(a)')'  STAT   - (optional) Scalar default-kind integer variable.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_atomic_fetch_add'
write(io,'(a)')'     use iso_fortran_env'
write(io,'(a)')'     integer(atomic_int_kind) :: atom[*], old'
write(io,'(a)')'     call atomic_add(atom[1], this_image(), old)'
write(io,'(a)')'   end program demo_atomic_fetch_add'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[TS 18508]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'Atomic subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[atomic_define]], [[atomic_add]], [[iso_fortran_env]],'
write(io,'(a)')'   [[atomic_fetch_and]], [[atomic_fetch_or]], [[atomic_fetch_xor]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     atomic_fetch_and(3f) - [INTRINSIC:ATOMIC:BIT MANIPULATION] Atomic bitwise AND operation with prior fetch'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'call atomic_fetch_and(atom, value, old [, stat])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   atomic_fetch_and(atom, value, old) atomically stores the value of'
write(io,'(a)')'   ATOM in OLD and defines ATOM with the bitwise AND between the'
write(io,'(a)')'   values of ATOM and VALUE. When STAT is present and the'
write(io,'(a)')'   invocation was successful, it is assigned the value 0. If it is'
write(io,'(a)')'   present and the invocation has failed, it is assigned a positive'
write(io,'(a)')'   value; in particular, for a coindexed ATOM, if the remote image has'
write(io,'(a)')'   stopped, it is assigned the value of iso_fortran_env''s'
write(io,'(a)')'   stat_stopped_image and if the remote image has failed, the value'
write(io,'(a)')'   stat_failed_image.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  ATOM  - Scalar coarray or coindexed variable of integer type with'
write(io,'(a)')'          atomic_int_kind kind.'
write(io,'(a)')'  VALUE  - Scalar of the same type as ATOM. If the kind is'
write(io,'(a)')'           different, the value is converted to the kind of ATOM.'
write(io,'(a)')'  OLD    - Scalar of the same type and kind as ATOM.'
write(io,'(a)')'  STAT   - (optional) Scalar default-kind integer variable.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_atomic_fetch_and'
write(io,'(a)')'     use iso_fortran_env'
write(io,'(a)')'     integer(atomic_int_kind) :: atom[*], old'
write(io,'(a)')'     call atomic_fetch_and (atom[1], int(b''10100011101''), old)'
write(io,'(a)')'   end program demo_atomic_fetch_and'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[TS 18508]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'Atomic subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[atomic_define]], [[atomic_and]], [[iso_fortran_env]],'
write(io,'(a)')'   [[atomic_fetch_add]], [[atomic_fetch_or]], [[atomic_fetch_xor]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     atomic_fetch_or(3f) - [INTRINSIC:ATOMIC:BIT MANIPULATION] Atomic bitwise OR operation with prior fetch'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'call atomic_fetch_or(atom, value, old [, stat])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   atomic_fetch_or(atom, value, old) atomically stores the value of ATOM in'
write(io,'(a)')'   OLD and defines ATOM with the bitwise OR between the values of'
write(io,'(a)')'   ATOM and VALUE. When STAT is present and the invocation was'
write(io,'(a)')'   successful, it is assigned the value 0. If it is present and the invocation has'
write(io,'(a)')'   failed, it is assigned a positive value; in particular, for a coindexed'
write(io,'(a)')'   ATOM, if the remote image has stopped, it is assigned the value of'
write(io,'(a)')'   iso_fortran_env''s stat_stopped_image and if the remote image has'
write(io,'(a)')'   failed, the value stat_failed_image.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  ATOM   - Scalar coarray or coindexed variable of integer'
write(io,'(a)')'           type with atomic_int_kind kind.'
write(io,'(a)')'  VALUE  - Scalar of the same type as ATOM. If the kind'
write(io,'(a)')'           is different, the value is converted to the kind of ATOM.'
write(io,'(a)')'  OLD    - Scalar of the same type and kind as ATOM.'
write(io,'(a)')'  STAT   - (optional) Scalar default-kind integer variable.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_atomic_fetch_or'
write(io,'(a)')'     use iso_fortran_env'
write(io,'(a)')'     integer(atomic_int_kind) :: atom[*], old'
write(io,'(a)')'     call atomic_fetch_or(atom[1], int(b''10100011101''), old)'
write(io,'(a)')'   end program demo_atomic_fetch_or'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[TS 18508]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'Atomic subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[atomic_define]], [[atomic_or]], [[iso_fortran_env]],'
write(io,'(a)')'   [[atomic_fetch_add]], [[atomic_fetch_and]], [[atomic_fetch_xor]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     atomic_fetch_xor(3f) - [INTRINSIC:ATOMIC:BIT MANIPULATION] Atomic bitwise XOR operation with prior fetch'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'call atomic_fetch_xor (atom, value, old [, stat])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   atomic_fetch_xor(atom, value, old) atomically stores the value of'
write(io,'(a)')'   ATOM in OLD and defines ATOM with the bitwise XOR between the'
write(io,'(a)')'   values of ATOM and VALUE. When STAT is present and the'
write(io,'(a)')'   invocation was successful, it is assigned the value 0. If it is'
write(io,'(a)')'   present and the invocation has failed, it is assigned a positive'
write(io,'(a)')'   value; in particular, for a coindexed ATOM, if the remote image has'
write(io,'(a)')'   stopped, it is assigned the value of iso_fortran_env''s'
write(io,'(a)')'   stat_stopped_image and if the remote image has failed, the value'
write(io,'(a)')'   stat_failed_image.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  ATOM   - Scalar coarray or coindexed variable of integer'
write(io,'(a)')'           type with atomic_int_kind kind.'
write(io,'(a)')'  VALUE  - Scalar of the same type as ATOM. If the kind'
write(io,'(a)')'           is different, the value is converted to the kind of ATOM.'
write(io,'(a)')'  OLD    - Scalar of the same type and kind as ATOM.'
write(io,'(a)')'  STAT   - (optional) Scalar default-kind integer variable.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_atomic_fetch_xor'
write(io,'(a)')'     use iso_fortran_env'
write(io,'(a)')'     integer(atomic_int_kind) :: atom[*], old'
write(io,'(a)')'     call atomic_fetch_xor (atom[1], int(b''10100011101''), old)'
write(io,'(a)')'   end program demo_atomic_fetch_xor'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[TS 18508]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'Atomic subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[atomic_define]], [[atomic_xor]], [[iso_fortran_env]],'
write(io,'(a)')'   [[atomic_fetch_add]], [[atomic_fetch_and]], [[atomic_fetch_or]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     atomic_or(3f) - [INTRINSIC:ATOMIC:BIT MANIPULATION] Atomic bitwise OR operation'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'call atomic_or(atom, value [, stat])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   atomic_or(atom, value) atomically defines ATOM with the bitwise'
write(io,'(a)')'   OR between the values of ATOM and VALUE. When STAT is present'
write(io,'(a)')'   and the invocation was successful, it is assigned the value 0. If it'
write(io,'(a)')'   is present and the invocation has failed, it is assigned a positive'
write(io,'(a)')'   value; in particular, for a coindexed ATOM, if the remote image has'
write(io,'(a)')'   stopped, it is assigned the value of iso_fortran_env''s'
write(io,'(a)')'   stat_stopped_image and if the remote image has failed, the value'
write(io,'(a)')'   stat_failed_image.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  ATOM   - Scalar coarray or coindexed variable of integer'
write(io,'(a)')'           type with atomic_int_kind kind.'
write(io,'(a)')'  VALUE  - Scalar of the same type as ATOM. If the kind'
write(io,'(a)')'           is different, the value is converted to the kind of ATOM.'
write(io,'(a)')'  STAT   - (optional) Scalar default-kind integer variable.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_atomic_or'
write(io,'(a)')'     use iso_fortran_env'
write(io,'(a)')'     integer(atomic_int_kind) :: atom[*]'
write(io,'(a)')'     call atomic_or(atom[1], int(b''10100011101''))'
write(io,'(a)')'   end program demo_atomic_or'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[TS 18508]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'Atomic subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[atomic_define]], [[atomic_fetch_or]], [[iso_fortran_env]],'
write(io,'(a)')'   [[atomic_add]], [[atomic_or]], [[atomic_xor]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     atomic_ref(3f) - [INTRINSIC] Obtaining the value of a variable atomically'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   call atomic_ref(value, atom [, stat])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   atomic_ref(atom, value) atomically assigns the value of the variable'
write(io,'(a)')'   ATOM to VALUE. When STAT is present and the invocation was'
write(io,'(a)')'   successful, it is assigned the value 0. If it is present and the'
write(io,'(a)')'   invocation has failed, it is assigned a positive value; in particular,'
write(io,'(a)')'   for a coindexed ATOM, if the remote image has stopped, it is'
write(io,'(a)')'   assigned the value of iso_fortran_env''s stat_stopped_image and if'
write(io,'(a)')'   the remote image has failed, the value stat_failed_image.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  VALUE  - Scalar of the same type as ATOM. If the kind'
write(io,'(a)')'           is different, the value is converted to the kind of ATOM.'
write(io,'(a)')'  ATOM  - Scalar coarray or coindexed variable of either integer type'
write(io,'(a)')'          with atomic_int_kind kind or logical type with'
write(io,'(a)')'          atomic_logical_kind kind.'
write(io,'(a)')'  STAT   - (optional) Scalar default-kind integer variable.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_atomic_ref'
write(io,'(a)')'     use iso_fortran_env'
write(io,'(a)')'     logical(atomic_logical_kind) :: atom[*]'
write(io,'(a)')'     logical :: val'
write(io,'(a)')'     call atomic_ref(atom, .false.)'
write(io,'(a)')'     ! ...'
write(io,'(a)')'     call atomic_ref(atom, val)'
write(io,'(a)')'     if (val) then'
write(io,'(a)')'       print *, "Obtained"'
write(io,'(a)')'     end if'
write(io,'(a)')'   end program demo_atomic_ref'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later; with STAT, [[TS 18508]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'Atomic subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[atomic_define]], [[atomic_cas]], [[iso_fortran_env]],'
write(io,'(a)')'   [[atomic_fetch_add]], [[atomic_fetch_and]], [[atomic_fetch_or]],'
write(io,'(a)')'   [[atomic_fetch_xor]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     atomic_xor(3f) - [INTRINSIC:ATOMIC:BIT MANIPULATION] Atomic bitwise OR operation'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'call atomic_xor(atom, value [, stat])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   atomic_xor(atom, value) atomically defines ATOM with the bitwise'
write(io,'(a)')'   XOR between the values of ATOM and VALUE. When STAT is present'
write(io,'(a)')'   and the invocation was successful, it is assigned the value 0. If it'
write(io,'(a)')'   is present and the invocation has failed, it is assigned a positive'
write(io,'(a)')'   value; in particular, for a coindexed ATOM, if the remote image has'
write(io,'(a)')'   stopped, it is assigned the value of iso_fortran_env''s'
write(io,'(a)')'   stat_stopped_image and if the remote image has failed, the value'
write(io,'(a)')'   stat_failed_image.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  ATOM  - Scalar coarray or coindexed variable of integer type with'
write(io,'(a)')'          atomic_int_kind kind.'
write(io,'(a)')'  VALUE  - Scalar of the same type as ATOM. If the kind is'
write(io,'(a)')'           different, the value is converted to the kind of ATOM.'
write(io,'(a)')'  STAT   - (optional) Scalar default-kind integer variable.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_atomic_xor'
write(io,'(a)')'     use iso_fortran_env'
write(io,'(a)')'     integer(atomic_int_kind) :: atom[*]'
write(io,'(a)')'     call atomic_xor(atom[1], int(b''10100011101''))'
write(io,'(a)')'   end program demo_atomic_xor'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[TS 18508]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'Atomic subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[atomic_define]], [[atomic_fetch_xor]], [[iso_fortran_env]],'
write(io,'(a)')'   [[atomic_add]], [[atomic_or]], [[atomic_xor]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     bessel_j0(3f) - [INTRINSIC:MATHEMATICS] Bessel function of the first kind of order 0'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = bessel_j0(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   bessel_j0(x) computes the [[Bessel function]] of the first kind of'
write(io,'(a)')'   order 0 of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  X  - The type shall be REAL.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type REAL and lies in the range -0.4027 <= Bessel(0,x) <= 1.'
write(io,'(a)')'   It has the same kind as X.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_besj0'
write(io,'(a)')'     real(8) :: x = 0.0_8'
write(io,'(a)')'     x = bessel_j0(x)'
write(io,'(a)')'   end program demo_besj0'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[bessel_j1]], [[bessel_jn]], [[bessel_y0]], [[bessel_y1]], [[bessel_yn]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     bessel_j1(3f) - [INTRINSIC:MATHEMATICS] Bessel function of the first kind of order 1'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = bessel_j1(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   bessel_j1(x) computes the [[Bessel function]] of the first kind of'
write(io,'(a)')'   order 1 of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  X  - The type shall be REAL.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type REAL and lies in the'
write(io,'(a)')'   range -0.5818 <= Bessel(0,x) <= 0.5818 . It has the same'
write(io,'(a)')'   kind as X.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_besj1'
write(io,'(a)')'     real(8) :: x = 1.0_8'
write(io,'(a)')'     x = bessel_j1(x)'
write(io,'(a)')'   end program demo_besj1'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[bessel_j0]], [[bessel_jn]], [[bessel_y0]], [[bessel_y1]], [[bessel_yn]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     bessel_jn(3f) - [INTRINSIC:MATHEMATICS] Bessel function of the first kind'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'* result = bessel_jn(n, x)'
write(io,'(a)')'* result = bessel_jn(n1, n2, x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   bessel_jn(n, x) computes the [[Bessel function]] of the first kind of'
write(io,'(a)')'   order N of X.'
write(io,'(a)')'   If N and X are arrays, their ranks and shapes shall conform.'
write(io,'(a)')''
write(io,'(a)')'   bessel_jn(n1, n2, x) returns an array with the [[Bessel function|Bessel'
write(io,'(a)')'   functions]] of the first kind of the orders N1 to N2.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   N  - Shall be a scalar or an array of type INTEGER.'
write(io,'(a)')'   N1  - Shall be a non-negative scalar of type INTEGER.'
write(io,'(a)')'   N2  - Shall be a non-negative scalar of type INTEGER.'
write(io,'(a)')'   X  - Shall be a scalar or an array of type REAL. For bessel_jn(n1, n2, x) it shall be scalar.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'The return value is a scalar of type REAL. It has the same kind as X.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_besjn'
write(io,'(a)')'     real(8) :: x = 1.0_8'
write(io,'(a)')'     x = bessel_jn(5,x)'
write(io,'(a)')'   end program demo_besjn'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]], except for the transformational variant bessel_jn(n1, n2, x).'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[bessel_j0]], [[bessel_j1]], [[bessel_y0]], [[bessel_y1]], [[bessel_yn]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     bessel_y0(3f) - [INTRINSIC:MATHEMATICS] Bessel function of the second kind of order 0'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = bessel_y0(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   bessel_y0(x) computes the [[Bessel function]] of the second kind of'
write(io,'(a)')'   order 0 of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type shall be REAL.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'The return value is of type REAL. It has the same kind as X.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_besy0'
write(io,'(a)')'     real(8) :: x = 0.0_8'
write(io,'(a)')'     x = bessel_y0(x)'
write(io,'(a)')'   end program demo_besy0'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[bessel_j0]], [[bessel_j1]], [[bessel_jn]], [[bessel_y1]], [[bessel_yn]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     bessel_y1(3f) - [INTRINSIC:MATHEMATICS] Bessel function of the second kind of order 1'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = bessel_y1(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   bessel_y1(x) computes the [[Bessel function]] of the second kind of'
write(io,'(a)')'   order 1 of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  X  - The type shall be REAL.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'The return value is REAL. It has the same kind as X.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_besy1'
write(io,'(a)')'     real(8) :: x = 1.0_8'
write(io,'(a)')'     x = bessel_y1(x)'
write(io,'(a)')'   end program demo_besy1'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[bessel_j0]], [[bessel_j1]], [[bessel_jn]], [[bessel_y0]], [[bessel_yn]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     bessel_yn(3f) - [INTRINSIC:MATHEMATICS] Bessel function of the second kind'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'* result = bessel_yn(n, x)'
write(io,'(a)')'* result = bessel_yn(n1, n2, x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   bessel_yn(n, x) computes the [[Bessel function]] of the second kind'
write(io,'(a)')'   of order N of X. If N and X are arrays, their ranks and'
write(io,'(a)')'   shapes shall conform.'
write(io,'(a)')''
write(io,'(a)')'   bessel_yn(n1, n2, x) returns an array with the'
write(io,'(a)')'   [[Bessel function|Bessel functions]] of the first kind of the orders'
write(io,'(a)')'   N1 to N2.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  N   - Shall be a scalar or an array of type INTEGER.'
write(io,'(a)')'  N1  - Shall be a non-negative scalar of type INTEGER.'
write(io,'(a)')'  N2  - Shall be a non-negative scalar of type INTEGER.'
write(io,'(a)')'  X   - Shall be a scalar or an array of type REAL;'
write(io,'(a)')'        for bessel_yn(n1, n2, x) it shall be scalar.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is REAL. It has the same kind as X.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_besyn'
write(io,'(a)')'     real(8) :: x = 1.0_8'
write(io,'(a)')'     x = bessel_yn(5,x)'
write(io,'(a)')'   end program demo_besyn'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]], except for the transformational function bessel_yn(n1, n2, x)'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[bessel_j0]], [[bessel_j1]], [[bessel_jn]], [[bessel_y0]], [[bessel_y1]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     bge(3f) - [INTRINSIC:BIT COMPARE] Bitwise greater than or equal to'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Determines whether an integer is a bitwise greater than or equal to another.'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = bge(i, j)'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I  - Shall be of INTEGER type.'
write(io,'(a)')'   J  - Shall be of INTEGER type, and of the same kind as I.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type LOGICAL and of the default kind.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[bgt]], [[ble]], [[blt]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     bgt(3f) - [INTRINSIC:BIT COMPARE] Bitwise greater than'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = bgt(i, j)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Determines whether an integer is bitwise greater than another.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  I  - Shall be of INTEGER type or a BOZ literal constant.'
write(io,'(a)')'  J  - Shall be of INTEGER type, and of the same kind as I; or a BOZ literal constant.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'  The return value is of type LOGICAL and of the default kind.'
write(io,'(a)')'  The result is true if the sequence of bits represented by I is greater than the sequence of bits'
write(io,'(a)')'  represented by J, otherwise the result is false.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[bge]], [[ble]], [[blt]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     bit_size(3f) - [INTRINSIC:BIT INQUIRY] Bit size inquiry function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = bit_size(i)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   bit_size(i) returns the number of bits (integer precision plus sign bit)'
write(io,'(a)')'   represented by the type of I.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I  - The type shall be INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'The return value is of type INTEGER'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_bit_size'
write(io,'(a)')'        integer :: i = 123'
write(io,'(a)')'        integer :: size'
write(io,'(a)')'        size = bit_size(i)'
write(io,'(a)')'        print *, size'
write(io,'(a)')'    end program demo_bit_size'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     ble(3f) - [INTRINSIC:BIT COMPARE] Bitwise less than or equal to'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Determines whether an integer is bitwise less than or equal to another.'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = ble(i, j)'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  I  - Shall be of INTEGER type.'
write(io,'(a)')'  J  - Shall be of INTEGER type, and of the same kind as I.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'The return value is of type LOGICAL and of the default kind.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[bge]], [[bgt]], [[blt]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     blt(3f) - [INTRINSIC:BIT COMPARE] Bitwise less than'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = blt(i, j)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Determines whether an integer is bitwise less than another.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  I  - Shall be of INTEGER type.'
write(io,'(a)')'  J  - Shall be of INTEGER type, and of the same kind as I.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'The return value is of type LOGICAL and of the default kind.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[bge]], [[bgt]], [[ble]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     btest(3f) - [INTRINSIC:BIT MANIPULATION] Bit test function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = btest(i, pos)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   btest(i,pos) returns logical .true. if the bit at POS'
write(io,'(a)')'   in I is set.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I  - The type shall be INTEGER.'
write(io,'(a)')'   POS  - The type shall be INTEGER. A value of zero refers to the least significant bit.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type LOGICAL'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_btest'
write(io,'(a)')'        integer :: i = 32768 + 1024 + 64'
write(io,'(a)')'        integer :: pos'
write(io,'(a)')'        logical :: bool'
write(io,'(a)')'        do pos=0,16'
write(io,'(a)')'            bool = btest(i, pos)'
write(io,'(a)')'            print *, pos, bool'
write(io,'(a)')'        end do'
write(io,'(a)')'    end program demo_btest'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[ibclr]], [[ibits]], [[ibset]], [[iand]], [[ior]], [[ieor]],'
write(io,'(a)')'   [[mvbits]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     c_associated(3f) - [INTRINSIC:ISO_C_BINDING] Status of a C pointer'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'    result = c_associated(c_prt_1[, c_ptr_2])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   c_associated(c_prt_1[, c_ptr_2]) determines the status of the C pointer'
write(io,'(a)')'   c_ptr_1 or if c_ptr_1 is associated with the target c_ptr_2.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   c_ptr_1  - Scalar of the type c_ptr or c_funptr.'
write(io,'(a)')'   c_ptr_2  - (Optional) Scalar of the same type as c_ptr_1.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type LOGICAL; it is .false. if either'
write(io,'(a)')'   c_ptr_1 is a C NULL pointer or if c_ptr1 and c_ptr_2'
write(io,'(a)')'   point to different addresses.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    subroutine association_test(a,b)'
write(io,'(a)')'      use iso_c_binding, only: c_associated, c_loc, c_ptr'
write(io,'(a)')'      implicit none'
write(io,'(a)')'      real, pointer :: a'
write(io,'(a)')'      type(c_ptr) :: b'
write(io,'(a)')'      if(c_associated(b, c_loc(a))) &'
write(io,'(a)')'         stop ''b and a do not point to same target'''
write(io,'(a)')'    end subroutine association_test'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[c_loc]], [[c_funloc]], [[iso_c_binding]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     c_f_pointer(3f) - [INTRINSIC:ISO_C_BINDING] Convert C into Fortran pointer'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'    call c_f_pointer(cptr, fptr[, shape])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   c_f_pointer(cptr, fptr[, shape]) Assign the target, the C pointer,'
write(io,'(a)')'   CPTR to the Fortran pointer FPTR and specify its'
write(io,'(a)')'   shape.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   CPTR  - scalar of the type c_ptr. It is'
write(io,'(a)')'           intent(in).'
write(io,'(a)')'   FPTR  - pointer interoperable with CPTR. It is'
write(io,'(a)')'           intent(out).'
write(io,'(a)')'   SHAPE  - (Optional) Rank-one array of type INTEGER'
write(io,'(a)')'            with intent(in). It shall be present'
write(io,'(a)')'            if and only if FPTR is an array. The size'
write(io,'(a)')'            must be equal to the rank of FPTR.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_c_f_pointer'
write(io,'(a)')'      use iso_c_binding'
write(io,'(a)')'      implicit none'
write(io,'(a)')'      interface'
write(io,'(a)')'        subroutine my_routine(p) bind(c,name=''myC_func'')'
write(io,'(a)')'          import :: c_ptr'
write(io,'(a)')'          type(c_ptr), intent(out) :: p'
write(io,'(a)')'        end subroutine'
write(io,'(a)')'      end interface'
write(io,'(a)')'      type(c_ptr) :: cptr'
write(io,'(a)')'      real,pointer :: a(:)'
write(io,'(a)')'      call my_routine(cptr)'
write(io,'(a)')'      call c_f_pointer(cptr, a, [12])'
write(io,'(a)')'    end program demo_c_f_pointer'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[c_loc]], [[c_f_procpointer]], [[iso_c_binding]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     c_f_procpointer(3f) - [INTRINSIC:ISO_C_BINDING] Convert C into Fortran procedure pointer'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   call c_f_procpointer(cptr, fptr)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   c_f_procpointer(cptr, fptr) assigns the target of the C'
write(io,'(a)')'   function pointer CPTR to the Fortran procedure pointer'
write(io,'(a)')'   FPTR.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  CPTR  - scalar of the type c_funptr.'
write(io,'(a)')'          It is intent(in).'
write(io,'(a)')'  FPTR  - procedure pointer interoperable with CPTR.'
write(io,'(a)')'          It is intent(out).'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_c_f_procpointer'
write(io,'(a)')'      use iso_c_binding'
write(io,'(a)')'      implicit none'
write(io,'(a)')'      abstract interface'
write(io,'(a)')'        function func(a)'
write(io,'(a)')'          import :: c_float'
write(io,'(a)')'          real(c_float), intent(in) :: a'
write(io,'(a)')'          real(c_float) :: func'
write(io,'(a)')'        end function'
write(io,'(a)')'      end interface'
write(io,'(a)')'      interface'
write(io,'(a)')'         function getIterFunc() bind(c,name="getIterFunc")'
write(io,'(a)')'           import :: c_funptr'
write(io,'(a)')'           type(c_funptr) :: getIterFunc'
write(io,'(a)')'         end function'
write(io,'(a)')'      end interface'
write(io,'(a)')'      type(c_funptr) :: cfunptr'
write(io,'(a)')'      procedure(func), pointer :: myFunc'
write(io,'(a)')'      cfunptr = getIterFunc()'
write(io,'(a)')'      call c_f_procpointer(cfunptr, myFunc)'
write(io,'(a)')'    end program demo_c_f_procpointer'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[c_loc]], [[c_f_pointer]], [[iso_c_binding]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     c_funloc(3f) - [INTRINSIC:ISO_C_BINDING] Obtain the C address of a procedure'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'    result = c_funloc(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   c_funloc(x) determines the C address of the argument.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - Interoperable function or pointer to such function.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type c_funptr and contains the C address'
write(io,'(a)')'   of the argument.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    ! program demo_c_funloc and module'
write(io,'(a)')'    module x'
write(io,'(a)')'    use iso_c_binding'
write(io,'(a)')'    implicit none'
write(io,'(a)')'    contains'
write(io,'(a)')'    subroutine sub(a) bind(c)'
write(io,'(a)')'    real(c_float) :: a'
write(io,'(a)')'       a = sqrt(a)+5.0'
write(io,'(a)')'    end subroutine sub'
write(io,'(a)')'    end module x'
write(io,'(a)')'    !'
write(io,'(a)')'    program demo_c_funloc'
write(io,'(a)')'    use iso_c_binding'
write(io,'(a)')'    use x'
write(io,'(a)')'    implicit none'
write(io,'(a)')'    interface'
write(io,'(a)')'       subroutine my_routine(p) bind(c,name=''myC_func'')'
write(io,'(a)')'         import :: c_funptr'
write(io,'(a)')'         type(c_funptr), intent(in) :: p'
write(io,'(a)')'       end subroutine'
write(io,'(a)')'    end interface'
write(io,'(a)')'       call my_routine(c_funloc(sub))'
write(io,'(a)')'    !'
write(io,'(a)')'    end program demo_c_funloc'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[c_associated]], [[c_loc]],'
write(io,'(a)')'   [[c_f_pointer]], [[c_f_procpointer]],'
write(io,'(a)')'   [[iso_c_binding]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     c_loc(3f) - [INTRINSIC:ISO_C_BINDING] Obtain the C address of an object'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = c_loc(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   c_loc(x) determines the C address of the argument.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - Shall have either the POINTER or TARGET attribute. It'
write(io,'(a)')'         shall not be a coindexed object. It shall either be a variable'
write(io,'(a)')'         with interoperable type and kind type parameters, or be a scalar,'
write(io,'(a)')'         nonpolymorphic variable with no length type parameters.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type c_ptr and contains the C address'
write(io,'(a)')'   of the argument.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   subroutine association_test(a,b)'
write(io,'(a)')'     use iso_c_binding, only: c_associated, c_loc, c_ptr'
write(io,'(a)')'     implicit none'
write(io,'(a)')'     real, pointer :: a'
write(io,'(a)')'     type(c_ptr) :: b'
write(io,'(a)')'     if(c_associated(b, c_loc(a))) &'
write(io,'(a)')'        stop ''b and a do not point to same target'''
write(io,'(a)')'   end subroutine association_test'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[c_associated]], [[c_funloc]],'
write(io,'(a)')'   [[c_f_pointer]], [[c_f_procpointer]],'
write(io,'(a)')'   [[iso_c_binding]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     c_sizeof(3f) - [INTRINSIC:ISO_C_BINDING] Size in bytes of an expression'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'n = c_sizeof(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   c_sizeof(x) calculates the number of bytes of storage the'
write(io,'(a)')'   expression X occupies.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The argument shall be an interoperable data entity.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type integer and of the system-dependent kind'
write(io,'(a)')'   c_size_t (from the [[iso_c_binding]] module). Its value is the'
write(io,'(a)')'   number of bytes occupied by the argument. If the argument has the'
write(io,'(a)')'   POINTER attribute, the number of bytes of the storage area pointed'
write(io,'(a)')'   to is returned. If the argument is of a derived type with POINTER'
write(io,'(a)')'   or ALLOCATABLE components, the return value does not account for'
write(io,'(a)')'   the sizes of the data pointed to by these components.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   use iso_c_binding'
write(io,'(a)')'   integer(c_int) :: i'
write(io,'(a)')'   real(c_float) :: r, s(5)'
write(io,'(a)')'   print *, (c_sizeof(s)/c_sizeof(r) == 5)'
write(io,'(a)')'   end'
write(io,'(a)')''
write(io,'(a)')'   The example will print .true. unless you are using a platform'
write(io,'(a)')'   where default REAL variables are unusually padded.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]]'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Intrinsic function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[storage_size]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     ceiling(3f) - [INTRINSIC:NUMERIC] Integer ceiling function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = ceiling(a [, kind])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   ceiling(a) returns the least integer greater than or equal to A.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   A  - The type shall be REAL.'
write(io,'(a)')'   KIND  - (Optional) An INTEGER initialization'
write(io,'(a)')'expression indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type integer(kind) if KIND is present'
write(io,'(a)')'   and a default-kind INTEGER otherwise.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_ceiling'
write(io,'(a)')'        real :: x = 63.29'
write(io,'(a)')'        real :: y = -63.59'
write(io,'(a)')'        print *, ceiling(x) ! returns 64'
write(io,'(a)')'        print *, ceiling(y) ! returns -63'
write(io,'(a)')'    end program demo_ceiling'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[floor]], [[nint]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     char(3f) - [INTRINSIC:CHARACTER] Character conversion function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = char(i [, kind])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   char(i [, kind]) returns the character represented by the integer I.'
write(io,'(a)')'   ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I  - The type shall be INTEGER.'
write(io,'(a)')'   KIND  - (Optional) An INTEGER initialization'
write(io,'(a)')'           expression indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type character(1)'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_char'
write(io,'(a)')'        integer :: i = 74'
write(io,'(a)')'        character(1) :: c'
write(io,'(a)')'        c = char(i)'
write(io,'(a)')'        print *, i, c ! returns ''J'''
write(io,'(a)')'    end program demo_char'
write(io,'(a)')''
write(io,'(a)')'NOTE'
write(io,'(a)')''
write(io,'(a)')'   See [[ichar]] for a discussion of converting between numerical values'
write(io,'(a)')'   and formatted string representations.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[achar]], [[iachar]], [[ichar]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     cmplx(3f) - [INTRINSIC:NUMERIC] Complex conversion function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = cmplx(x [, y [, kind]])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   cmplx(x [, y [, kind]]) returns a complex number where X is converted to'
write(io,'(a)')'   the real component. If Y is present it is converted to the imaginary'
write(io,'(a)')'   component. If Y is not present then the imaginary component is set to'
write(io,'(a)')'   0.0. If X is complex then Y must not be present.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X     - The type may be INTEGER, REAL, or COMPLEX.'
write(io,'(a)')'   Y     - (Optional; only allowed if X is not COMPLEX.).'
write(io,'(a)')'           May be INTEGER or REAL.'
write(io,'(a)')'   KIND  - (Optional) An INTEGER initialization expression'
write(io,'(a)')'           indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of COMPLEX type, with a kind equal to'
write(io,'(a)')'   KIND if it is specified. If KIND is not specified, the'
write(io,'(a)')'   result is of the default COMPLEX kind, regardless of the kinds of'
write(io,'(a)')'   X and Y.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_cmplx'
write(io,'(a)')'        integer :: i = 42'
write(io,'(a)')'        real :: x = 3.14'
write(io,'(a)')'        complex :: z'
write(io,'(a)')'        z = cmplx(i, x)'
write(io,'(a)')'        print *, z, cmplx(x)'
write(io,'(a)')'    end program demo_cmplx'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     co_broadcast(3f) - [INTRINSIC] Copy a value to all images the current set of images'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   call co_broadcast(A, SOURCE_IMAGE [, STAT, ERRMSG])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   co_broadcast copies the value of argument A on the image with'
write(io,'(a)')'   image index source_image to all images in the current team. A'
write(io,'(a)')'   becomes defined as if by intrinsic assignment. If the execution was'
write(io,'(a)')'   successful and STAT is present, it is assigned the value zero. If the'
write(io,'(a)')'   execution failed, STAT gets assigned a nonzero value and, if present,'
write(io,'(a)')'   ERRMSG gets assigned a value describing the occurred error.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  A  - intent(inout) argument; shall have the same dynamic type and'
write(io,'(a)')'       type parameters on all images of the current team. If it is an array,'
write(io,'(a)')'       it shall have the same shape on all images.'
write(io,'(a)')''
write(io,'(a)')'  SOURCE_IMAGE  - a scalar integer expression. It shall have the'
write(io,'(a)')'                  same the same value on all images and refer to an image of the'
write(io,'(a)')'                  current team.'
write(io,'(a)')''
write(io,'(a)')'   STAT  - (optional) a scalar integer variable'
write(io,'(a)')''
write(io,'(a)')'   ERRMSG  - (optional) a scalar character variable'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_co_broadcast'
write(io,'(a)')'     integer :: val(3)'
write(io,'(a)')'     if (this_image() == 1) then'
write(io,'(a)')'       val = [1, 5, 3]'
write(io,'(a)')'     end if'
write(io,'(a)')'     call co_broadcast (val, source_image=1)'
write(io,'(a)')'     print *, this_image, ":", val'
write(io,'(a)')'   end program demo_co_broadcast'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[co_max]], [[co_min]], [[co_sum]], [[co_reduce]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     co_max(3f) - [INTRINSIC] Maximal value on the current set of images'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   call co_max(a [, result_image, stat, errmsg])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   co_max determines element-wise the maximal value of A on all'
write(io,'(a)')'   images of the current team. If result_image is present, the maximum'
write(io,'(a)')'   values are returned in A on the specified image only and the value'
write(io,'(a)')'   of A on the other images become undefined. If result_image is not'
write(io,'(a)')'   present, the value is returned on all images. If the execution was'
write(io,'(a)')'   successful and STAT is present, it is assigned the value zero. If'
write(io,'(a)')'   the execution failed, STAT gets assigned a nonzero value and, if'
write(io,'(a)')'   present, ERRMSG gets assigned a value describing the occurred error.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  A  - shall be an integer, real or character variable, which has the'
write(io,'(a)')'       same type and type parameters on all images of the team.'
write(io,'(a)')'  result_image  - (optional) a scalar integer expression; if present,'
write(io,'(a)')'                  it shall have the same the same value on all images and refer to an'
write(io,'(a)')'                  image of the current team.'
write(io,'(a)')'  STAT  - (optional) a scalar integer variable'
write(io,'(a)')'  ERRMSG  - (optional) a scalar character variable'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_co_max'
write(io,'(a)')'     integer :: val'
write(io,'(a)')'     val = this_image()'
write(io,'(a)')'     call co_max(val, result_image=1)'
write(io,'(a)')'     if (this_image() == 1) then'
write(io,'(a)')'       write(*,*) "Maximal value", val  ! prints num_images()'
write(io,'(a)')'     end if'
write(io,'(a)')'   end program demo_co_max'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[TS 18508]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Collective subroutine]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[co_min]], [[co_sum]], [[co_reduce]], [[co_broadcast]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     co_min(3f) - [INTRINSIC] Minimal value on the current set of images'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'call co_min(a [, result_image, stat, errmsg])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   co_min determines element-wise the minimal value of A on all'
write(io,'(a)')'   images of the current team. If result_image is present, the minimal'
write(io,'(a)')'   values are returned in A on the specified image only and the value'
write(io,'(a)')'   of A on the other images become undefined. If result_image is not'
write(io,'(a)')'   present, the value is returned on all images. If the execution was'
write(io,'(a)')'   successful and STAT is present, it is assigned the value zero. If'
write(io,'(a)')'   the execution failed, STAT gets assigned a nonzero value and, if'
write(io,'(a)')'   present, ERRMSG gets assigned a value describing the occurred error.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  A  - shall be an integer, real or character variable, which has the'
write(io,'(a)')'       same type and type parameters on all images of the team.'
write(io,'(a)')'  result_image  - (optional) a scalar integer expression; if present,'
write(io,'(a)')'                  it shall have the same the same value on all images and refer to an'
write(io,'(a)')'                  image of the current team.'
write(io,'(a)')'  STAT  - (optional) a scalar integer variable'
write(io,'(a)')'  ERRMSG  - (optional) a scalar character variable'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_co_min'
write(io,'(a)')'     integer :: val'
write(io,'(a)')'     val = this_image()'
write(io,'(a)')'     call co_min(val, result_image=1)'
write(io,'(a)')'     if (this_image() == 1) then'
write(io,'(a)')'       write(*,*) "Minimal value", val  ! prints 1'
write(io,'(a)')'     end if'
write(io,'(a)')'   end program demo_co_min'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[TS 18508]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Collective subroutine]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[co_max]], [[co_sum]], [[co_reduce]], [[co_broadcast]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     co_reduce(3f) - [INTRINSIC] Reduction of values on the current set of images'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   call co_reduce(a, operator, [, result_image, stat, errmsg])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   co_reduce determines element-wise the reduction of the value of A'
write(io,'(a)')'   on all images of the current team. The pure function passed as'
write(io,'(a)')'   OPERATOR is used to pairwise reduce the values of A by passing'
write(io,'(a)')'   either the value of A of different images or the result values of'
write(io,'(a)')'   such a reduction as argument. If A is an array, the deduction is'
write(io,'(a)')'   done element wise. If result_image is present, the result values are'
write(io,'(a)')'   returned in A on the specified image only and the value of A on'
write(io,'(a)')'   the other images become undefined. If result_image is not present,'
write(io,'(a)')'   the value is returned on all images. If the execution was successful'
write(io,'(a)')'   and STAT is present, it is assigned the value zero. If the'
write(io,'(a)')'   execution failed, STAT gets assigned a nonzero value and, if'
write(io,'(a)')'   present, ERRMSG gets assigned a value describing the occurred error.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  A  - is an intent(inout) argument and shall be nonpolymorphic. If'
write(io,'(a)')'  it is allocatable, it shall be allocated; if it is a pointer, it'
write(io,'(a)')'  shall be associated. A shall have the same type and type'
write(io,'(a)')'  parameters on all images of the team; if it is an array, it shall'
write(io,'(a)')'  have the same shape on all images.'
write(io,'(a)')''
write(io,'(a)')'  OPERATOR  - pure function with two scalar nonallocatable arguments,'
write(io,'(a)')'  which shall be nonpolymorphic and have the same type and type'
write(io,'(a)')'  parameters as A. The function shall return a nonallocatable'
write(io,'(a)')'  scalar of the same type and type parameters as A. The function'
write(io,'(a)')'  shall be the same on all images and with regards to the arguments'
write(io,'(a)')'  mathematically commutative and associative. Note that OPERATOR'
write(io,'(a)')'  may not be an elemental function, unless it is an intrinsic function.'
write(io,'(a)')'  result_image  - (optional) a scalar integer expression; if present,'
write(io,'(a)')'  it shall have the same the same value on all images and refer to an'
write(io,'(a)')'  image of the current team.'
write(io,'(a)')''
write(io,'(a)')'  STAT  - (optional) a scalar integer variable'
write(io,'(a)')''
write(io,'(a)')'  ERRMSG  - (optional) a scalar character variable'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_co_reduce'
write(io,'(a)')'     integer :: val'
write(io,'(a)')'     val = this_image()'
write(io,'(a)')'     call co_reduce(val, result_image=1, operator=myprod)'
write(io,'(a)')'     if (this_image() == 1) then'
write(io,'(a)')'       write(*,*) "Product value", val  ! prints num_images() factorial'
write(io,'(a)')'     end if'
write(io,'(a)')'   contains'
write(io,'(a)')'     pure function myprod(a, b)'
write(io,'(a)')'       integer, value :: a, b'
write(io,'(a)')'       integer :: myprod'
write(io,'(a)')'       myprod = a * b'
write(io,'(a)')'     end function myprod'
write(io,'(a)')'   end program demo_co_reduce'
write(io,'(a)')''
write(io,'(a)')'NOTE'
write(io,'(a)')''
write(io,'(a)')'   While the rules permit in principle an intrinsic function, none of the'
write(io,'(a)')'   intrinsics in the standard fulfill the criteria of having a specific'
write(io,'(a)')'   function, which takes two arguments of the same type and returning'
write(io,'(a)')'   that type as result.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[TS 18508]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Collective subroutine]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[co_min]], [[co_max]], [[co_sum]], [[co_broadcast]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     co_sum(3f) - [INTRINSIC] Sum of values on the current set of images'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   call co_sum(a [, result_image, stat, errmsg])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   co_sum sums up the values of each element of A on all images of'
write(io,'(a)')'   the current team. If result_image is present, the summed-up values'
write(io,'(a)')'   are returned in A on the specified image only and the value of A'
write(io,'(a)')'   on the other images become undefined. If result_image is not'
write(io,'(a)')'   present, the value is returned on all images. If the execution was'
write(io,'(a)')'   successful and STAT is present, it is assigned the value zero. If'
write(io,'(a)')'   the execution failed, STAT gets assigned a nonzero value and, if'
write(io,'(a)')'   present, ERRMSG gets assigned a value describing the occurred error.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  A  - shall be an integer, real or complex variable, which has the'
write(io,'(a)')'  same type and type parameters on all images of the team.'
write(io,'(a)')'  result_image  - (optional) a scalar integer expression; if present,'
write(io,'(a)')'  it shall have the same the same value on all images and refer to an'
write(io,'(a)')'  image of the current team.'
write(io,'(a)')''
write(io,'(a)')'  STAT  - (optional) a scalar integer variable'
write(io,'(a)')''
write(io,'(a)')'  ERRMSG  - (optional) a scalar character variable'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_co_sum'
write(io,'(a)')'     integer :: val'
write(io,'(a)')'     val = this_image()'
write(io,'(a)')'     call co_sum(val, result_image=1)'
write(io,'(a)')'     if (this_image() == 1) then'
write(io,'(a)')'       write(*,*) "The sum is ", val ! prints (n**2 + n)/2, with n = num_images()'
write(io,'(a)')'     end if'
write(io,'(a)')'   end program demo_co_sum'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[TS 18508]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Collective subroutine]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[co_max]], [[co_min]], [[co_reduce]], [[co_broadcast]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     command_argument_count(3f) - [INTRINSIC:SYSTEM ENVIRONMENT] Get number of command line arguments'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = command_argument_count()'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   command_argument_count returns the number of arguments passed on the'
write(io,'(a)')'   command line when the containing program was invoked.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'None'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type integer(4)'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_command_argument_count'
write(io,'(a)')'       integer :: count'
write(io,'(a)')'       count = command_argument_count()'
write(io,'(a)')'       print *, count'
write(io,'(a)')'   end program demo_command_argument_count'
write(io,'(a)')''
write(io,'(a)')'  Sample output:'
write(io,'(a)')''
write(io,'(a)')'   # the command verb does not count'
write(io,'(a)')'   ./test_command_argument_count'
write(io,'(a)')'           0'
write(io,'(a)')'   # quoted strings may count as one argument'
write(io,'(a)')'   ./test_command_argument_count count arguments'
write(io,'(a)')'           2'
write(io,'(a)')'   ./test_command_argument_count ''count arguments'''
write(io,'(a)')'           1'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[get_command]],'
write(io,'(a)')'   [[get_command_argument]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     compiler_options(3f) - [INTRINSIC] Options passed to the compiler'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   str = compiler_options()'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   compiler_options returns a string with the options used for'
write(io,'(a)')'   compiling.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'None.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is a default-kind string with system-dependent'
write(io,'(a)')'   length. It contains the compiler flags used to compile the file,'
write(io,'(a)')'   which called the compiler_options intrinsic.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_compiler_version'
write(io,'(a)')'   use iso_fortran_env'
write(io,'(a)')'   implicit none'
write(io,'(a)')'   print ''(4a)'', &'
write(io,'(a)')'      ''This file was compiled by '', &'
write(io,'(a)')'      compiler_version(),           &'
write(io,'(a)')'      '' using the options '',        &'
write(io,'(a)')'      compiler_options()'
write(io,'(a)')'   end program demo_compiler_version'
write(io,'(a)')''
write(io,'(a)')'  Example results:'
write(io,'(a)')''
write(io,'(a)')'   This file was compiled by GCC version 5.4.0 using the options'
write(io,'(a)')'   -I /usr/include/w32api -I /home/urbanjs/V600/lib/CYGWIN64_GFORTRAN'
write(io,'(a)')'   -mtune=generic -march=x86-64 -g -Wunused -Wuninitialized -Wall'
write(io,'(a)')'   -std=f2008 -fbounds-check -fbacktrace -finit-real=nan'
write(io,'(a)')'   -fno-range-check -frecord-marker=4'
write(io,'(a)')'   -J /home/urbanjs/V600/lib/CYGWIN64_GFORTRAN'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]]'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Inquiry function of the module [[iso_fortran_env]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[compiler_version]], [[iso_fortran_env]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     compiler_version(3f) - [INTRINSIC] Compiler version string'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'str = compiler_version()'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   compiler_version returns a string with the name and the'
write(io,'(a)')'   version of the compiler.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'None.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is a default-kind string with system-dependent'
write(io,'(a)')'   length. It contains the name of the compiler and its version number.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_compiler_version'
write(io,'(a)')'   use iso_fortran_env'
write(io,'(a)')'   implicit none'
write(io,'(a)')'   print ''(4a)'', &'
write(io,'(a)')'      ''This file was compiled by '', &'
write(io,'(a)')'      compiler_version(),           &'
write(io,'(a)')'      '' using the options '',        &'
write(io,'(a)')'      compiler_options()'
write(io,'(a)')'   end program demo_compiler_version'
write(io,'(a)')''
write(io,'(a)')'  Example results:'
write(io,'(a)')''
write(io,'(a)')'   This file was compiled by GCC version 5.4.0 using the options'
write(io,'(a)')'   -I /usr/include/w32api -I /home/urbanjs/V600/lib/CYGWIN64_GFORTRAN'
write(io,'(a)')'   -mtune=generic -march=x86-64 -g -Wunused -Wuninitialized -Wall'
write(io,'(a)')'   -std=f2008 -fbounds-check -fbacktrace -finit-real=nan'
write(io,'(a)')'   -fno-range-check -frecord-marker=4'
write(io,'(a)')'   -J /home/urbanjs/V600/lib/CYGWIN64_GFORTRAN'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]]'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Inquiry function of the module [[iso_fortran_env]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[compiler_options]], [[iso_fortran_env]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     conjg(3f) - [INTRINSIC:NUMERIC] Complex conjugate function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   z = conjg(z)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   conjg(z) returns the conjugate of Z. If Z is (x, y)'
write(io,'(a)')'   then the result is (x, -y)'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   Z  - The type shall be COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_conjg'
write(io,'(a)')'        complex :: z = (2.0, 3.0)'
write(io,'(a)')'        complex(8) :: dz = (2.71_8, -3.14_8)'
write(io,'(a)')'        z= conjg(z)'
write(io,'(a)')'        print *, z'
write(io,'(a)')'        dz = dconjg(dz)'
write(io,'(a)')'        print *, dz'
write(io,'(a)')'    end program demo_conjg'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     cos(3f) - [INTRINSIC:TRIGONOMETRIC] Cosine function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = cos(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   cos(x) computes the cosine of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type shall be REAL or COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of the same type and kind as X. The real part'
write(io,'(a)')'   of the result is in radians. If X is of the type REAL, the return'
write(io,'(a)')'   value lies in the range -1 <= \cos (x) <= 1.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_cos'
write(io,'(a)')'     real :: x = 0.0'
write(io,'(a)')'     x = cos(x)'
write(io,'(a)')'   end program demo_cos'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[acos]], [[sin]], [[tan]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     cosh(3f) - [INTRINSIC:TRIGONOMETRIC] Hyperbolic cosine function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   x = cosh(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   cosh(x) computes the hyperbolic cosine of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type shall be REAL or COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value has same type and kind as X. If X is complex, the'
write(io,'(a)')'   imaginary part of the result is in radians. If X is REAL, the'
write(io,'(a)')'   return value has a lower bound of one, cosh(x) >= 1.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_cosh'
write(io,'(a)')'     real(8) :: x = 1.0_8'
write(io,'(a)')'     x = cosh(x)'
write(io,'(a)')'   end program demo_cosh'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later, for a complex argument [[Fortran 2008]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   Inverse function: [[acosh]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'   count(3f) - [INTRINSIC:TRANSFORMATIONAL FUNCTION] Count function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = count(mask [, dim, kind])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Counts the number of .true. elements in a logical MASK,'
write(io,'(a)')'   or, if the DIM argument is supplied, counts the number of'
write(io,'(a)')'   elements along each row of the array in the DIM direction.'
write(io,'(a)')'   If the array has zero size, or all of the elements of MASK are'
write(io,'(a)')'   false, then the result is 0.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   MASK  - The type shall be LOGICAL.'
write(io,'(a)')'   DIM   - (Optional) The type shall be INTEGER.'
write(io,'(a)')'   KIND  - (Optional) An INTEGER initialization'
write(io,'(a)')'           expression indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER and of kind KIND. If'
write(io,'(a)')'   KIND is absent, the return value is of default integer kind.'
write(io,'(a)')'   If DIM is present, the result is an array with a rank one less'
write(io,'(a)')'   than the rank of ARRAY, and a size corresponding to the shape'
write(io,'(a)')'   of ARRAY with the DIM dimension removed.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_count'
write(io,'(a)')'       integer, dimension(2,3) :: a, b'
write(io,'(a)')'       logical, dimension(2,3) :: mask'
write(io,'(a)')'       a = reshape( (/ 1, 2, 3, 4, 5, 6 /), (/ 2, 3 /))'
write(io,'(a)')'       b = reshape( (/ 0, 7, 3, 4, 5, 8 /), (/ 2, 3 /))'
write(io,'(a)')'       print ''(3i3)'', a(1,:)'
write(io,'(a)')'       print ''(3i3)'', a(2,:)'
write(io,'(a)')'       print *'
write(io,'(a)')'       print ''(3i3)'', b(1,:)'
write(io,'(a)')'       print ''(3i3)'', b(2,:)'
write(io,'(a)')'       print *'
write(io,'(a)')'       mask = a.ne.b'
write(io,'(a)')'       print ''(3l3)'', mask(1,:)'
write(io,'(a)')'       print ''(3l3)'', mask(2,:)'
write(io,'(a)')'       print *'
write(io,'(a)')'       print ''(3i3)'', count(mask)'
write(io,'(a)')'       print *'
write(io,'(a)')'       print ''(3i3)'', count(mask, 1)'
write(io,'(a)')'       print *'
write(io,'(a)')'       print ''(3i3)'', count(mask, 2)'
write(io,'(a)')'   end program demo_count'
write(io,'(a)')''
write(io,'(a)')'   Expected Results:'
write(io,'(a)')''
write(io,'(a)')'     1  3  5'
write(io,'(a)')'     2  4  6'
write(io,'(a)')''
write(io,'(a)')'     0  3  5'
write(io,'(a)')'     7  4  8'
write(io,'(a)')''
write(io,'(a)')'     T  F  F'
write(io,'(a)')'     T  F  T'
write(io,'(a)')''
write(io,'(a)')'     3'
write(io,'(a)')''
write(io,'(a)')'     2  0  1'
write(io,'(a)')''
write(io,'(a)')'     1  2'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later, with KIND argument [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     cpu_time(3f) - [INTRINSIC:SYSTEM ENVIRONMENT] return CPU processor time in seconds'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   call cpu_time(time)'
write(io,'(a)')''
write(io,'(a)')'      real,intent(out) :: time'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Returns a REAL value representing the elapsed CPU time in'
write(io,'(a)')'   seconds. This is useful for testing segments of code to determine'
write(io,'(a)')'   execution time.'
write(io,'(a)')''
write(io,'(a)')'   The exact definition of time is left imprecise because of the'
write(io,'(a)')'   variability in what different processors are able to provide.'
write(io,'(a)')''
write(io,'(a)')'   for gfortran(1) If a time source is available, time will be reported'
write(io,'(a)')'   with microsecond resolution. If no time source is available, TIME is'
write(io,'(a)')'   set to -1.0.'
write(io,'(a)')''
write(io,'(a)')'   Note that TIME may contain a system dependent, arbitrary offset'
write(io,'(a)')'   and may not start with 0.0. For cpu_time the absolute'
write(io,'(a)')'   value is meaningless. Only differences between subsequent calls,'
write(io,'(a)')'   as shown in the example below, should be used.'
write(io,'(a)')''
write(io,'(a)')'   A processor for which a single result is inadequate (for example,'
write(io,'(a)')'   a parallel processor) might choose to provide an additional version'
write(io,'(a)')'   for which time is an array.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   TIME  - The type shall be REAL with intent(out).'
write(io,'(a)')'           It is assigned a processor-dependent approximation to the'
write(io,'(a)')'           processor time in seconds. If the processor cannot return'
write(io,'(a)')'           a meaningful time, a processor-dependent negative value is returned.'
write(io,'(a)')'           The start time is left imprecise because the purpose is to'
write(io,'(a)')'           time sections of code, as in the example.'
write(io,'(a)')'           This might or might not include system overhead time.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_cpu_time'
write(io,'(a)')'       real :: start, finish'
write(io,'(a)')'       call cpu_time(start)'
write(io,'(a)')'       ! put code to test here'
write(io,'(a)')'       call cpu_time(finish)'
write(io,'(a)')'       ! writes processor time taken by the piece of code.'
write(io,'(a)')'       print ''("Processor Time = ",f6.3," seconds.")'',finish-start'
write(io,'(a)')'    end program demo_cpu_time'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[system_clock]], [[date_and_time]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     cshift(3f) - [INTRINSIC:TRANSFORMATIONAL FUNCTION] Circular shift elements of an array'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = cshift(array, shift [, dim])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   cshift(array, shift [, dim]) performs a circular shift on elements of'
write(io,'(a)')'   ARRAY along the dimension of DIM. If DIM is omitted it is'
write(io,'(a)')'   taken to be 1. DIM is a scalar of type INTEGER in the'
write(io,'(a)')'   range of 1 <= DIM <= n, where "n" is the rank of ARRAY.'
write(io,'(a)')'   If the rank of ARRAY is one, then all elements of ARRAY are shifted'
write(io,'(a)')'   by SHIFT places. If rank is greater than one, then all complete rank one'
write(io,'(a)')'   sections of ARRAY along the given dimension are shifted. Elements'
write(io,'(a)')'   shifted out one end of each rank one section are shifted back in the other end.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   ARRAY  - Shall be an array of any type.'
write(io,'(a)')'   SHIFT  - The type shall be INTEGER.'
write(io,'(a)')'   DIM  - The type shall be INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   Returns an array of same type and rank as the ARRAY argument.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_cshift'
write(io,'(a)')'        integer, dimension(3,3) :: a'
write(io,'(a)')'        a = reshape( (/ 1, 2, 3, 4, 5, 6, 7, 8, 9 /), (/ 3, 3 /))'
write(io,'(a)')'        print ''(3i3)'', a(1,:)'
write(io,'(a)')'        print ''(3i3)'', a(2,:)'
write(io,'(a)')'        print ''(3i3)'', a(3,:)'
write(io,'(a)')'        a = cshift(a, SHIFT=(/1, 2, -1/), DIM=2)'
write(io,'(a)')'        print *'
write(io,'(a)')'        print ''(3i3)'', a(1,:)'
write(io,'(a)')'        print ''(3i3)'', a(2,:)'
write(io,'(a)')'        print ''(3i3)'', a(3,:)'
write(io,'(a)')'    end program demo_cshift'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     date_and_time(3f) - [INTRINSIC:SYSTEM ENVIRONMENT] gets current time'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'    call date_and_time([date, time, zone, values])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   date_and_time(date, time, zone, values) gets the corresponding date and'
write(io,'(a)')'   time information from the real-time system clock. DATE is intent(out)'
write(io,'(a)')'   and has form ccyymmdd. TIME is intent(out) and has form hhmmss.sss.'
write(io,'(a)')'   ZONE is intent(out) and has form (+-)hhmm, representing the difference'
write(io,'(a)')'   with respect to Coordinated Universal Time (UTC). Unavailable time and'
write(io,'(a)')'   date parameters return blanks.'
write(io,'(a)')''
write(io,'(a)')'   VALUES is intent(out) and provides the following:'
write(io,'(a)')''
write(io,'(a)')'   * value(1): - The year'
write(io,'(a)')'   * value(2): - The month'
write(io,'(a)')'   * value(3): - The day of the month'
write(io,'(a)')'   * value(4): - Time difference with UTC in minutes'
write(io,'(a)')'   * value(5): - The hour of the day'
write(io,'(a)')'   * value(6): - The minutes of the hour'
write(io,'(a)')'   * value(7): - The seconds of the minute'
write(io,'(a)')'   * value(8): - The milliseconds of the second'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   DATE    - (Optional) The type shall be character(len=8) or larger,'
write(io,'(a)')'             and of default kind.'
write(io,'(a)')'   TIME    - (Optional) The type shall be character(len=10) or'
write(io,'(a)')'             larger, and of default kind.'
write(io,'(a)')'   ZONE    - (Optional) The type shall be character(len=5) or larger,'
write(io,'(a)')'             and of default kind.'
write(io,'(a)')'   VALUES  - (Optional) The type shall be integer(8).'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'None'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'    program demo_time_and_date'
write(io,'(a)')''
write(io,'(a)')'        character(8)  :: date'
write(io,'(a)')'        character(10) :: time'
write(io,'(a)')'        character(5)  :: zone'
write(io,'(a)')'        integer,dimension(8) :: values'
write(io,'(a)')'        ! using keyword arguments'
write(io,'(a)')'        call date_and_time(date,time,zone,values)'
write(io,'(a)')'        call date_and_time(DATE=date,ZONE=zone)'
write(io,'(a)')'        call date_and_time(TIME=time)'
write(io,'(a)')'        call date_and_time(VALUES=values)'
write(io,'(a)')'        print ''(a,2x,a,2x,a)'', date, time, zone'
write(io,'(a)')'        print ''(8i5)'', values'
write(io,'(a)')''
write(io,'(a)')'    end program demo_time_and_date'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[cpu_time]], [[system_clock]]'
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     dble(3f) - [INTRINSIC:NUMERIC] Double conversion function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = DBLE(A)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   DBLE(A) Converts A to double precision real type.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   A  - The type shall be INTEGER, REAL, or COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type DOUBLEPRECISION.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_dble'
write(io,'(a)')'        real    :: x = 2.18'
write(io,'(a)')'        integer :: i = 5'
write(io,'(a)')'        complex :: z = (2.3,1.14)'
write(io,'(a)')'        print *, dble(x), dble(i), dble(z)'
write(io,'(a)')'    end program demo_dble'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[float]], [[real]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     digits(3f) - [INTRINSIC] Significant digits function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = digits(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   digits(x) returns the number of significant digits of the internal model'
write(io,'(a)')'   representation of X. For example, on a system using a 32-bit'
write(io,'(a)')'   floating point representation, a default real number would likely return 24.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type may be INTEGER or REAL.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_digits'
write(io,'(a)')'        integer :: i = 12345'
write(io,'(a)')'        real :: x = 3.143'
write(io,'(a)')'        real(8) :: y = 2.33'
write(io,'(a)')'        print *, digits(i)'
write(io,'(a)')'        print *, digits(x)'
write(io,'(a)')'        print *, digits(y)'
write(io,'(a)')'    end program demo_digits'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     DIM(3f) - [INTRINSIC:NUMERIC] Positive difference'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = DIM(X, Y)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   DIM(X,Y) returns the difference X-Y if the result is positive;'
write(io,'(a)')'   otherwise returns zero.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type shall be INTEGER or REAL'
write(io,'(a)')'   Y  - The type shall be the same type and kind as X.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER or REAL.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_dim'
write(io,'(a)')'        integer :: i'
write(io,'(a)')'        real(8) :: x'
write(io,'(a)')'        i = dim(4, 15)'
write(io,'(a)')'        x = dim(4.345_8, 2.111_8)'
write(io,'(a)')'        print *, i'
write(io,'(a)')'        print *, x'
write(io,'(a)')'    end program demo_dim'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     dot_product(3f) - [INTRINSIC:TRANSFORMATIONAL FUNCTION] Dot product function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = dot_product(vector_a, vector_b)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   dot_product(vector_a, vector_b) computes the dot product multiplication'
write(io,'(a)')'   of two vectors vector_a and vector_b. The two vectors may be'
write(io,'(a)')'   either numeric or logical and must be arrays of rank one and of equal size. If'
write(io,'(a)')'   the vectors are INTEGER or REAL, the result is'
write(io,'(a)')'   sum(vector_a*vector_b). If the vectors are COMPLEX, the result'
write(io,'(a)')'   is sum(conjg(vector_a)*vector_b). If the vectors are LOGICAL,'
write(io,'(a)')'   the result is any(vector_a .and. vector_b).'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   vector_a  - The type shall be numeric or LOGICAL, rank 1.'
write(io,'(a)')'   vector_b  - The type shall be numeric if vector_a is of numeric type or LOGICAL'
write(io,'(a)')'               if vector_a is of type LOGICAL. vector_b shall be a rank-one array.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   If the arguments are numeric, the return value is a scalar of numeric type,'
write(io,'(a)')'   INTEGER, REAL, or COMPLEX. If the arguments are'
write(io,'(a)')'   LOGICAL, the return value is .true. or .false..'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_dot_prod'
write(io,'(a)')'        integer, dimension(3) :: a, b'
write(io,'(a)')'        a = (/ 1, 2, 3 /)'
write(io,'(a)')'        b = (/ 4, 5, 6 /)'
write(io,'(a)')'        print ''(3i3)'', a'
write(io,'(a)')'        print *'
write(io,'(a)')'        print ''(3i3)'', b'
write(io,'(a)')'        print *'
write(io,'(a)')'        print *, dot_product(a,b)'
write(io,'(a)')'    end program demo_dot_prod'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     dprod(3f) - [INTRINSIC:NUMERIC] Double product function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = dprod(x, y)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   dprod(x,y) returns the product x*y.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type shall be REAL.'
write(io,'(a)')'   Y  - The type shall be REAL.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type real(8).'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_dprod'
write(io,'(a)')'        real :: x = 5.2'
write(io,'(a)')'        real :: y = 2.3'
write(io,'(a)')'        real(8) :: d'
write(io,'(a)')'        d = dprod(x,y)'
write(io,'(a)')'        print *, d'
write(io,'(a)')'    end program demo_dprod'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     eoshift(3f) - [INTRINSIC:TRANSFORMATIONAL FUNCTION] End-off shift elements of an array'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = eoshift(array, shift [, boundary, dim])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   eoshift(array, shift[, boundary, dim]) performs an end-off shift on'
write(io,'(a)')'   elements of ARRAY along the dimension of DIM. If DIM is'
write(io,'(a)')'   omitted it is taken to be 1. DIM is a scalar of type'
write(io,'(a)')'   INTEGER in the range of 1 <= DIM <= n where "n" is the'
write(io,'(a)')'   rank of ARRAY. If the rank of ARRAY is one, then all elements of'
write(io,'(a)')'   ARRAY are shifted by SHIFT places. If rank is greater than one,'
write(io,'(a)')'   then all complete rank one sections of ARRAY along the given dimension are'
write(io,'(a)')'   shifted. Elements shifted out one end of each rank one section are dropped. If'
write(io,'(a)')'   BOUNDARY is present then the corresponding value of from BOUNDARY'
write(io,'(a)')'   is copied back in the other end. If BOUNDARY is not present then the'
write(io,'(a)')'   following are copied in depending on the type of ARRAY.'
write(io,'(a)')''
write(io,'(a)')'*Array Type* - *Boundary Value*'
write(io,'(a)')''
write(io,'(a)')'* Numeric  - 0 of the type and kind of ARRAY.'
write(io,'(a)')'* Logical  - .false..'
write(io,'(a)')'* Character(LEN) - LEN blanks.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   ARRAY  - May be any type, not scalar.'
write(io,'(a)')'   SHIFT  - The type shall be INTEGER.'
write(io,'(a)')'   BOUNDARY  - Same type as ARRAY.'
write(io,'(a)')'   DIM  - The type shall be INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   Returns an array of same type and rank as the ARRAY argument.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_eoshift'
write(io,'(a)')'        integer, dimension(3,3) :: a'
write(io,'(a)')'        a = reshape( (/ 1, 2, 3, 4, 5, 6, 7, 8, 9 /), (/ 3, 3 /))'
write(io,'(a)')'        print ''(3i3)'', a(1,:)'
write(io,'(a)')'        print ''(3i3)'', a(2,:)'
write(io,'(a)')'        print ''(3i3)'', a(3,:)'
write(io,'(a)')'        a = eoshift(a, SHIFT=(/1, 2, 1/), BOUNDARY=-5, DIM=2)'
write(io,'(a)')'        print *'
write(io,'(a)')'        print ''(3i3)'', a(1,:)'
write(io,'(a)')'        print ''(3i3)'', a(2,:)'
write(io,'(a)')'        print ''(3i3)'', a(3,:)'
write(io,'(a)')'    end program demo_eoshift'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     epsilon(3f) - [INTRINSIC] Epsilon function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = epsilon(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   epsilon(x) returns a nearly negligible number relative to 1.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type shall be REAL.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of same type as the argument.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_epsilon'
write(io,'(a)')'        real :: x = 3.143'
write(io,'(a)')'        real(8) :: y = 2.33'
write(io,'(a)')'        print *, epsilon(x)'
write(io,'(a)')'        print *, epsilon(y)'
write(io,'(a)')'    end program demo_epsilon'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     erf(3f) - [INTRINSIC:MATHEMATICS] Error function'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   erf(x) computes the error function of X, defined as'
write(io,'(a)')'   $$'
write(io,'(a)')'   \text{erf}(x) = \frac{2}{\sqrt{\pi}} \int_0**x e**{-t**2} dt.'
write(io,'(a)')'   $$'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = erf(x)'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type shall be REAL.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type REAL, of the same kind as'
write(io,'(a)')'   X and lies in the range -1 <= erf(x) <= 1 .'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_erf'
write(io,'(a)')'      real(8) :: x = 0.17_8'
write(io,'(a)')'      x = erf(x)'
write(io,'(a)')'    end program demo_erf'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     erfc(3f) - [INTRINSIC:MATHEMATICS] Complementary error function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = erfc(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   erfc(x) computes the complementary error function of X, defined as'
write(io,'(a)')'   $$'
write(io,'(a)')'   1 - \text{erf}(x) = 1 - \frac{2}{\sqrt{\pi}} \int_0**x e**{-t**2} dt.'
write(io,'(a)')'   $$'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type shall be REAL.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type REAL and of the same kind as X. It lies'
write(io,'(a)')'   in the range'
write(io,'(a)')''
write(io,'(a)')'     0 <= ERFC(X) <= 2.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_erfc'
write(io,'(a)')'     real(8) :: x = 0.17_8'
write(io,'(a)')'     x = erfc(x)'
write(io,'(a)')'   end program demo_erfc'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     erfc_scaled(3f) - [INTRINSIC:MATHEMATICS] Error function'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   erfc_scaled(x) computes the exponentially-scaled complementary'
write(io,'(a)')'   error function of X:'
write(io,'(a)')''
write(io,'(a)')'   $$'
write(io,'(a)')'   e**{x**2} \frac{2}{\sqrt{\pi}} \int_{x}**{\infty} e**{-t**2} dt.'
write(io,'(a)')'   $$'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = erfc_scaled(x)'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type shall be REAL.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type REAL and of the same kind as X.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_erfc_scaled'
write(io,'(a)')'     real(kind(0.0d0)) :: x = 0.17_8'
write(io,'(a)')'     x = erfc_scaled(x)'
write(io,'(a)')'     print *, x ! prints approx. 0.83375830214998126'
write(io,'(a)')'   end program demo_erfc_scaled'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     EVENT_QUERY(3f) - [INTRINSIC] Query whether a coarray event has occurred'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   call EVENT_QUERY(EVENT, COUNT [, STAT])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   EVENT_QUERY assigns the number of events to COUNT which have been'
write(io,'(a)')'   posted to the EVENT variable and not yet been removed by calling'
write(io,'(a)')'   EVENT_WAIT. When STAT is present and the invocation was'
write(io,'(a)')'   successful, it is assigned the value 0. If it is present and the'
write(io,'(a)')'   invocation has failed, it is assigned a positive value and COUNT is'
write(io,'(a)')'   assigned the value -1.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  EVENT  - (intent(in)) Scalar of type event_type, defined in'
write(io,'(a)')'           iso_fortran_env; shall not be coindexed.'
write(io,'(a)')'  COUNT  - (intent(out))Scalar integer with at least the precision of'
write(io,'(a)')'           default integer.'
write(io,'(a)')'  STAT   - (OPTIONAL) Scalar default-kind integer variable.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_event_query'
write(io,'(a)')'     use iso_fortran_env'
write(io,'(a)')'     implicit none'
write(io,'(a)')'     type(event_type) :: event_value_has_been_set[*]'
write(io,'(a)')'     integer :: cnt'
write(io,'(a)')'     if (this_image() == 1) then'
write(io,'(a)')'       call event_query(event_value_has_been_set, cnt)'
write(io,'(a)')'       if (cnt > 0) write(*,*) "Value has been set"'
write(io,'(a)')'     elseif (this_image() == 2) then'
write(io,'(a)')'       event post(event_value_has_been_set[1])'
write(io,'(a)')'     end if'
write(io,'(a)')'   end program demo_event_query'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[TS 18508]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Subroutine'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     execute_command_line(3f) - [INTRINSIC:SYSTEM ENVIRONMENT] Execute a shell command'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'     call execute_command_line(command [, wait, exitstat, cmdstat, cmdmsg ])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   The COMMAND argument is passed to the shell and executed. (The shell'
write(io,'(a)')'   is generally sh(1) on Unix systems, and cmd.exe on Windows.) If WAIT'
write(io,'(a)')'   is present and has the value false, the execution of the command is'
write(io,'(a)')'   asynchronous if the system supports it; otherwise, the command is'
write(io,'(a)')'   executed synchronously.'
write(io,'(a)')''
write(io,'(a)')'   The three last arguments allow the user to get status information.'
write(io,'(a)')'   After synchronous execution, EXITSTAT contains the integer exit code'
write(io,'(a)')'   of the command, as returned by SYSTEM. CMDSTAT is set to zero if the'
write(io,'(a)')'   command line was executed (whatever its exit status was). CMDMSG is'
write(io,'(a)')'   assigned an error message if an error has occurred.'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'   Note that the system call need not be thread-safe. It is the'
write(io,'(a)')'   responsibility of the user to ensure that the system is not called'
write(io,'(a)')'   concurrently if required.'
write(io,'(a)')''
write(io,'(a)')'   When the command is executed synchronously, EXECUTE_COMMAND_LINE'
write(io,'(a)')'   returns after the command line has completed execution. Otherwise,'
write(io,'(a)')'   EXECUTE_COMMAND_LINE returns without waiting.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   COMMAND   - a default CHARACTER scalar containing the command line to be'
write(io,'(a)')'               executed. The interpretation is programming-environment dependent.'
write(io,'(a)')''
write(io,'(a)')'   WAIT      - (Optional) a default LOGICAL scalar.'
write(io,'(a)')'               If WAIT is present with the value .false., and the'
write(io,'(a)')'               processor supports asynchronous execution of the command,'
write(io,'(a)')'               the command is executed asynchronously; otherwise it is'
write(io,'(a)')'               executed synchronously.'
write(io,'(a)')''
write(io,'(a)')'   EXITSTAT  - (Optional) an INTEGER of the default kind with intent(INOUT).'
write(io,'(a)')'               If the command is executed synchronously, it is'
write(io,'(a)')'               assigned the value of the processor-dependent exit'
write(io,'(a)')'               status. Otherwise, the value of EXITSTAT is unchanged.'
write(io,'(a)')''
write(io,'(a)')'   CMDSTAT   - (Optional) an INTEGER of default kind with intent(INOUT).'
write(io,'(a)')'               If an error condition occurs and CMDSTAT is not present, error'
write(io,'(a)')'               termination of execution of the image is initiated.'
write(io,'(a)')''
write(io,'(a)')'               It is assigned the value -1 if the processor does not'
write(io,'(a)')'               support command line execution, a processor-dependent'
write(io,'(a)')'               positive value if an error condition occurs, or the'
write(io,'(a)')'               value -2 if no error condition occurs but WAIT is present'
write(io,'(a)')'               with the value false and the processor does not support'
write(io,'(a)')'               asynchronous execution.Otherwise it is assigned the'
write(io,'(a)')'               value 0.'
write(io,'(a)')''
write(io,'(a)')'   CMDMSG    - (Optional) a CHARACTER scalar of the default kind.'
write(io,'(a)')'               It is an INTENT (INOUT) argument.If an error condition'
write(io,'(a)')'               occurs, it is assigned a processor-dependent explanatory'
write(io,'(a)')'               message.Otherwise, it is unchanged.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_exec'
write(io,'(a)')'     integer :: i'
write(io,'(a)')''
write(io,'(a)')'     call execute_command_line("external_prog.exe", exitstat=i)'
write(io,'(a)')'     print *, "Exit status of external_prog.exe was ", i'
write(io,'(a)')''
write(io,'(a)')'     call execute_command_line("reindex_files.exe", wait=.false.)'
write(io,'(a)')'     print *, "Now reindexing files in the background"'
write(io,'(a)')'   end program demo_exec'
write(io,'(a)')''
write(io,'(a)')'NOTE'
write(io,'(a)')''
write(io,'(a)')'   Because this intrinsic is making a system call, it is very system'
write(io,'(a)')'   dependent.Its behavior with respect to signaling is processor'
write(io,'(a)')'   dependent.In particular, on POSIX-compliant systems, the SIGINT and'
write(io,'(a)')'   SIGQUIT signals will be ignored, and the SIGCHLD will be blocked.As'
write(io,'(a)')'   such, if the parent process is terminated, the child process might'
write(io,'(a)')'   not be terminated alongside.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Subroutine'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     exp(3f) - [INTRINSIC:MATHEMATICS] Exponential function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = exp(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   exp(x) computes the base "e" exponential of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type shall be REAL or'
write(io,'(a)')'COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value has same type and kind as X.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_exp'
write(io,'(a)')'      real :: x = 1.0'
write(io,'(a)')'      x = exp(x)'
write(io,'(a)')'    end program demo_exp'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     exponent(3f) - [INTRINSIC:MODEL_COMPONENTS] Exponent function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = exponent(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   exponent(x) returns the value of the exponent part of X. If X'
write(io,'(a)')'   is zero the value returned is zero.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type shall be REAL.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type default INTEGER.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_exponent'
write(io,'(a)')'      real :: x = 1.0'
write(io,'(a)')'      integer :: i'
write(io,'(a)')'      i = exponent(x)'
write(io,'(a)')'      print *, i'
write(io,'(a)')'      print *, exponent(0.0)'
write(io,'(a)')'    end program demo_exponent'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'  EXTENDS_TYPE_OF(3f) - [INTRINSIC] True if and only if the dynamic type of A is an extension of the dynamic type o'
write(io,'(a)')''
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'  EXTENDS_TYPE_OF (A, MOLD)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'1 Description. True if and only if the dynamic type of A is an extension of the dynamic type of MOLD.'
write(io,'(a)')''
write(io,'(a)')'2 Class. Inquiry function.'
write(io,'(a)')''
write(io,'(a)')'OPTIONS'
write(io,'(a)')'  A             shall be an object of extensible type. If it is a pointer, it shall not have an undefined associati'
write(io,'(a)')'                status.'
write(io,'(a)')'  MOLD          shall be an object of extensible type. If it is a pointer, it shall not have an undefined associati'
write(io,'(a)')'                status.'
write(io,'(a)')''
write(io,'(a)')'RESULTS'
write(io,'(a)')''
write(io,'(a)')'4 Result Characteristics. Default logical scalar.'
write(io,'(a)')''
write(io,'(a)')'5 Result Value. If MOLD is unlimited polymorphic and is either a disassociated pointer or unallocated allocatable'
write(io,'(a)')'  variable, the result is true; otherwise if A is unlimited polymorphic and is either a disassociated pointer or'
write(io,'(a)')'  unallocated allocatable variable, the result is false; otherwise the result is true if and only if the dynamic ty'
write(io,'(a)')'  A is an extension type of the dynamic type of MOLD.'
write(io,'(a)')''
write(io,'(a)')'  The dynamic type of a disassociated pointer or unallocated allocatable variable is its declared type.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     float(3f) - [INTRINSIC] Convert integer to default real'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = float(a)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   float(a) converts the integer A to a default real value.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   A  - The type shall be INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type default REAL.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_float'
write(io,'(a)')'        integer :: i = 1'
write(io,'(a)')'        if (float(i) /= 1.) call abort'
write(io,'(a)')'    end program demo_float'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[dble]], [[real]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     floor(3f) - [INTRINSIC:NUMERIC] Integer floor function'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   floor(a) returns the greatest integer less than or equal to X.'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = floor(a [, kind])'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   A  - The type shall be REAL.'
write(io,'(a)')'   KIND  - (Optional) An INTEGER initialization'
write(io,'(a)')'expression indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type integer(kind) if KIND is present'
write(io,'(a)')'   and of default-kind INTEGER otherwise.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_floor'
write(io,'(a)')'        real :: x = 63.29'
write(io,'(a)')'        real :: y = -63.59'
write(io,'(a)')'        print *, floor(x) ! returns 63'
write(io,'(a)')'        print *, floor(y) ! returns -64'
write(io,'(a)')'    end program demo_floor'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[ceiling]], [[nint]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     fraction(3f) - [INTRINSIC:MODEL_COMPONENTS] Fractional part of the model representation'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   fraction(x) returns the fractional part of the model'
write(io,'(a)')'   representation of X.'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   y = fraction(x)'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type of the argument shall be a REAL.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of the same type and kind as the argument.'
write(io,'(a)')'   The fractional part of the model representation of X is returned;'
write(io,'(a)')'   it is x * radix(x)**(-exponent(x)).'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_fraction'
write(io,'(a)')'      real :: x'
write(io,'(a)')'      x = 178.1387e-4'
write(io,'(a)')'      print *, fraction(x), x * radix(x)**(-exponent(x))'
write(io,'(a)')'    end program demo_fraction'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     gamma(3f) - [INTRINSIC:MATHEMATICS] Gamma function'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   gamma(x) computes Gamma of X. For positive,'
write(io,'(a)')'   integer values of X the Gamma function simplifies to the factorial'
write(io,'(a)')'   function Gamma(x)=(x-1)!.'
write(io,'(a)')''
write(io,'(a)')'   $$'
write(io,'(a)')'   \Gamma(x) = \int_0**\infty t**{x-1}{\mathrm{e}}**{-t}\,{\mathrm{d}}t'
write(io,'(a)')'   $$'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   x = gamma(x)'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - Shall be of type REAL and neither zero'
write(io,'(a)')'        nor a negative integer.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type REAL of the same kind as X.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_gamma'
write(io,'(a)')'     real :: x = 1.0'
write(io,'(a)')'     x = gamma(x) ! returns 1.0'
write(io,'(a)')'   end program demo_gamma'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   Logarithm of the Gamma function: [[log_gamma]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     get_command(3f) - [INTRINSIC:SYSTEM ENVIRONMENT] Get the entire command line'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Retrieve the entire command line that was used to invoke the program.'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   call get_command([command, length, status])'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  COMMAND  - (Optional) shall be of type CHARACTER and of default kind.'
write(io,'(a)')'  LENGTH  - (Optional) Shall be of type INTEGER and of default kind.'
write(io,'(a)')'  STATUS  - (Optional) Shall be of type INTEGER and of default kind.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   If COMMAND is present, stores the entire command line that was used'
write(io,'(a)')'   to invoke the program in COMMAND. If LENGTH is present, it is'
write(io,'(a)')'   assigned the length of the command line. If STATUS is present, it is'
write(io,'(a)')'   assigned 0 upon success of the command, -1 if COMMAND is too short'
write(io,'(a)')'   to store the command line, or a positive value in case of an error.'
write(io,'(a)')''
write(io,'(a)')'   Note that what is typed on the command line is often processed by'
write(io,'(a)')'   a shell. The shell often processes special characters and white'
write(io,'(a)')'   space before passing it to the program. The processing can typically'
write(io,'(a)')'   be turned off by turning off globbing or quoting the command line'
write(io,'(a)')'   arguments with quote characters and/or changing the default field'
write(io,'(a)')'   separators, but this should rarely be necessary.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_get_command'
write(io,'(a)')'   implicit none'
write(io,'(a)')'   integer                      :: COMMAND_LINE_LENGTH'
write(io,'(a)')'   character(len=:),allocatable :: COMMAND_LINE'
write(io,'(a)')''
write(io,'(a)')'      ! get command line length'
write(io,'(a)')'      call get_command(length=COMMAND_LINE_LENGTH)'
write(io,'(a)')''
write(io,'(a)')'      ! allocate string big enough to hold command line'
write(io,'(a)')'      allocate(character(len=COMMAND_LINE_LENGTH) :: COMMAND_LINE)'
write(io,'(a)')''
write(io,'(a)')'      ! get command line as a string'
write(io,'(a)')'      call get_command(command=COMMAND_LINE)'
write(io,'(a)')''
write(io,'(a)')'      ! JIC:: trim leading spaces just in case'
write(io,'(a)')'      COMMAND_LINE=adjustl(COMMAND_LINE)'
write(io,'(a)')''
write(io,'(a)')'      write(*,''(a)'')COMMAND_LINE'
write(io,'(a)')''
write(io,'(a)')'   end program demo_get_command'
write(io,'(a)')''
write(io,'(a)')'  Sample execution:'
write(io,'(a)')'     ./test_get_command  arguments    on the    command   line to   echo'
write(io,'(a)')'     ./test_get_command arguments on the command line to echo'
write(io,'(a)')'     # using the bash shell'
write(io,'(a)')'     ./test_get_command  ''arguments  *><`~[]!{}?"\''| on the    command   line to   echo'''
write(io,'(a)')'     ./test_get_command arguments  *><`~[]!{}?"''| on the    command   line to   echo'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[get_command_argument]],'
write(io,'(a)')'   [[command_argument_count]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     get_command_argument(3f) - [INTRINSIC:SYSTEM ENVIRONMENT] Get command line arguments'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   call get_command_argument(number [, value, length, status])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Retrieve the NUMBER-th argument that was passed on the command line'
write(io,'(a)')'   when the containing program was invoked.'
write(io,'(a)')''
write(io,'(a)')'   There is not anything specifically stated about what an argument is but'
write(io,'(a)')'   in practice the arguments are split on whitespace unless the arguments'
write(io,'(a)')'   are quoted and IFS values (Internal Field Separators) used by common'
write(io,'(a)')'   shells are ignored.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   NUMBER  - Shall be a scalar of type integer(4), NUMBER > 0.'
write(io,'(a)')'   VALUE   - Shall be a scalar of type CHARACTER and of default kind.'
write(io,'(a)')'   LENGTH  - (Optional) Shall be a scalar of type integer(4).'
write(io,'(a)')'   STATUS  - (Optional) Shall be a scalar of type integer(4).'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   After get_command_argument returns, the VALUE argument holds the'
write(io,'(a)')'   NUMBER-th command line argument. If VALUE can not hold the argument, it is'
write(io,'(a)')'   truncated to fit the length of VALUE. If there are less than NUMBER'
write(io,'(a)')'   arguments specified at the command line, VALUE will be filled with blanks.'
write(io,'(a)')'   If NUMBER = 0, VALUE is set to the name of the program (on systems'
write(io,'(a)')'   that support this feature).'
write(io,'(a)')''
write(io,'(a)')'   The LENGTH argument contains the length of the'
write(io,'(a)')'   NUMBER-th command line argument.'
write(io,'(a)')''
write(io,'(a)')'   If the argument retrieval fails, STATUS'
write(io,'(a)')'   is a positive number; if VALUE contains a truncated command line argument,'
write(io,'(a)')'   STATUS is -1; and otherwise the STATUS is zero.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_get_command_argument'
write(io,'(a)')'   implicit none'
write(io,'(a)')'     integer :: count,i, longest, argument_length'
write(io,'(a)')'     integer,allocatable  :: istat(:), ilen(:)'
write(io,'(a)')'     character(len=:),allocatable :: arguments(:)'
write(io,'(a)')''
write(io,'(a)')'     ! get number of arguments'
write(io,'(a)')'     count = command_argument_count()'
write(io,'(a)')''
write(io,'(a)')'     ! find longest argument'
write(io,'(a)')'     longest=0'
write(io,'(a)')'     do i=0,count'
write(io,'(a)')'        call get_command_argument(number=i,length=argument_length)'
write(io,'(a)')'        longest=max(longest,argument_length)'
write(io,'(a)')'      enddo'
write(io,'(a)')''
write(io,'(a)')'     ! allocate string array big enough to hold command line'
write(io,'(a)')'    allocate(character(len=longest) :: arguments(0:count))'
write(io,'(a)')'    allocate(istat(0:count))'
write(io,'(a)')'    allocate(ilen(0:count))'
write(io,'(a)')''
write(io,'(a)')'     ! read the arguments into the array'
write(io,'(a)')'     do i=0,count'
write(io,'(a)')'       call get_command_argument(i, arguments(i),status=istat(i),length=ilen(i))'
write(io,'(a)')'     enddo'
write(io,'(a)')''
write(io,'(a)')'     ! show the results'
write(io,'(a)')'     write (*,''(i3.3,1x,i0.5,1x,i0.5,1x,"[",a,"]")'') (i,istat(i),ilen(i),arguments(i)(:ilen(i)),i=0,count)'
write(io,'(a)')''
write(io,'(a)')'   end program demo_get_command_argument'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')' Sample output:'
write(io,'(a)')''
write(io,'(a)')'   ./test_get_command_argument a    simple      test    ''of getting   arguments  '' "  from the command"'
write(io,'(a)')'   000 00000 00003 [./test_get_command_argument]'
write(io,'(a)')'   001 00000 00001 [a]'
write(io,'(a)')'   002 00000 00006 [simple]'
write(io,'(a)')'   003 00000 00004 [test]'
write(io,'(a)')'   004 00000 00024 [of getting   arguments  ]'
write(io,'(a)')'   005 00000 00018 [  from the command]'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[get_command]],'
write(io,'(a)')'   [[command_argument_count]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     get_environment_variable(3f) - [INTRINSIC:SYSTEM ENVIRONMENT] Get an environmental variable'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   call get_environment_variable(NAME[, VALUE, LENGTH, STATUS, TRIM_NAME)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Get the VALUE of the environmental variable NAME.'
write(io,'(a)')''
write(io,'(a)')'   Note that get_environment_variable need not be thread-safe. It is'
write(io,'(a)')'   the responsibility of the user to ensure that the environment is not'
write(io,'(a)')'   being updated concurrently.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   NAME       - (Optional) Shall be a scalar of type CHARACTER and of default kind.'
write(io,'(a)')'   VALUE      - (Optional) Shall be a scalar of type CHARACTER and of default kind.'
write(io,'(a)')'   LENGTH     - (Optional) Shall be a scalar of type INTEGER and of default kind.'
write(io,'(a)')'   STATUS     - (Optional) Shall be a scalar of type INTEGER and of default kind.'
write(io,'(a)')'   TRIM_NAME  - (Optional) Shall be a scalar of type LOGICAL and of default kind.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   Stores the value of NAME in VALUE.'
write(io,'(a)')'   If VALUE is not large enough to hold the data, it is truncated.'
write(io,'(a)')'   If NAME is not set, VALUE will be filled with blanks.'
write(io,'(a)')''
write(io,'(a)')'   Argument LENGTH contains the length needed for storing the environment'
write(io,'(a)')'   variable NAME or zero if it is not present.'
write(io,'(a)')''
write(io,'(a)')'   STATUS is'
write(io,'(a)')'   -1 if VALUE is present but too short for the environment variable;'
write(io,'(a)')'   it is 1 if the environment variable does not exist'
write(io,'(a)')'   and 2 if the processor does not support environment variables;'
write(io,'(a)')'   in all other cases STATUS is zero.'
write(io,'(a)')''
write(io,'(a)')'   If TRIM_NAME is present with the value .FALSE.,'
write(io,'(a)')'   the trailing blanks in NAME are significant;'
write(io,'(a)')'   otherwise they are not part of the environment variable name.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_getenv'
write(io,'(a)')'     character(len=:),allocatable :: var'
write(io,'(a)')'     character(len=:),allocatable :: homedir'
write(io,'(a)')'     integer :: howbig'
write(io,'(a)')'     var=''HOME'''
write(io,'(a)')'     ! get length required to hold value'
write(io,'(a)')'     call get_environment_variable(var, length=howbig)'
write(io,'(a)')'     ! make string to hold value of sufficient size'
write(io,'(a)')'     allocate(character(len=howbig) :: homedir)'
write(io,'(a)')'     ! get value'
write(io,'(a)')'     call get_environment_variable(var, homedir)'
write(io,'(a)')'     ! print environment variable name value'
write(io,'(a)')'     write (*,''(a,"=""",a,"""")'')var,trim(homedir)'
write(io,'(a)')'   end program demo_getenv'
write(io,'(a)')''
write(io,'(a)')'Typical Results:'
write(io,'(a)')''
write(io,'(a)')'   HOME="/home/urbanjs/V600"'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Subroutine'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     huge(3f) - [INTRINSIC] Largest number of a kind'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = huge(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   huge(x) returns the largest number that is not an infinity in'
write(io,'(a)')'   the model of the type of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - Shall be of type REAL or INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of the same type and kind as X'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_huge_tiny'
write(io,'(a)')'      print *, huge(0), huge(0.0), huge(0.0d0)'
write(io,'(a)')'      print *, tiny(0.0), tiny(0.0d0)'
write(io,'(a)')'    end program demo_huge_tiny'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     hypot(3f) - [INTRINSIC:MATHEMATICS] Euclidean distance function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = hypot(x, y)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'hypot(x,y) is the Euclidean distance function. It is equal to'
write(io,'(a)')''
write(io,'(a)')'   sqrt{X**2 + Y**2}, without undue underflow or overflow.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type shall be REAL.'
write(io,'(a)')'   Y  - The type and kind type parameter shall be the same as'
write(io,'(a)')'X.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value has the same type and kind type parameter as X.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_hypot'
write(io,'(a)')'      real(4) :: x = 1.e0_4, y = 0.5e0_4'
write(io,'(a)')'      x = hypot(x,y)'
write(io,'(a)')'    end program demo_hypot'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     iachar(3f) - [INTRINSIC:CHARACTER] Code in ASCII collating sequence'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = iachar(c [, kind])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   iachar(c) returns the code for the ASCII character'
write(io,'(a)')'   in the first character position of C.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   C  - Shall be a scalar CHARACTER, with intent(in)'
write(io,'(a)')'   KIND  - (Optional) An INTEGER initialization'
write(io,'(a)')'expression indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER and of kind KIND. If'
write(io,'(a)')'   KIND is absent, the return value is of default integer kind.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_iachar'
write(io,'(a)')'      integer i'
write(io,'(a)')'      i = iachar('' '')'
write(io,'(a)')'    end program demo_iachar'
write(io,'(a)')''
write(io,'(a)')'NOTE'
write(io,'(a)')''
write(io,'(a)')'   See [[ichar]] for a discussion of converting between numerical'
write(io,'(a)')'   values and formatted string representations.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later, with KIND argument [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[achar]], [[char]], [[ichar]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     iall(3f) - [INTRINSIC:BIT MANIPULATION] Bitwise and of array elements'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'* result = iall(array[, mask])'
write(io,'(a)')'* result = iall(array, dim[, mask])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Reduces with bitwise AND the elements of ARRAY along dimension DIM'
write(io,'(a)')'   if the corresponding element in MASK is TRUE.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  ARRAY  - Shall be an array of type INTEGER'
write(io,'(a)')'  DIM  - (Optional) shall be a scalar of type INTEGER with a value'
write(io,'(a)')'  in the range from 1 to "n", where "n" equals the rank of ARRAY.'
write(io,'(a)')'  MASK  - (Optional) shall be of type LOGICAL and either be a'
write(io,'(a)')'  scalar or an array of the same shape as ARRAY.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The result is of the same type as ARRAY.'
write(io,'(a)')''
write(io,'(a)')'   If DIM is absent, a scalar with the bitwise ALL of all elements in'
write(io,'(a)')'   ARRAY is returned. Otherwise, an array of rank "n-1", where "n" equals'
write(io,'(a)')'   the rank of ARRAY, and a shape similar to that of ARRAY with'
write(io,'(a)')'   dimension DIM dropped is returned.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_iall'
write(io,'(a)')'     integer(1) :: a(2)'
write(io,'(a)')''
write(io,'(a)')'     a(1) = b''00100100'''
write(io,'(a)')'     a(2) = b''01101010'''
write(io,'(a)')''
write(io,'(a)')'     ! prints 00100000'
write(io,'(a)')'     print ''(b8.8)'', iall(a)'
write(io,'(a)')'   end program demo_iall'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[iany]], [[iparity]], [[iand]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     iand(3f) - [INTRINSIC:BIT MANIPULATION] Bitwise logical and'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = iand(i, j)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Bitwise logical AND.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I  - The type shall be INTEGER.'
write(io,'(a)')'   J  - The type shall be INTEGER, of the same kind as I.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return type is INTEGER, of the same kind as the'
write(io,'(a)')'   arguments. (If the argument kinds differ, it is of the same kind as'
write(io,'(a)')'   the larger argument.)'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_iand'
write(io,'(a)')'      integer :: a, b'
write(io,'(a)')'      data a / z''f'' /, b / z''3'' /'
write(io,'(a)')'      write (*,*) iand(a, b)'
write(io,'(a)')'    end program demo_iand'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[ior]], [[ieor]], [[ibits]], [[ibset]], [[ibclr]],'
write(io,'(a)')'   [[not]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     iany(3f) - [INTRINSIC:BIT MANIPULATION] Bitwise or of array elements'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'* result = iany(array[, mask])'
write(io,'(a)')'* result = iany(array, dim[, mask])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Reduces with bitwise or (inclusive or) the elements of ARRAY along'
write(io,'(a)')'   dimension DIM if the corresponding element in MASK is TRUE.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  ARRAY  - Shall be an array of type INTEGER'
write(io,'(a)')'  DIM  - (Optional) shall be a scalar of type INTEGER with a value'
write(io,'(a)')'  in the range from "1" to "n", where "n" equals the rank of ARRAY.'
write(io,'(a)')'  MASK  - (Optional) shall be of type LOGICAL and either be a'
write(io,'(a)')'  scalar or an array of the same shape as ARRAY.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The result is of the same type as ARRAY.'
write(io,'(a)')''
write(io,'(a)')'   If DIM is absent, a scalar with the bitwise OR of all elements in'
write(io,'(a)')'   ARRAY is returned. Otherwise, an array of rank "n-1", where "n"'
write(io,'(a)')'   equals the rank of ARRAY, and a shape similar to that of ARRAY'
write(io,'(a)')'   with dimension DIM dropped is returned.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_iany'
write(io,'(a)')'     integer(1) :: a(2)'
write(io,'(a)')''
write(io,'(a)')'     a(1) = b''00100100'''
write(io,'(a)')'     a(2) = b''01101010'''
write(io,'(a)')''
write(io,'(a)')'     ! prints 01101110'
write(io,'(a)')'     print ''(b8.8)'', iany(a)'
write(io,'(a)')'   end program demo_iany'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[iparity]], [[iall]], [[ior]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     ibclr(3f) - [INTRINSIC:BIT MANIPULATION] Clear bit'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = ibclr(i, pos)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   IBCLR returns the value of I with the bit at position'
write(io,'(a)')'   POS set to zero.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I  - The type shall be INTEGER.'
write(io,'(a)')'   POS  - The type shall be INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER and of the same kind as I.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[ibits]], [[ibset]], [[iand]], [[ior]], [[ieor]],'
write(io,'(a)')'   [[mvbits]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     ibits(3f) - [INTRINSIC:BIT MANIPULATION] Bit extraction'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = ibits(i, pos, len)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   IBITS extracts a field of length LEN from I,'
write(io,'(a)')'   starting from bit position POS and extending left for LEN'
write(io,'(a)')'   bits. The result is right-justified and the remaining bits are'
write(io,'(a)')'   zeroed. The value of pos+len must be less than or equal to the'
write(io,'(a)')'   value bit_size(i).'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I  - The type shall be INTEGER.'
write(io,'(a)')'   POS  - The type shall be INTEGER.'
write(io,'(a)')'   LEN  - The type shall be INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'The return value is of type INTEGER and of the same kind as'
write(io,'(a)')'I.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[bit_size]], [[ibclr]], [[ibset]],'
write(io,'(a)')'   [[iand]], [[ior]], [[ieor]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     ibset(3f) - [INTRINSIC:BIT MANIPULATION] Set bit'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = ibset(i, pos)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   IBSET returns the value of I with the bit at position'
write(io,'(a)')'   POS set to one.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I  - The type shall be INTEGER.'
write(io,'(a)')'   POS  - The type shall be INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER and of the same kind as'
write(io,'(a)')'I.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[btest]], [[ibclr]], [[ibits]], [[iand]], [[ior]], [[ieor]],'
write(io,'(a)')'   [[mvbits]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     ichar(3f) - [INTRINSIC:CHARACTER] Character-to-integer conversion function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = ichar(c [, kind])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   ichar(c) returns the code for the character in the first character'
write(io,'(a)')'   position of C in the system''s native character set.'
write(io,'(a)')'   The correspondence between characters and their codes is not necessarily'
write(io,'(a)')'   the same across different GNU Fortran implementations.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   C  - Shall be a scalar CHARACTER, with intent(in)'
write(io,'(a)')'   KIND  - (Optional) An INTEGER initialization'
write(io,'(a)')'expression indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER and of kind KIND. If'
write(io,'(a)')'   KIND is absent, the return value is of default integer kind.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_ichar'
write(io,'(a)')'   implicit none'
write(io,'(a)')'   integer i'
write(io,'(a)')'      do i=0,127'
write(io,'(a)')'         call printme()'
write(io,'(a)')'      enddo'
write(io,'(a)')'   contains'
write(io,'(a)')'   subroutine printme()'
write(io,'(a)')'   character(len=1) :: letter'
write(io,'(a)')'   letter=char(i)'
write(io,'(a)')'      select case(i)'
write(io,'(a)')'       case (:31,127:)'
write(io,'(a)')'         write(*,''(1x,i0.3,1x,"HEX=",z2.2,1x,i0)'')i,letter,ichar(letter)'
write(io,'(a)')'       case default'
write(io,'(a)')'         write(*,''(1x,i0.3,1x,a,1x,i0)'')i,letter,ichar(letter)'
write(io,'(a)')'      end select'
write(io,'(a)')'   end subroutine printme'
write(io,'(a)')'   end program demo_ichar'
write(io,'(a)')''
write(io,'(a)')'NOTE'
write(io,'(a)')''
write(io,'(a)')'   No intrinsic exists to convert between a numeric value and a formatted'
write(io,'(a)')'   character string representation -- for instance, given the'
write(io,'(a)')'   CHARACTER value ''154'', obtaining an INTEGER or'
write(io,'(a)')'   REAL value with the value 154, or vice versa. Instead, this'
write(io,'(a)')'   functionality is provided by internal-file I/O, as in the following'
write(io,'(a)')'   example:'
write(io,'(a)')''
write(io,'(a)')'    program read_val'
write(io,'(a)')'      integer value'
write(io,'(a)')'      character(len=10) string, string2'
write(io,'(a)')'      string = ''154'''
write(io,'(a)')''
write(io,'(a)')'      ! Convert a string to a numeric value'
write(io,'(a)')'      read (string,''(I10)'') value'
write(io,'(a)')'      print *, value'
write(io,'(a)')''
write(io,'(a)')'      ! Convert a value to a formatted string'
write(io,'(a)')'      write (string2,''(I10)'') value'
write(io,'(a)')'      print *, string2'
write(io,'(a)')'    end program read_val'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later, with KIND argument [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[achar]], [[char]], [[iachar]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     ieor(3f) - [INTRINSIC:BIT MANIPULATION] Bitwise logical exclusive or'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = ieor(i, j)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   IEOR returns the bitwise Boolean exclusive-OR of I and J.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I  - The type shall be INTEGER.'
write(io,'(a)')'   J  - The type shall be INTEGER, of the same kind as I.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return type is INTEGER, of the same kind as the arguments. (If the'
write(io,'(a)')'   argument kinds differ, it is of the same kind as the larger argument.)'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[ior]], [[iand]], [[ibits]], [[ibset]],'
write(io,'(a)')'   [[ibclr]], [[not]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     image_index(3f) - [INTRINSIC] Cosubscript to image index conversion'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = image_index(coarray, sub)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Returns the image index belonging to a cosubscript.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   COARRAY  - Coarray of any type.'
write(io,'(a)')'   SUB      - default integer rank-1 array of a size equal to the corank of COARRAY.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   Scalar default integer with the value of the image index which'
write(io,'(a)')'   corresponds to the cosubscripts. For invalid cosubscripts the result'
write(io,'(a)')'   is zero.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   integer :: array[2,-1:4,8,*]'
write(io,'(a)')'   ! Writes  28 (or 0 if there are fewer than 28 images)'
write(io,'(a)')'   write (*,*) image_index(array, [2,0,3,1])'
write(io,'(a)')'   end'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Inquiry function.'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[this_image]], [[num_images]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     index(3f) - [INTRINSIC:CHARACTER] Position of a substring within a string'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'    index(STRING, SUBSTRING [, BACK [, KIND]]) result(START)'
write(io,'(a)')''
write(io,'(a)')'     character(len=*),intent(in) :: STRING'
write(io,'(a)')'     character(len=*),intent(in) :: SUBSTRING'
write(io,'(a)')'     logical,intent(in),optional :: bACK'
write(io,'(a)')'     integer,intent(in),optional :: KIND'
write(io,'(a)')'     integer(kind=KIND)          :: START'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Returns the position of the start of the leftmost or rightmost'
write(io,'(a)')'   occurrence of string SUBSTRING in STRING, counting from one. If'
write(io,'(a)')'   SUBSTRING is not present in STRING, zero is returned.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'* STRING       string to be searched'
write(io,'(a)')'* SUBSTRING    string to attempt to locate in STRING'
write(io,'(a)')'* BACK         If the BACK argument is present and true, the return'
write(io,'(a)')'               value is the start of the rightmost occurrence rather than the'
write(io,'(a)')'               leftmost.'
write(io,'(a)')'* KIND         An INTEGER initialization expression indicating'
write(io,'(a)')'               the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'* START        The return value is of type INTEGER and of kind KIND.'
write(io,'(a)')'               If KIND is absent, the return value is of default integer'
write(io,'(a)')'               kind.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later, with KIND argument [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'  Example program'
write(io,'(a)')''
write(io,'(a)')'   program demo_index'
write(io,'(a)')'                                     !1234567890123456789012345678901234567890'
write(io,'(a)')'   character(len=*),parameter :: str=''Search this string for this expression'''
write(io,'(a)')'      write(*,*)index(str,''this'').eq.8,              &'
write(io,'(a)')'                index(str,''this'',back=.true.).eq.24, &'
write(io,'(a)')'                ! INDEX is case-sensitive'
write(io,'(a)')'                index(str,''This'').eq.0'
write(io,'(a)')'   end program demo_index'
write(io,'(a)')''
write(io,'(a)')'  Expected Results:'
write(io,'(a)')''
write(io,'(a)')'   T T T'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[scan]], [[verify]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     int(3f) - [INTRINSIC:NUMERIC] Convert to integer type'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = int(a [, kind))'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'Convert to integer type'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   A     - Shall be of type INTEGER,'
write(io,'(a)')'           REAL, or COMPLEX.'
write(io,'(a)')'   KIND  - (Optional) An INTEGER initialization'
write(io,'(a)')'           expression indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   These functions return a INTEGER variable or array under'
write(io,'(a)')'   the following rules:'
write(io,'(a)')''
write(io,'(a)')'    1. If A is of type INTEGER, int(a) = a'
write(io,'(a)')''
write(io,'(a)')'    2. If A is of type REAL and |a| < 1, int(a) equals 0.'
write(io,'(a)')'       If |a| >= 1, then int(a) equals the largest integer that'
write(io,'(a)')'       does not exceed the range of A and whose sign is the same as the'
write(io,'(a)')'       sign of A.'
write(io,'(a)')''
write(io,'(a)')'    3. If A is of type COMPLEX, rule 2 is applied to the real part of A.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_int'
write(io,'(a)')'      integer :: i = 42'
write(io,'(a)')'      complex :: z = (-3.7, 1.0)'
write(io,'(a)')'      print *, int(i)'
write(io,'(a)')'      print *, int(z), int(z,8)'
write(io,'(a)')'    end program demo_int'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     ior(3f) - [INTRINSIC:BIT MANIPULATION] Bitwise logical inclusive or'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = ior(i, j)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   IOR returns the bitwise Boolean inclusive-OR of I and J.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I  - The type shall be INTEGER.'
write(io,'(a)')'   J  - The type shall be INTEGER, of the same kind as I.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return type is INTEGER, of the same kind as the arguments. (If the'
write(io,'(a)')'   argument kinds differ, it is of the same kind as the larger argument.)'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[ieor]], [[iand]], [[ibits]], [[ibset]],'
write(io,'(a)')'   [[ibclr]], [[not]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     iparity(3f) - [INTRINSIC:BIT MANIPULATION] Bitwise exclusive or of array elements'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'* result = iparity(array[, mask])'
write(io,'(a)')'* result = iparity(array, dim[, mask])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Reduces with bitwise XOR (exclusive OR) the elements of ARRAY'
write(io,'(a)')'   along dimension DIM if the corresponding element in MASK is'
write(io,'(a)')'   TRUE.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   ARRAY  - Shall be an array of type INTEGER'
write(io,'(a)')'   DIM    - (Optional) shall be a scalar of type INTEGER with a value'
write(io,'(a)')'            in the range from "1" to "n", where "n" equals the rank of ARRAY.'
write(io,'(a)')'   MASK   - (Optional) shall be of type LOGICAL and either be a'
write(io,'(a)')'            scalar or an array of the same shape as ARRAY.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The result is of the same type as ARRAY.'
write(io,'(a)')''
write(io,'(a)')'   If DIM is absent, a scalar with the bitwise XOR of all elements in'
write(io,'(a)')'   ARRAY is returned. Otherwise, an array of rank "n-1", where "n" equals'
write(io,'(a)')'   the rank of ARRAY, and a shape similar to that of ARRAY with'
write(io,'(a)')'   dimension DIM dropped is returned.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_iparity'
write(io,'(a)')'     integer, dimension(2) :: a'
write(io,'(a)')''
write(io,'(a)')'     a(1) = b''00100100'''
write(io,'(a)')'     a(2) = b''01101010'''
write(io,'(a)')''
write(io,'(a)')'     ! prints 01001110'
write(io,'(a)')'     print ''(b8.8)'', iparity(a)'
write(io,'(a)')'   end program demo_iparity'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[iany]], [[iall]], [[ieor]], [[parity]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'   FINDLOC(3f) - [INTRINSIC] Location of the first element of ARRAY identified by MASK along dimension DIM having a'
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'  FINDLOC (ARRAY, VALUE, DIM [, MASK, KIND, BACK])'
write(io,'(a)')''
write(io,'(a)')'  or'
write(io,'(a)')''
write(io,'(a)')'  FINDLOC (ARRAY, VALUE [, MASK, KIND, BACK])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'  Location of the first element of ARRAY identified by MASK along dimension DIM having a value'
write(io,'(a)')'  equal to VALUE.'
write(io,'(a)')''
write(io,'(a)')'  Class. Transformational function.'
write(io,'(a)')''
write(io,'(a)')'  If both ARRAY and VALUE are of type logical, the comparison is performed with the .EQV. operator; otherwise,'
write(io,'(a)')'  the comparison is performed with the == operator. If the value of the comparison is true, that element of ARRAY'
write(io,'(a)')'  matches VALUE.'
write(io,'(a)')''
write(io,'(a)')'  If only one element matches VALUE, that element''s subscripts are returned. Otherwise, if more than one element'
write(io,'(a)')'  matches VALUE and BACK is absent or present with the value false, the element whose subscripts are returned'
write(io,'(a)')'  is the first such element, taken in array element order. If BACK is present with the value true, the element whos'
write(io,'(a)')'  subscripts are returned is the last such element, taken in array element order.'
write(io,'(a)')''
write(io,'(a)')'OPTIONS'
write(io,'(a)')''
write(io,'(a)')'  ARRAY       shall be an array of intrinsic type.'
write(io,'(a)')'  VALUE       shall be scalar and in type conformance with ARRAY, as specified in Table 7.3 for relational intrinsi'
write(io,'(a)')'              operations 7.1.5.5.2).'
write(io,'(a)')'  DIM         shall be an integer scalar with a value in the range 1 DIM n, where n is the rank of ARRAY.'
write(io,'(a)')'              The corresponding actual argument shall not be an optional dummy argument.'
write(io,'(a)')'  MASK        (optional) shall be of type logical and shall be conformable with ARRAY.'
write(io,'(a)')'  KIND        (optional) shall be a scalar integer initialization expression.'
write(io,'(a)')'  BACK        (optional) shall be a logical scalar.'
write(io,'(a)')''
write(io,'(a)')'RESULT'
write(io,'(a)')''
write(io,'(a)')'4 Result Characteristics. Integer. If KIND is present, the kind type parameter is that specified by the value of'
write(io,'(a)')'  KIND; otherwise the kind type parameter is that of default integer type. If DIM does not appear, the result is'
write(io,'(a)')'  an array of rank one and of size equal to the rank of ARRAY; otherwise, the result is of rank n - 1 and shape'
write(io,'(a)')'  [d1 , d2 , . . . , dDIM-1 , dDIM+1 , . . . , dn ], where [d1 , d2 , . . . , dn ] is the shape of ARRAY.'
write(io,'(a)')''
write(io,'(a)')'5 Result Value.'
write(io,'(a)')'  Case (i):     The result of FINDLOC (ARRAY, VALUE) is a rank-one array whose element values are the values'
write(io,'(a)')'                of the subscripts of an element of ARRAY whose value matches VALUE. If there is such a value,'
write(io,'(a)')'                the ith subscript returned lies in the range 1 to ei , where ei is the extent of the ith dimension'
write(io,'(a)')'                ARRAY. If no elements match VALUE or ARRAY has size zero, all elements of the result are zero.'
write(io,'(a)')'  Case (ii):    The result of FINDLOC (ARRAY, VALUE, MASK = MASK) is a rank-one array whose element'
write(io,'(a)')'                values are the values of the subscripts of an element of ARRAY, corresponding to a true element of'
write(io,'(a)')'                MASK, whose value matches VALUE. If there is such a value, the ith subscript returned lies in the'
write(io,'(a)')'                range 1 to ei , where ei is the extent of the ith dimension of ARRAY. If no elements match VALUE,'
write(io,'(a)')'                ARRAY has size zero, or every element of MASK has the value false, all elements of the result are'
write(io,'(a)')'                zero.'
write(io,'(a)')'  Case (iii):   If ARRAY has rank one, the result of'
write(io,'(a)')''
write(io,'(a)')'                  FINDLOC (ARRAY, VALUE, DIM=DIM [, MASK = MASK])'
write(io,'(a)')''
write(io,'(a)')'                is a scalar whose value is equal to that of the first element of'
write(io,'(a)')''
write(io,'(a)')'                  FINDLOC (ARRAY, VALUE [, MASK = MASK])'
write(io,'(a)')''
write(io,'(a)')'                . Otherwise, the value'
write(io,'(a)')''
write(io,'(a)')'                of element (s1 , s2 , . . . , sDIM-1 , sDIM+1 , . . . , sn ) of the result is equal to'
write(io,'(a)')''
write(io,'(a)')'                   FINDLOC (ARRAY (s1, s2, ..., sDIM-1, :, sDIM+1, ..., sn ), &'
write(io,'(a)')'                   VALUE, DIM=1 [, MASK = MASK (s1, s2, ..., sDIM-1, :, sDIM+1 ,... , sn )]).'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'  Case (i):     The value of'
write(io,'(a)')''
write(io,'(a)')'                  FINDLOC ([2, 6, 4, 6,], VALUE = 6)'
write(io,'(a)')''
write(io,'(a)')'                is [2], and the value of'
write(io,'(a)')''
write(io,'(a)')'                  FINDLOC ([2, 6, 4, 6], VALUE = 6, BACK = .TRUE.)'
write(io,'(a)')''
write(io,'(a)')'                is [4].'
write(io,'(a)')''
write(io,'(a)')'                                       0 -5 7 7                                  T T F T'
write(io,'(a)')'  Case (ii):    If A has the value 3 4 -1 2 , and M has the value T T F T , FINDLOC (A, 7,'
write(io,'(a)')'                                       1 5     6 7                               T T F T'
write(io,'(a)')'                MASK = M) has the value [1, 4] and FINDLOC (A, 7, MASK = M, BACK = .TRUE.) has the'
write(io,'(a)')'                value [3, 4]. This is independent of the declared lower bounds for A.'
write(io,'(a)')'  Case (iii):   The value of FINDLOC ([2, 6, 4], VALUE = 6, DIM = 1) is 2. If B has the value'
write(io,'(a)')'                  1 2 -9'
write(io,'(a)')'                              , FINDLOC (B, VALUE = 2, DIM = 1) has the value [2, 1, 0] and FINDLOC (B,'
write(io,'(a)')'                  2 2 6'
write(io,'(a)')'                VALUE = 2, DIM = 2) has the value [2, 1]. This is independent of the declared lower bounds for B.'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     is_contiguous(3f) - [INTRINSIC:ARRAY INQUIRY] test if object is contiguous'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'    result = is_contiguous(A)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   True if and only if an object is contiguous.'
write(io,'(a)')''
write(io,'(a)')'   An object is contiguous if it is'
write(io,'(a)')'      (1)     an object with the CONTIGUOUS attribute,'
write(io,'(a)')'      (2)     a nonpointer whole array that is not assumed-shape,'
write(io,'(a)')'      (3)     an assumed-shape array that is argument associated with an array that is contiguous,'
write(io,'(a)')'      (4)     an array allocated by an ALLOCATE statement,'
write(io,'(a)')'      (5)     a pointer associated with a contiguous target, or'
write(io,'(a)')'      (6)     a nonzero-sized array section provided that'
write(io,'(a)')'          (a)   its base object is contiguous,'
write(io,'(a)')'          (b)   it does not have a vector subscript,'
write(io,'(a)')'          (c)   the elements of the section, in array element order, are a subset of the base object elements'
write(io,'(a)')'                that are consecutive in array element order,'
write(io,'(a)')'          (d)   if the array is of type character and a substring-range appears, the substring-range specifies all'
write(io,'(a)')'                of the characters of the parent-string,'
write(io,'(a)')'          (e)   only its final part-ref has nonzero rank, and'
write(io,'(a)')'          (f)   it is not the real or imaginary part of an array of type complex.'
write(io,'(a)')''
write(io,'(a)')'   An object is not contiguous if it is an array subobject, and'
write(io,'(a)')''
write(io,'(a)')'      o the object has two or more elements,'
write(io,'(a)')'      o the elements of the object in array element order are not consecutive in the elements of the base object,'
write(io,'(a)')'      o the object is not of type character with length zero, and'
write(io,'(a)')'      o the object is not of a derived type that has no ultimate components other than zero-sized arrays and'
write(io,'(a)')'      o characters with length zero.'
write(io,'(a)')''
write(io,'(a)')'   It is processor-dependent whether any other object is contiguous.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'    A         may be of any type. It shall be an array. If it is a'
write(io,'(a)')'              pointer it shall be associated.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'    Result    of type Default logical scalar.'
write(io,'(a)')'              The result has the value true if A is contiguous, and false otherwise.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_is_contiguous'
write(io,'(a)')'   implicit none'
write(io,'(a)')'   intrinsic, is_contiguous'
write(io,'(a)')'   REAL, DIMENSION (1000, 1000), TARGET :: A'
write(io,'(a)')'   REAL, DIMENSION (:, :), POINTER       :: IN, OUT'
write(io,'(a)')'   IN => A              ! Associate IN with target A'
write(io,'(a)')'   OUT => A(1:1000:2,:) ! Associate OUT with subset of target A'
write(io,'(a)')'   !'
write(io,'(a)')'   write(*,*)''IN is '',IS_CONTIGUOUS(IN)'
write(io,'(a)')'   write(*,*)''OUT is '',IS_CONTIGUOUS(OUT)'
write(io,'(a)')'   !'
write(io,'(a)')'   end program demo_is_contiguous'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     is_iostat_end(3f) - [INTRINSIC] Test for end-of-file value'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'   result = is_iostat_end(i)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   is_iostat_end tests whether an variable has the value of the I/O'
write(io,'(a)')'   status "end of file". The function is equivalent to comparing the'
write(io,'(a)')'   variable with the iostat_end parameter of the intrinsic module'
write(io,'(a)')'   [[iso_fortran_env]].'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')'   I  - Shall be of the type INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')'   Returns a LOGICAL of the default kind, which .true. if'
write(io,'(a)')'   I has the value which indicates an end of file condition for'
write(io,'(a)')'   IOSTAT= specifiers, and is .false. otherwise.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_iostat'
write(io,'(a)')'      implicit none'
write(io,'(a)')'      integer :: stat, i'
write(io,'(a)')'      open(88, file=''test.dat'')'
write(io,'(a)')'      read(88, *, iostat=stat) i'
write(io,'(a)')'      if(is_iostat_end(stat)) stop ''end of file'''
write(io,'(a)')'    end program demo_iostat'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')'   [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     is_iostat_eor(3f) - [INTRINSIC] Test for end-of-record value'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = is_iostat_eor(i)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   is_iostat_eor tests whether an variable has the value of the I/O'
write(io,'(a)')'   status "end of record". The function is equivalent to comparing the'
write(io,'(a)')'   variable with the iostat_eor parameter of the intrinsic module'
write(io,'(a)')'   [[iso_fortran_env]].'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I  - Shall be of the type INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   Returns a LOGICAL of the default kind, which .true. if'
write(io,'(a)')'   I has the value which indicates an end of file condition for'
write(io,'(a)')'   iostat= specifiers, and is .false. otherwise.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_is_iostat_eor'
write(io,'(a)')'      implicit none'
write(io,'(a)')'      integer :: stat, i(50)'
write(io,'(a)')'      open(88, file=''test.dat'', form=''unformatted'')'
write(io,'(a)')'      read(88, iostat=stat) i'
write(io,'(a)')'      if(is_iostat_eor(stat)) stop ''end of record'''
write(io,'(a)')'    end program demo_is_iostat_eor'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'Fortran 2003 and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Elemental function'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     ishft(3f) - [INTRINSIC:BIT MANIPULATION] Shift bits'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = ishft(i, shift)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   ISHFT returns a value corresponding to I with all of the'
write(io,'(a)')'   bits shifted SHIFT places. A value of SHIFT greater than'
write(io,'(a)')'   zero corresponds to a left shift, a value of zero corresponds to no'
write(io,'(a)')'   shift, and a value less than zero corresponds to a right shift. If the'
write(io,'(a)')'   absolute value of SHIFT is greater than bit_size(i), the'
write(io,'(a)')'   value is undefined. Bits shifted out from the left end or right end are'
write(io,'(a)')'   lost; zeros are shifted in from the opposite end.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I  - The type shall be INTEGER.'
write(io,'(a)')'   SHIFT  - The type shall be INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER and of the same kind as I.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[ishftc]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     ishftc(3f) - [INTRINSIC:BIT MANIPULATION] Shift bits circularly'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = ishftc(i, shift [, size])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   ISHFTC returns a value corresponding to I with the'
write(io,'(a)')'   rightmost SIZE bits shifted circularly SHIFT places; that'
write(io,'(a)')'   is, bits shifted out one end are shifted into the opposite end. A value'
write(io,'(a)')'   of SHIFT greater than zero corresponds to a left shift, a value of'
write(io,'(a)')'   zero corresponds to no shift, and a value less than zero corresponds to'
write(io,'(a)')'   a right shift. The absolute value of SHIFT must be less than'
write(io,'(a)')'   SIZE. If the SIZE argument is omitted, it is taken to be'
write(io,'(a)')'   equivalent to bit_size(i).'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I      - The type shall be INTEGER.'
write(io,'(a)')'   SHIFT  - The type shall be INTEGER.'
write(io,'(a)')'   SIZE   - (Optional) The type shall be INTEGER;'
write(io,'(a)')'            the value must be greater than zero and less than or equal to'
write(io,'(a)')'            bit_size(i).'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER and of the same kind as I.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[ishft]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'   IS_IOSTAT_END(3f) - [INTRINSIC] True if and only if a value indicates an end-of-file condition.'
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'    logical IS_IOSTAT_END (I)'
write(io,'(a)')'    integer,intent(in) :: I'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   True if and only if a value indicates an end-of-file condition'
write(io,'(a)')''
write(io,'(a)')'ARGUMENT'
write(io,'(a)')'   I     integer status value obtained from READ(3f)'
write(io,'(a)')''
write(io,'(a)')'RESULT'
write(io,'(a)')'   A default logical value is returned.'
write(io,'(a)')'   The result has the value true if and only if I is a value for the'
write(io,'(a)')'   scalar-int-variable in an IOSTAT= specifier that would'
write(io,'(a)')'   indicate an end-of-file condition.'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')'   Elemental function.'
write(io,'(a)')'NAME'
write(io,'(a)')'   IS_IOSTAT_EOR(3f) - [INTRINSIC] True if and only if a value indicates an end-of-record condition.'
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'   logical IS_IOSTAT_EOR (I)'
write(io,'(a)')''
write(io,'(a)')'    integer,intent(in) :: I'
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   True if and only if a value indicates an end-of-record condition.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENT'
write(io,'(a)')'   I    shall be of type integer.'
write(io,'(a)')''
write(io,'(a)')'RESULT'
write(io,'(a)')'   Default logical. The result has the value true if and only if I is'
write(io,'(a)')'   a value for the scalar-int-variable in an IOSTAT= specifier'
write(io,'(a)')'   that would indicate an end-of-record condition.'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')'   Elemental function.'
write(io,'(a)')'NAME'
write(io,'(a)')'     kind(3f) - [INTRINSIC] Kind of an entity'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'   k = kind(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   kind(x) returns the kind value of the entity X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')'   X  - Shall be of type LOGICAL, INTEGER,'
write(io,'(a)')'        REAL, COMPLEX or CHARACTER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')'   The return value is a scalar of type INTEGER and of the default'
write(io,'(a)')'   integer kind.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_kind'
write(io,'(a)')'      integer,parameter :: kc = kind('' '')'
write(io,'(a)')'      integer,parameter :: kl = kind(.true.)'
write(io,'(a)')''
write(io,'(a)')'    print *, "The default character kind is ", kc'
write(io,'(a)')'      print *, "The default logical kind is ", kl'
write(io,'(a)')'    end program demo_kind'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     lbound(3f) - [INTRINSIC:ARRAY INQUIRY] Lower dimension bounds of an array'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'   result = lbound(array [, dim [, kind]])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   Returns the lower bounds of an array, or a single lower bound'
write(io,'(a)')'   along the DIM dimension.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')'   ARRAY  - Shall be an array, of any type.'
write(io,'(a)')'   DIM    - (Optional) Shall be a scalar INTEGER.'
write(io,'(a)')'   KIND   - (Optional) An INTEGER initialization'
write(io,'(a)')'            expression indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')'   The return value is of type INTEGER and of kind KIND. If'
write(io,'(a)')'   KIND is absent, the return value is of default integer kind.'
write(io,'(a)')'   If DIM is absent, the result is an array of the lower bounds of'
write(io,'(a)')'   ARRAY. If DIM is present, the result is a scalar'
write(io,'(a)')'   corresponding to the lower bound of the array along that dimension. If'
write(io,'(a)')'   ARRAY is an expression rather than a whole array or array'
write(io,'(a)')'   structure component, or if it has a zero extent along the relevant'
write(io,'(a)')'   dimension, the lower bound is taken to be 1.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')'   [[Fortran 95]] and later, with KIND argument [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')'   [[ubound]], [[co_lbound]]'
write(io,'(a)')'NAME'
write(io,'(a)')'     CO_LBOUND(3f) - [INTRINSIC] Lower codimension bounds of an array'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'   result = CO_LBOUND(coarray [, dim [, kind]])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   Returns the lower bounds of a coarray, or a single lower cobound'
write(io,'(a)')'   along the DIM codimension.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')'  ARRAY  - Shall be an coarray, of any type.'
write(io,'(a)')'  DIM  - (Optional) Shall be a scalar INTEGER.'
write(io,'(a)')'  KIND  - (Optional) An INTEGER initialization expression'
write(io,'(a)')'  indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')'   The return value is of type INTEGER and of kind KIND. If KIND is'
write(io,'(a)')'   absent, the return value is of default integer kind. If DIM is'
write(io,'(a)')'   absent, the result is an array of the lower cobounds of COARRAY. If'
write(io,'(a)')'   DIM is present, the result is a scalar corresponding to the lower'
write(io,'(a)')'   cobound of the array along that codimension.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')'   Inquiry function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')'   [[co_ubound]], [[lbound]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     leadz(3f) - [INTRINSIC:BIT INQUIRY] Number of leading zero bits of an integer'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'   result = leadz(i)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   LEADZ returns the number of leading zero bits of an integer.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')'   I  - Shall be of type INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')'   The type of the return value is the default INTEGER.'
write(io,'(a)')'   If all the bits of I are zero, the result value is bit_size(i).'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_leadz'
write(io,'(a)')'      write (*,*) leadz(1)  ! prints 8 if bitsize(i) has the value 32'
write(io,'(a)')'    end program demo_leadz'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')'   [[bit_size]], [[popcnt]], [[poppar]], [[trailz]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     len(3f) - [INTRINSIC:CHARACTER] Length of a character entity'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'   l = len(string [, kind])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   Returns the length of a character string. If STRING is an array,'
write(io,'(a)')'   the length of an element of STRING is returned. Note that'
write(io,'(a)')'   STRING need not be defined when this intrinsic is invoked, since'
write(io,'(a)')'   only the length, not the content, of STRING is needed.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')'   STRING  - Shall be a scalar or array of type'
write(io,'(a)')'             CHARACTER, with intent(in)'
write(io,'(a)')'   KIND  - (Optional) An INTEGER initialization'
write(io,'(a)')'           expression indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')'   The return value is of type INTEGER and of kind KIND. If'
write(io,'(a)')'   KIND is absent, the return value is of default integer kind.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')'   [[FORTRAN 77]] and later, with KIND argument [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')'   [[len_trim]], [[adjustl]], [[adjustr]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     len_trim(3f) - [INTRINSIC:CHARACTER] Length of a character entity without trailing blank characters'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'   result = len_trim(string [, kind])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   Returns the length of a character string, ignoring any trailing blanks.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')'   STRING  - Shall be a scalar of type CHARACTER,'
write(io,'(a)')'             with intent(in)'
write(io,'(a)')'   KIND    - (Optional) An INTEGER initialization'
write(io,'(a)')'             expression indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')'   The return value is of type INTEGER and of kind KIND. If'
write(io,'(a)')'   KIND is absent, the return value is of default integer kind.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')'   [[Fortran 95]] and later, with KIND argument [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')'   [[len]], [[adjustl]], [[adjustr]]'
write(io,'(a)')'NAME'
write(io,'(a)')'     lge(3f) - [INTRINSIC:CHARACTER] Lexical greater than or equal'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'   result = lge(string_a, string_b)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   Determines whether one string is lexically greater than or equal to'
write(io,'(a)')'   another string, where the two strings are interpreted as containing'
write(io,'(a)')'   ASCII character codes. If the String A and String B are not the same'
write(io,'(a)')'   length, the shorter is compared as if spaces were appended to it to form'
write(io,'(a)')'   a value that has the same length as the longer.'
write(io,'(a)')''
write(io,'(a)')'   In general, the lexical comparison intrinsics LGE, LGT,'
write(io,'(a)')'   LLE, and LLT differ from the corresponding intrinsic'
write(io,'(a)')'   operators .ge., .gt., .le., and .lt., in'
write(io,'(a)')'   that the latter use the processor''s character ordering (which is not'
write(io,'(a)')'   ASCII on some targets), whereas the former always use the ASCII'
write(io,'(a)')'   ordering.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')'   string_a  - Shall be of default CHARACTER type.'
write(io,'(a)')'   string_b  - Shall be of default CHARACTER type.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')'   Returns .true. if string_a >= string_b, and .false.'
write(io,'(a)')'   otherwise, based on the ASCII ordering.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')'   [[lgt]], [[lle]], [[llt]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     lgt(3f) - [INTRINSIC:CHARACTER] Lexical greater than'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'   result = lgt(string_a, string_b)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   Determines whether one string is lexically greater than another string,'
write(io,'(a)')'   where the two strings are interpreted as containing ASCII character'
write(io,'(a)')'   codes. If the String A and String B are not the same length, the'
write(io,'(a)')'   shorter is compared as if spaces were appended to it to form a value'
write(io,'(a)')'   that has the same length as the longer.'
write(io,'(a)')''
write(io,'(a)')'   In general, the lexical comparison intrinsics LGE, LGT,'
write(io,'(a)')'   LLE, and LLT differ from the corresponding intrinsic'
write(io,'(a)')'   operators .ge., .gt., .le., and .lt., in'
write(io,'(a)')'   that the latter use the processor''s character ordering (which is not'
write(io,'(a)')'   ASCII on some targets), whereas the former always use the ASCII'
write(io,'(a)')'   ordering.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')'   string_a  - Shall be of default CHARACTER type.'
write(io,'(a)')'   string_b  - Shall be of default CHARACTER type.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')'   Returns .true. if string_a > string_b, and .false.'
write(io,'(a)')'   otherwise, based on the ASCII ordering.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')'   [[lge]], [[lle]], [[llt]]'
write(io,'(a)')'NAME'
write(io,'(a)')'     lle(3f) - [INTRINSIC:CHARACTER] Lexical less than or equal'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'   result = lle(string_a, string_b)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   Determines whether one string is lexically less than or equal to another'
write(io,'(a)')'   string, where the two strings are interpreted as containing ASCII'
write(io,'(a)')'   character codes. If the String A and String B are not the same length,'
write(io,'(a)')'   the shorter is compared as if spaces were appended to it to form a value'
write(io,'(a)')'   that has the same length as the longer.'
write(io,'(a)')''
write(io,'(a)')'   In general, the lexical comparison intrinsics LGE, LGT,'
write(io,'(a)')'   LLE, and LLT differ from the corresponding intrinsic'
write(io,'(a)')'   operators .ge., .gt., .le., and .lt., in'
write(io,'(a)')'   that the latter use the processor''s character ordering (which is not'
write(io,'(a)')'   ASCII on some targets), whereas the former always use the ASCII'
write(io,'(a)')'   ordering.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')'   string_a  - Shall be of default CHARACTER type.'
write(io,'(a)')'   string_b  - Shall be of default CHARACTER type.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')'   Returns .true. if string_a < string_b, and .false.'
write(io,'(a)')'   otherwise, based on the ASCII ordering.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')'   [[lge]], [[lgt]], [[llt]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     llt(3f) - [INTRINSIC:CHARACTER] Lexical less than'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'   result = llt(string_a, string_b)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   Determines whether one string is lexically less than another string,'
write(io,'(a)')'   where the two strings are interpreted as containing ASCII character'
write(io,'(a)')'   codes. If the String A and String B are not the same length, the'
write(io,'(a)')'   shorter is compared as if spaces were appended to it to form a value'
write(io,'(a)')'   that has the same length as the longer.'
write(io,'(a)')''
write(io,'(a)')'   In general, the lexical comparison intrinsics LGE, LGT,'
write(io,'(a)')'   LLE, and LLT differ from the corresponding intrinsic'
write(io,'(a)')'   operators .ge., .gt., .le., and .lt., in'
write(io,'(a)')'   that the latter use the processor''s character ordering (which is not'
write(io,'(a)')'   ASCII on some targets), whereas the former always use the ASCII'
write(io,'(a)')'   ordering.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')'   string_a  - Shall be of default CHARACTER type.'
write(io,'(a)')'   string_b  - Shall be of default CHARACTER type.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')'   Returns .true. if string_a <= string_b, and .false.'
write(io,'(a)')'   otherwise, based on the ASCII ordering.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')'   [[lge]], [[lgt]], [[lle]]'
write(io,'(a)')'NAME'
write(io,'(a)')'     LOG(3f) - [INTRINSIC:MATHEMATICS] Logarithm function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'   result = LOG(X)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   LOG(X) computes the natural logarithm of X, i.e. the logarithm to the base "e".'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')'   X  - The type shall be REAL or COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')'   The return value is of type REAL or COMPLEX.'
write(io,'(a)')'   The kind type parameter is the same as X.'
write(io,'(a)')'   If X is COMPLEX, the imaginary part OMEGA is in the range'
write(io,'(a)')''
write(io,'(a)')'   -PI < OMEGA <= PI.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_log'
write(io,'(a)')'     real :: x = 2.7182818284590451_8'
write(io,'(a)')'     complex :: z = (1.0, 2.0)'
write(io,'(a)')'     x = log(x)    ! will yield (approximately) 1'
write(io,'(a)')'     z = log(z)'
write(io,'(a)')'   end program demo_log'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     LOG10(3f) - [INTRINSIC:MATHEMATICS] Base 10 logarithm function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'   result = LOG10(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   LOG10(X) computes the base 10 logarithm of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')'   X  - The type shall be REAL.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')'   The return value is of type REAL or COMPLEX.'
write(io,'(a)')'   The kind type parameter is the same as X.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_log10'
write(io,'(a)')'      real(8) :: x = 10.0_8'
write(io,'(a)')'      x = log10(x)'
write(io,'(a)')'    end program demo_log10'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')'NAME'
write(io,'(a)')'     log_gamma(3f) - [INTRINSIC:MATHEMATICS] Logarithm of the Gamma function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'x = log_gamma(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   log_gamma(x) computes the natural logarithm of the absolute value of the [[Gamma function]].'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - Shall be of type REAL and neither zero nor a negative integer.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type REAL of the same kind as X.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_log_gamma'
write(io,'(a)')'     real :: x = 1.0'
write(io,'(a)')'     x = log_gamma(x) ! returns 0.0'
write(io,'(a)')'   end program demo_log_gamma'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'Gamma function: [[gamma]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     logical(3f) - [INTRINSIC:BIT MANIPULATION] Bitwise logical and'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = logical(l [, kind])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Converts one kind of LOGICAL variable to another.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   L  - The type shall be LOGICAL.'
write(io,'(a)')'   KIND  - (Optional) An INTEGER initialization'
write(io,'(a)')'expression indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is a LOGICAL value equal to L, with a'
write(io,'(a)')'   kind corresponding to KIND, or of the default logical kind if'
write(io,'(a)')'   KIND is not given.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[int]], [[real]], [[cmplx]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     maskl(3f) - [INTRINSIC] Left justified mask'
write(io,'(a)')''
write(io,'(a)')'   result = maskl(i[, kind])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   maskl(i[, kind]) has its leftmost I bits set to 1, and the'
write(io,'(a)')'   remaining bits set to 0.'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I  - Shall be of type INTEGER.'
write(io,'(a)')'   KIND  - Shall be a scalar constant expression of type INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER. If KIND is present, it'
write(io,'(a)')'   specifies the kind value of the return type; otherwise, it is of the'
write(io,'(a)')'   default integer kind.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[maskr]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     maskr(3f) - [INTRINSIC] Right justified mask'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = maskr(i[, kind])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   maskr(i[, kind]) has its rightmost I bits set to 1, and the'
write(io,'(a)')'   remaining bits set to 0.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I  - Shall be of type INTEGER.'
write(io,'(a)')'   KIND  - Shall be a scalar constant expression of type INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER. If KIND is present, it'
write(io,'(a)')'   specifies the kind value of the return type; otherwise, it is of the'
write(io,'(a)')'   default integer kind.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[maskl]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     matmul(3f) - [INTRINSIC:TRANSFORMATIONAL FUNCTION] matrix multiplication'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = matmul(matrix_a, matrix_b)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Performs a matrix multiplication on numeric or logical arguments.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   matrix_a  - An array of INTEGER,'
write(io,'(a)')'               REAL, COMPLEX, or LOGICAL type, with a rank of'
write(io,'(a)')'               one or two.'
write(io,'(a)')'   matrix_b  - An array of INTEGER,'
write(io,'(a)')'               REAL, or COMPLEX type if matrix_a is of a numeric'
write(io,'(a)')'               type; otherwise, an array of LOGICAL type. The rank shall be one'
write(io,'(a)')'               or two, and the first (or only) dimension of matrix_b shall be'
write(io,'(a)')'               equal to the last (or only) dimension of matrix_a.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'The matrix product of matrix_a and matrix_b. The type and'
write(io,'(a)')'kind of the result follow the usual type and kind promotion rules, as'
write(io,'(a)')'for the * or .and. operators.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     max(3f) - [INTRINSIC:NUMERIC] Maximum value of an argument list'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = max(a1, a2 [, a3 [, ...]])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Returns the argument with the largest (most positive) value.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   A1        - The type shall be INTEGER or'
write(io,'(a)')'REAL.'
write(io,'(a)')'   A2, A3, ... - An expression of the same type and kind'
write(io,'(a)')'as A1.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value corresponds to the maximum value among the arguments,'
write(io,'(a)')'   and has the same type and kind as the first argument.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[maxloc]] [[maxval]], [[min]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     maxexponent(3f) - [INTRINSIC] Maximum exponent of a real kind'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = maxexponent(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   maxexponent(x) returns the maximum exponent in the model of the'
write(io,'(a)')'   type of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - Shall be of type REAL.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER and of the default integer'
write(io,'(a)')'   kind.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_maxexponent'
write(io,'(a)')'      real(kind=4) :: x'
write(io,'(a)')'      real(kind=8) :: y'
write(io,'(a)')''
write(io,'(a)')'      print *, minexponent(x), maxexponent(x)'
write(io,'(a)')'      print *, minexponent(y), maxexponent(y)'
write(io,'(a)')'    end program demo_maxexponent'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     maxloc(3f) - [INTRINSIC:TRANSFORMATIONAL FUNCTION] Location of the maximum value within an array'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = maxloc(array, dim [, mask])'
write(io,'(a)')'   result = maxloc(array [, mask])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Determines the location of the element in the array with the maximum'
write(io,'(a)')'   value, or, if the DIM argument is supplied, determines the'
write(io,'(a)')'   locations of the maximum element along each row of the array in the'
write(io,'(a)')'   DIM direction. If MASK is present, only the elements for'
write(io,'(a)')'   which MASK is .true. are considered. If more than one'
write(io,'(a)')'   element in the array has the maximum value, the location returned is'
write(io,'(a)')'   that of the first such element in array element order. If the array has'
write(io,'(a)')'   zero size, or all of the elements of MASK are .false., then'
write(io,'(a)')'   the result is an array of zeroes. Similarly, if DIM is supplied'
write(io,'(a)')'   and all of the elements of MASK along a given row are zero, the'
write(io,'(a)')'   result value for that row is zero.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   ARRAY  - Shall be an array of type INTEGER, REAL, or CHARACTER.'
write(io,'(a)')'   DIM    - (Optional) Shall be a scalar of type'
write(io,'(a)')'            INTEGER, with a value between one and the rank of ARRAY,'
write(io,'(a)')'            inclusive. It may not be an optional dummy argument.'
write(io,'(a)')'   MASK   - Shall be an array of type LOGICAL, and conformable with ARRAY.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   If DIM is absent, the result is a rank-one array with a length'
write(io,'(a)')'   equal to the rank of ARRAY. If DIM is present, the result'
write(io,'(a)')'   is an array with a rank one less than the rank of ARRAY, and a'
write(io,'(a)')'   size corresponding to the size of ARRAY with the DIM'
write(io,'(a)')'   dimension removed. If DIM is present and ARRAY has a rank'
write(io,'(a)')'   of one, the result is a scalar. In all cases, the result is of default'
write(io,'(a)')'   INTEGER type.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[max]], [[maxval]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     maxval(3f) - [INTRINSIC:TRANSFORMATIONAL FUNCTION] determines the maximum value in an array or row'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = maxval(array, dim [, mask])'
write(io,'(a)')'   result = maxval(array [, mask])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Determines the maximum value of the elements in an array value, or, if'
write(io,'(a)')'   the DIM argument is supplied, determines the maximum value along'
write(io,'(a)')'   each row of the array in the DIM direction. If MASK is'
write(io,'(a)')'   present, only the elements for which MASK is .true. are'
write(io,'(a)')'   considered. If the array has zero size, or all of the elements of'
write(io,'(a)')'   MASK are .false., then the result is the most negative'
write(io,'(a)')'   number of the type and kind of ARRAY if ARRAY is numeric, or'
write(io,'(a)')'   a string of nulls if ARRAY is of character type.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   ARRAY - Shall be an array of type INTEGER,'
write(io,'(a)')'   REAL, or CHARACTER.'
write(io,'(a)')'   DIM - (Optional) Shall be a scalar of type'
write(io,'(a)')'   INTEGER, with a value between one and the rank of ARRAY,'
write(io,'(a)')'   inclusive. It may not be an optional dummy argument.'
write(io,'(a)')'   MASK  - Shall be an array of type LOGICAL,'
write(io,'(a)')'   and conformable with ARRAY.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   If DIM is absent, or if ARRAY has a rank of one, the result'
write(io,'(a)')'   is a scalar. If DIM is present, the result is an array with a'
write(io,'(a)')'   rank one less than the rank of ARRAY, and a size corresponding to'
write(io,'(a)')'   the size of ARRAY with the DIM dimension removed. In all'
write(io,'(a)')'   cases, the result is of the same type and kind as ARRAY.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[max]], [[maxloc]]'
write(io,'(a)')''
write(io,'(a)')'CATEGORY'
write(io,'(a)')''
write(io,'(a)')'   intrinsics'
write(io,'(a)')'NAME'
write(io,'(a)')'     merge(3f) - [INTRINSIC:ARRAY CONSTRUCTION] Merge variables'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'     result = merge(tsource, fsource, mask)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   Select values from two arrays according to a logical mask. The result'
write(io,'(a)')'   is equal to TSOURCE if MASK is .true., or equal to'
write(io,'(a)')'   FSOURCE if it is .false..'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')'   TSOURCE  - May be of any type.'
write(io,'(a)')'   FSOURCE  - Shall be of the same type and type parameters'
write(io,'(a)')'              as TSOURCE.'
write(io,'(a)')'   MASK  - Shall be of type LOGICAL.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')'   The result is of the same type and type parameters as TSOURCE.'
write(io,'(a)')'   For any element the result is TSOURCE if MASK is true and FSOURCE otherwise.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLES'
write(io,'(a)')'  The value of'
write(io,'(a)')''
write(io,'(a)')'   MERGE (1.0, 0.0, K > 0)'
write(io,'(a)')''
write(io,'(a)')'  is 1.0 for K = 5 and 0.0 for K =  2.'
write(io,'(a)')''
write(io,'(a)')'   program demo_merge'
write(io,'(a)')'   integer :: TSRC(2,3), FSRC(2,3), ANSWER(2,3)'
write(io,'(a)')'   logical :: MASK(2,3)'
write(io,'(a)')''
write(io,'(a)')'   TSRC(1,:)=[ 1,6,5 ]; FSRC(1,:)=[ 0,3,2 ]; MASK(1,:)=[.TRUE., .FALSE.,.TRUE.]'
write(io,'(a)')'   TSRC(2,:)=[ 2,4,6 ]; FSRC(2,:)=[ 7,4,8 ]; MASK(2,:)=[.FALSE.,.FALSE.,.TRUE.]'
write(io,'(a)')''
write(io,'(a)')'   ANSWER=MERGE(TSRC,FSRC,MASK)'
write(io,'(a)')'   write(*,''(3i2)'')(answer(i,:),i=1,size(answer,dim=1))'
write(io,'(a)')'   end program demo_merge'
write(io,'(a)')''
write(io,'(a)')'  Expected result'
write(io,'(a)')''
write(io,'(a)')'    1 3 5'
write(io,'(a)')'    7 4 6'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')'CLASS'
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')'NAME'
write(io,'(a)')'     merge_bits(3f) - [INTRINSIC:BIT MANIPULATION] Merge of bits under mask'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = merge_bits(i, j, mask)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   merge_bits(i, j, mask) merges the bits of I and J as determined by'
write(io,'(a)')'   the mask. The k-th bit of the result is equal to the k-th bit of'
write(io,'(a)')'   I if the k-th bit of MASK is 1; it is equal to the k-th bit of'
write(io,'(a)')'   J otherwise.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  I  - Shall be of type INTEGER.'
write(io,'(a)')'  J  - Shall be of type INTEGER and of the same kind as I.'
write(io,'(a)')'  MASK  - Shall be of type INTEGER and of the same kind as I.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'The result is of the same type and kind as I.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     min(3f) - [INTRINSIC:NUMERIC] Minimum value of an argument list'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = min(a1, a2 [, a3, ...])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Returns the argument with the smallest (most negative) value.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   A1           - The type shall be INTEGER or REAL.'
write(io,'(a)')'   A2, A3, ...  - An expression of the same type and kind as A1.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value corresponds to the minimum value among the arguments,'
write(io,'(a)')'   and has the same type and kind as the first argument.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[max]], [[minloc]], [[minval]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     minexponent(3f) - [INTRINSIC] Minimum exponent of a real kind'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = minexponent(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   minexponent(x) returns the minimum exponent in the model of the'
write(io,'(a)')'   type of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - Shall be of type REAL.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER and of the default integer'
write(io,'(a)')'   kind.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'See [[maxexponent]] for an example.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     minloc(3f) - [INTRINSIC:TRANSFORMATIONAL FUNCTION] Location of the minimum value within an array'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = minloc(array, dim [, mask])'
write(io,'(a)')'   result = minloc(array [, mask])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Determines the location of the element in the array with the minimum'
write(io,'(a)')'   value, or, if the DIM argument is supplied, determines the'
write(io,'(a)')'   locations of the minimum element along each row of the array in the'
write(io,'(a)')'   DIM direction. If MASK is present, only the elements for'
write(io,'(a)')'   which MASK is .true. are considered. If more than one'
write(io,'(a)')'   element in the array has the minimum value, the location returned is'
write(io,'(a)')'   that of the first such element in array element order. If the array has'
write(io,'(a)')'   zero size, or all of the elements of MASK are .false., then'
write(io,'(a)')'   the result is an array of zeroes. Similarly, if DIM is supplied'
write(io,'(a)')'   and all of the elements of MASK along a given row are zero, the'
write(io,'(a)')'   result value for that row is zero.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   ARRAY  - Shall be an array of type INTEGER, REAL, or CHARACTER.'
write(io,'(a)')'   DIM    - (Optional) Shall be a scalar of type'
write(io,'(a)')'            INTEGER, with a value between one and the rank of ARRAY,'
write(io,'(a)')'            inclusive. It may not be an optional dummy argument.'
write(io,'(a)')'   MASK   - Shall be an array of type LOGICAL,'
write(io,'(a)')'            and conformable with ARRAY.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   If DIM is absent, the result is a rank-one array with a length'
write(io,'(a)')'   equal to the rank of ARRAY. If DIM is present, the result'
write(io,'(a)')'   is an array with a rank one less than the rank of ARRAY, and a'
write(io,'(a)')'   size corresponding to the size of ARRAY with the DIM'
write(io,'(a)')'   dimension removed. If DIM is present and ARRAY has a rank'
write(io,'(a)')'   of one, the result is a scalar. In all cases, the result is of default'
write(io,'(a)')'   INTEGER type.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[min]], [[minval]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     minval(3f) - [INTRINSIC:TRANSFORMATIONAL FUNCTION] Minimum value of an array'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = minval(array, dim [, mask])'
write(io,'(a)')'   result = minval(array [, mask])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Determines the minimum value of the elements in an array value, or, if'
write(io,'(a)')'   the DIM argument is supplied, determines the minimum value along'
write(io,'(a)')'   each row of the array in the DIM direction. If MASK is'
write(io,'(a)')'   present, only the elements for which MASK is .true. are'
write(io,'(a)')'   considered. If the array has zero size, or all of the elements of'
write(io,'(a)')'   MASK are .false., then the result is huge(array) if'
write(io,'(a)')'   ARRAY is numeric, or a string of char(255) characters if'
write(io,'(a)')'   ARRAY is of character type.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   ARRAY  - Shall be an array of type INTEGER,'
write(io,'(a)')'            REAL, or CHARACTER.'
write(io,'(a)')'   DIM    - (Optional) Shall be a scalar of type'
write(io,'(a)')'            INTEGER, with a value between one and the rank of ARRAY,'
write(io,'(a)')'            inclusive. It may not be an optional dummy argument.'
write(io,'(a)')'   MASK   - Shall be an array of type LOGICAL,'
write(io,'(a)')'            and conformable with ARRAY.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   If DIM is absent, or if ARRAY has a rank of one, the result'
write(io,'(a)')'   is a scalar. If DIM is present, the result is an array with a'
write(io,'(a)')'   rank one less than the rank of ARRAY, and a size corresponding to'
write(io,'(a)')'   the size of ARRAY with the DIM dimension removed. In all'
write(io,'(a)')'   cases, the result is of the same type and kind as ARRAY.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[min]], [[minloc]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     mod(3f) - [INTRINSIC:NUMERIC] Remainder function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = mod(a, p)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   mod(a,p) computes the remainder of the division of A by P.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   A  - Shall be a scalar of type INTEGER or REAL.'
write(io,'(a)')'   P  - Shall be a scalar of the same type and kind as A and not equal to zero.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is the result of a - (int(a/p) * p). The type'
write(io,'(a)')'   and kind of the return value is the same as that of the arguments. The'
write(io,'(a)')'   returned value has the same sign as A and a magnitude less than the'
write(io,'(a)')'   magnitude of P.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_mod'
write(io,'(a)')'     print *, mod(17,3)         ! yields 2'
write(io,'(a)')'     print *, mod(17.5,5.5)     ! yields 1.0'
write(io,'(a)')'     print *, mod(17.5d0,5.5)   ! yields 1.0d0'
write(io,'(a)')'     print *, mod(17.5,5.5d0)   ! yields 1.0d0'
write(io,'(a)')''
write(io,'(a)')'     print *, mod(-17,3)        ! yields -2'
write(io,'(a)')'     print *, mod(-17.5,5.5)    ! yields -1.0'
write(io,'(a)')'     print *, mod(-17.5d0,5.5)  ! yields -1.0d0'
write(io,'(a)')'     print *, mod(-17.5,5.5d0)  ! yields -1.0d0'
write(io,'(a)')''
write(io,'(a)')'     print *, mod(17,-3)        ! yields 2'
write(io,'(a)')'     print *, mod(17.5,-5.5)    ! yields 1.0'
write(io,'(a)')'     print *, mod(17.5d0,-5.5)  ! yields 1.0d0'
write(io,'(a)')'     print *, mod(17.5,-5.5d0)  ! yields 1.0d0'
write(io,'(a)')'   end program demo_mod'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[modulo]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     modulo(3f) - [INTRINSIC:NUMERIC] Modulo function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = modulo(a, p)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   modulo(a,p) computes the A modulo P.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  A  - Shall be a scalar of type INTEGER or REAL.'
write(io,'(a)')'  P  - Shall be a scalar of the same type and kind as A. It shall'
write(io,'(a)')'  not be zero.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The type and kind of the result are those of the arguments.'
write(io,'(a)')''
write(io,'(a)')'   * If A and P are of type INTEGER:'
write(io,'(a)')'     modulo(a,p) has the value of a - floor (real(a) / real(p)) * p.'
write(io,'(a)')'   * If A and P are of type REAL:'
write(io,'(a)')'     modulo(a,p) has the value of a - floor (a / p) * p.'
write(io,'(a)')''
write(io,'(a)')'   The returned value has the same sign as P and a magnitude less than'
write(io,'(a)')'   the magnitude of P.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_modulo'
write(io,'(a)')'     print *, modulo(17,3)        ! yields 2'
write(io,'(a)')'     print *, modulo(17.5,5.5)    ! yields 1.0'
write(io,'(a)')''
write(io,'(a)')'     print *, modulo(-17,3)       ! yields 1'
write(io,'(a)')'     print *, modulo(-17.5,5.5)   ! yields 4.5'
write(io,'(a)')''
write(io,'(a)')'     print *, modulo(17,-3)       ! yields -1'
write(io,'(a)')'     print *, modulo(17.5,-5.5)   ! yields -4.5'
write(io,'(a)')'   end program demo_modulo'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[mod]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     move_alloc(3f) - [INTRINSIC] Move allocation from one object to another'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   call move_alloc(src, dest)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   move_alloc(src, dest) moves the allocation from SRC to DEST.'
write(io,'(a)')'   SRC will become deallocated in the process.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   SRC  - ALLOCATABLE, intent(inout), may be of any type and kind.'
write(io,'(a)')'   DEST  - ALLOCATABLE, intent(out), shall be of the same type, kind and rank as SRC.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_move_alloc'
write(io,'(a)')'       integer, allocatable :: a(:), b(:)'
write(io,'(a)')''
write(io,'(a)')'       allocate(a(3))'
write(io,'(a)')'       a = [ 1, 2, 3 ]'
write(io,'(a)')'       call move_alloc(a, b)'
write(io,'(a)')'       print *, allocated(a), allocated(b)'
write(io,'(a)')'       print *, b'
write(io,'(a)')'   end program demo_move_alloc'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'Pure subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[allocated]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     mvbits(3f) - [INTRINSIC:BIT MANIPULATION] Move bits from one integer to another'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   call mvbits(from, frompos, len, to, topos)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Moves LEN bits from positions FROMPOS through'
write(io,'(a)')'   frompos+len-1 of FROM to positions TOPOS through'
write(io,'(a)')'   topos+len-1 of TO. The portion of argument TO not'
write(io,'(a)')'   affected by the movement of bits is unchanged. The values of'
write(io,'(a)')'   frompos+len-1 and topos+len-1 must be less than'
write(io,'(a)')'   bit_size(from).'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   FROM  - The type shall be INTEGER.'
write(io,'(a)')'   FROMPOS  - The type shall be INTEGER.'
write(io,'(a)')'   LEN   - The type shall be INTEGER.'
write(io,'(a)')'   TO    - The type shall be INTEGER, of the'
write(io,'(a)')'same kind as FROM.'
write(io,'(a)')'   TOPOS  - The type shall be INTEGER.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental subroutine]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[ibclr]], [[ibset]], [[ibits]],'
write(io,'(a)')'   [[iand]], [[ior]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     nearest(3f) - [INTRINSIC:MODEL_COMPONENTS] Nearest representable number'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = nearest(x, s)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   nearest(x, s) returns the processor-representable number nearest'
write(io,'(a)')'   to X in the direction indicated by the sign of S.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - Shall be of type REAL.'
write(io,'(a)')'   S  - Shall be of type REAL and not equal to zero.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of the same type as X. If S is positive,'
write(io,'(a)')'   NEAREST returns the processor-representable number greater than X'
write(io,'(a)')'   and nearest to it. If S is negative, NEAREST returns the'
write(io,'(a)')'   processor-representable number smaller than X and nearest to it.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_nearest'
write(io,'(a)')'     real :: x, y'
write(io,'(a)')'     x = nearest(42.0, 1.0)'
write(io,'(a)')'     y = nearest(42.0, -1.0)'
write(io,'(a)')'     write (*,"(3(g20.15))") x, y, x - y'
write(io,'(a)')'   end program demo_nearest'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     new_line(3f) - [INTRINSIC] New line character'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'   result = new_line(c)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   new_line(c) returns the new-line character.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')'   C  - The argument shall be a scalar or array of the type CHARACTER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')'   Returns a CHARACTER scalar of length one with the new-line character of'
write(io,'(a)')'   the same kind as parameter C.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_new_line'
write(io,'(a)')'      implicit none'
write(io,'(a)')'      write(*,''(A)'') ''This is record 1.''//NEW_LINE(''A'')//''This is record 2.'''
write(io,'(a)')'    end program demo_new_line'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     nint(3f) - [INTRINSIC:NUMERIC] Nearest whole number'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = nint(x [, kind])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   nint(x) rounds its argument to the nearest whole number.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type of the argument shall be REAL.'
write(io,'(a)')'   KIND  - (Optional) An INTEGER initialization'
write(io,'(a)')'           expression indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   Returns A with the fractional portion of its magnitude eliminated by'
write(io,'(a)')'   rounding to the nearest whole number and with its sign preserved,'
write(io,'(a)')'   converted to an INTEGER of the default kind.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_nint'
write(io,'(a)')'      real(4) x4'
write(io,'(a)')'      real(8) x8'
write(io,'(a)')'      x4 = 1.234E0_4'
write(io,'(a)')'      x8 = 4.321_8'
write(io,'(a)')'      print *, nint(x4), idnint(x8)'
write(io,'(a)')'    end program demo_nint'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later, with KIND argument [[Fortran 90]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[ceiling]], [[floor]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     norm2(3f) - [INTRINSIC:MATHEMATICS] Euclidean vector norm'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = norm2(array[, dim])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Calculates the Euclidean vector norm (L_2 norm) of ARRAY along dimension DIM.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  ARRAY  - Shall be an array of type REAL.'
write(io,'(a)')'  DIM  - (Optional) shall be a scalar of type INTEGER with a value'
write(io,'(a)')'  in the range from 1 to n, where n equals the rank of ARRAY.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The result is of the same type as ARRAY.'
write(io,'(a)')''
write(io,'(a)')'   If DIM is absent, a scalar with the square root of the sum of'
write(io,'(a)')'   squares of the elements of ARRAY is returned. Otherwise, an array of'
write(io,'(a)')'   rank n-1, where "n" equals the rank of ARRAY, and a shape similar'
write(io,'(a)')'   to that of ARRAY with dimension DIM dropped is returned.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_norm2'
write(io,'(a)')'     real :: x(5) = [ real :: 1, 2, 3, 4, 5 ]'
write(io,'(a)')'     print *, norm2(x)  ! = sqrt(55.) ~ 7.416'
write(io,'(a)')'   end program demo_norm2'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[product]], [[sum]], [[hypot]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     not(3f) - [INTRINSIC:BIT MANIPULATION] Logical negation'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = not(i)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   NOT returns the bitwise Boolean inverse of I.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I  - The type shall be INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return type is INTEGER, of the same kind as the argument.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[iand]], [[ior]], [[ieor]], [[ibits]],'
write(io,'(a)')'   [[ibset]], [[ibclr]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     null(3f) - [INTRINSIC:TRANSFORMATIONAL FUNCTION] Function that returns an disassociated pointer'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'    ptr => null([mold])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Returns a disassociated pointer.'
write(io,'(a)')''
write(io,'(a)')'   If MOLD is present, a disassociated pointer of the same type is'
write(io,'(a)')'   returned, otherwise the type is determined by context.'
write(io,'(a)')''
write(io,'(a)')'   In [[Fortran 95]], MOLD is optional. Please note that [[Fortran 2003]]'
write(io,'(a)')'   includes cases where it is required.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   MOLD  - (Optional) shall be a pointer of any association'
write(io,'(a)')'           status and of any type.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   A disassociated pointer.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    real, pointer, dimension(:) :: vec => null ()'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[associated]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     num_images(3f) - [INTRINSIC] Number of images'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = num_images(distance, failed)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Returns the number of images.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   DISTANCE  - (optional, intent(in)) Nonnegative scalar integer'
write(io,'(a)')'   FAILED   - (optional, intent(in)) Scalar logical expression'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   Scalar default-kind integer. If DISTANCE is not present or has'
write(io,'(a)')'   value 0, the number of images in the current team is returned. For'
write(io,'(a)')'   values smaller or equal distance to the initial team, it returns the'
write(io,'(a)')'   number of images index on the ancestor team which has a distance of'
write(io,'(a)')'   DISTANCE from the invoking team. If DISTANCE is larger than the'
write(io,'(a)')'   distance to the initial team, the number of images of the initial team'
write(io,'(a)')'   is returned. If FAILED is not present the total number of images is'
write(io,'(a)')'   returned; if it has the value .true., the number of failed images is'
write(io,'(a)')'   returned, otherwise, the number of images which do have not the failed'
write(io,'(a)')'   status.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   integer :: value[*]'
write(io,'(a)')'   integer :: i'
write(io,'(a)')'   value = this_image()'
write(io,'(a)')'   sync all'
write(io,'(a)')'   if (this_image() == 1) then'
write(io,'(a)')'     do i = 1, num_images()'
write(io,'(a)')'       write(*,''(2(a,i0))'') ''value['', i, ''] is '', value[i]'
write(io,'(a)')'     end do'
write(io,'(a)')'   end if'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later. With DISTANCE or FAILED argument, [[TS 18508]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[this_image]], [[image_index]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     pack(3f) - [INTRINSIC:ARRAY CONSTRUCTION] Pack an array into an array of rank one'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = pack(array, mask[,vector])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Stores the elements of ARRAY in an array of rank one.'
write(io,'(a)')''
write(io,'(a)')'   The beginning of the resulting array is made up of elements whose MASK'
write(io,'(a)')'   equals TRUE. Afterwards, positions are filled with elements taken from'
write(io,'(a)')'   VECTOR.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   ARRAY  - Shall be an array of any type.'
write(io,'(a)')'   MASK  - Shall be an array of type LOGICAL and of the same size'
write(io,'(a)')'           as ARRAY. Alternatively, it may be a LOGICAL scalar.'
write(io,'(a)')'   VECTOR  - (Optional) shall be an array of the same type as ARRAY'
write(io,'(a)')'             and of rank one. If present, the number of elements in VECTOR'
write(io,'(a)')'             shall be equal to or greater than the number of true elements in'
write(io,'(a)')'             MASK. If MASK is scalar, the number of elements in VECTOR'
write(io,'(a)')'             shall be equal to or greater than the number of elements in'
write(io,'(a)')'             ARRAY.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The result is an array of rank one and the same type as that of ARRAY.'
write(io,'(a)')'   If VECTOR is present, the result size is that of VECTOR, the'
write(io,'(a)')'   number of TRUE values in MASK otherwise.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_pack'
write(io,'(a)')'    ! Sample program gathering nonzero elements from an array:'
write(io,'(a)')'    call test1()'
write(io,'(a)')'    ! Gathering nonzero elements from an array and appending elements from VECTOR:'
write(io,'(a)')'    call test2()'
write(io,'(a)')'    contains'
write(io,'(a)')'    !'
write(io,'(a)')'    subroutine test1()'
write(io,'(a)')'    integer :: m(6)'
write(io,'(a)')'      m = (/ 1, 0, 0, 0, 5, 0 /)'
write(io,'(a)')'      write(*, fmt="(6(i0, '' ''))") pack(m, m /= 0)  ! "1 5"'
write(io,'(a)')'    end subroutine test1'
write(io,'(a)')'    !'
write(io,'(a)')'    subroutine test2()'
write(io,'(a)')'    integer :: m(4)'
write(io,'(a)')'      m = (/ 1, 0, 0, 2 /)'
write(io,'(a)')'      write(*, fmt="(4(i0, '' ''))") pack(m, m /= 0, (/ 0, 0, 3, 4 /))  ! "1 2 3 4"'
write(io,'(a)')'    end subroutine test2'
write(io,'(a)')'    !'
write(io,'(a)')'    end program demo_pack'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[unpack]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     parity(3f) - [INTRINSIC:TRANSFORMATIONAL FUNCTION] Reduction with exclusive OR()'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = parity(mask[, dim])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Calculates the parity (i.e. the reduction using .xor.) of MASK along dimension DIM.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   MASK  - Shall be an array of type LOGICAL.'
write(io,'(a)')'   DIM  - (Optional) shall be a scalar of type INTEGER with a value'
write(io,'(a)')'          in the range from 1 to n, where n equals the rank of ARRAY.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The result is of the same type as MASK.'
write(io,'(a)')''
write(io,'(a)')'   If DIM is absent, a scalar with the parity of all elements in MASK'
write(io,'(a)')'   is returned: .true. if an odd number of elements are .true. and'
write(io,'(a)')'   .false. otherwise. If DIM is present, an array of rank n-1,'
write(io,'(a)')'   where "n" equals the rank of MASK, and a shape similar to that of'
write(io,'(a)')'   MASK with dimension DIM dropped is returned.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_parity'
write(io,'(a)')'     logical :: x(2) = [ .true., .false. ]'
write(io,'(a)')'     print *, parity(x) ! T'
write(io,'(a)')'   end program demo_parity'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     popcnt(3f) - [INTRINSIC:BIT INQUIRY] Number of bits set'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = popcnt(i)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Returns the number of bits set in the binary representation of an integer.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I  - Shall be of type INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type ''integer'' and of the default integer kind.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_population'
write(io,'(a)')'     print *, popcnt(127),       poppar(127)'
write(io,'(a)')'     print *, popcnt(huge(0_4)), poppar(huge(0_4))'
write(io,'(a)')'     print *, popcnt(huge(0_8)), poppar(huge(0_8))'
write(io,'(a)')'   end program demo_population'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[poppar]], [[leadz]], [[trailz]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     poppar(3f) - [INTRINSIC:BIT INQUIRY] Parity of the number of bits set'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = poppar(i)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Returns the parity of an integer''s binary representation (i.e., the'
write(io,'(a)')'   parity of the number of bits set).'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I  - Shall be of type INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type ''integer'' and of the default integer kind.'
write(io,'(a)')'   It is equal to 0 if I has an even number of bits set and 1 if an odd'
write(io,'(a)')'   number of bits are set.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_population'
write(io,'(a)')'     print *, popcnt(127),       poppar(127)'
write(io,'(a)')'     print *, popcnt(huge(0_4)), poppar(huge(0_4))'
write(io,'(a)')'     print *, popcnt(huge(0_8)), poppar(huge(0_8))'
write(io,'(a)')'   end program demo_population'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[popcnt]], [[leadz]], [[trailz]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     precision(3f) - [INTRINSIC] Decimal precision of a real kind'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'    result = precision(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   precision(x) returns the decimal precision in the model of the'
write(io,'(a)')'   type of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - Shall be of type REAL or COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER and of the default integer'
write(io,'(a)')'   kind.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_precision'
write(io,'(a)')'      real(kind=4) :: x(2)'
write(io,'(a)')'      complex(kind=8) :: y'
write(io,'(a)')''
write(io,'(a)')'      print *, precision(x), range(x)'
write(io,'(a)')'      print *, precision(y), range(y)'
write(io,'(a)')'    end program demo_precision'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[selected_real_kind]], [[range]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     present(3f) - [INTRINSIC] Determine whether an optional dummy argument is specified'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = present(a)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Determines whether an optional dummy argument is present.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   A  - May be of any type and may be a pointer, scalar or array'
write(io,'(a)')'        value, or a dummy procedure. It shall be the name of an optional'
write(io,'(a)')'        dummy argument accessible within the current subroutine or'
write(io,'(a)')'        function.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'      Returns either TRUE if the optional argument A is present, or'
write(io,'(a)')'      FALSE otherwise.'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'   EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'     Sample program:'
write(io,'(a)')''
write(io,'(a)')'       program demo_present'
write(io,'(a)')'         write(*,*) f(), f(42)      ! "f t"'
write(io,'(a)')'       contains'
write(io,'(a)')'         logical function f(x)'
write(io,'(a)')'           integer, intent(in), optional :: x'
write(io,'(a)')'           f = present(x)'
write(io,'(a)')'         end function'
write(io,'(a)')'       end program demo_present'
write(io,'(a)')''
write(io,'(a)')'   STANDARD'
write(io,'(a)')''
write(io,'(a)')'      [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'   CLASS'
write(io,'(a)')''
write(io,'(a)')'      [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'        product(3f) - [INTRINSIC:TRANSFORMATIONAL FUNCTION] Product of array elements'
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   * result = product(array[, mask])'
write(io,'(a)')'   * result = product(array, dim[, mask])'
write(io,'(a)')''
write(io,'(a)')'   DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Multiplies the elements of ARRAY along dimension DIM if'
write(io,'(a)')'   the corresponding element in MASK is TRUE.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   ARRAY  - Shall be an array of type INTEGER, REAL or COMPLEX.'
write(io,'(a)')'   DIM    - (Optional) shall be a scalar of type INTEGER with a'
write(io,'(a)')'            value in the range from 1 to n, where n equals the rank of ARRAY.'
write(io,'(a)')'   MASK   - (Optional) shall be of type LOGICAL'
write(io,'(a)')'            and either be a scalar or an array of the same shape as ARRAY.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The result is of the same type as ARRAY.'
write(io,'(a)')''
write(io,'(a)')'   If DIM is absent, a scalar with the product of all elements in'
write(io,'(a)')'   ARRAY is returned. Otherwise, an array of rank n-1, where n equals'
write(io,'(a)')'   the rank of ARRAY, and a shape similar to that of ARRAY with'
write(io,'(a)')'   dimension DIM dropped is returned.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_product'
write(io,'(a)')'      integer :: x(5) = (/ 1, 2, 3, 4 ,5 /)'
write(io,'(a)')'      print *, product(x)                    ! all elements, product = 120'
write(io,'(a)')'      print *, product(x, mask=mod(x, 2)==1) ! odd elements, product = 15'
write(io,'(a)')'    end program demo_product'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[sum]], note that an element by element multiplication is done directly using the star character.'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     radix(3f) - [INTRINSIC] Base of a model number'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'    result = radix(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   radix(x) returns the base of the model representing the entity X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - Shall be of type INTEGER or REAL'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is a scalar of type INTEGER and of the default'
write(io,'(a)')'   integer kind.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_radix'
write(io,'(a)')'      print *, "The radix for the default integer kind is", radix(0)'
write(io,'(a)')'      print *, "The radix for the default real kind is", radix(0.0)'
write(io,'(a)')'    end program demo_radix'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[scale]], [[selected_real_kind]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     random_number(3f) - [INTRINSIC] Pseudo-random number'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   random_number(harvest)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Returns a single pseudorandom number or an array of pseudorandom numbers'
write(io,'(a)')'   from the uniform distribution over the range 0 <= x < 1.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   HARVEST  - Shall be a scalar or an array of type REAL.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_random_number'
write(io,'(a)')'      real :: r(5,5)'
write(io,'(a)')'      call random_number(r)'
write(io,'(a)')'    end program demo_random_number'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[random_seed]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     random_seed(3f) - [INTRINSIC] Initialize a pseudo-random number sequence'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   call random_seed([size, put, get])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Restarts or queries the state of the pseudorandom number generator'
write(io,'(a)')'   used by random_number.'
write(io,'(a)')''
write(io,'(a)')'   If random_seed is called without arguments, it is seeded with random'
write(io,'(a)')'   data retrieved from the operating system.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   SIZE  - (Optional) Shall be a scalar and of type default'
write(io,'(a)')'   INTEGER, with intent(out). It specifies the minimum size of the'
write(io,'(a)')'   arrays used with the PUT and GET arguments.'
write(io,'(a)')''
write(io,'(a)')'   PUT  - (Optional) Shall be an array of type default INTEGER and'
write(io,'(a)')'   rank one. It is intent(in) and the size of the array must be'
write(io,'(a)')'   larger than or equal to the number returned by the SIZE argument.'
write(io,'(a)')''
write(io,'(a)')'   GET  - (Optional) Shall be an array of type default INTEGER and'
write(io,'(a)')'   rank one. It is intent(out) and the size of the array must be'
write(io,'(a)')'   larger than or equal to the number returned by the SIZE argument.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_random_seed'
write(io,'(a)')'     implicit none'
write(io,'(a)')'     integer, allocatable :: seed(:)'
write(io,'(a)')'     integer :: n'
write(io,'(a)')''
write(io,'(a)')'     call random_seed(size = n)'
write(io,'(a)')'     allocate(seed(n))'
write(io,'(a)')'     call random_seed(get=seed)'
write(io,'(a)')'     write (*, *) seed'
write(io,'(a)')'   end program demo_random_seed'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[random_number]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     range(3f) - [INTRINSIC] Decimal exponent range of a real kind'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = range(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   range(x) returns the decimal exponent range in the model of the'
write(io,'(a)')'   type of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - Shall be of type REAL or COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER and of the default integer'
write(io,'(a)')'   kind.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'See [[precision]] for an example.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[selected_real_kind]], [[precision]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     rank(3f) - [INTRINSIC:ARRAY INQUIRY] Rank of a data object'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = rank(a)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   rank(a) returns the rank of a scalar or array data object.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   A  - can be of any type'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER and of the default integer'
write(io,'(a)')'   kind. For arrays, their rank is returned; for scalars zero is'
write(io,'(a)')'   returned.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_rank'
write(io,'(a)')'     integer :: a'
write(io,'(a)')'     real, allocatable :: b(:,:)'
write(io,'(a)')''
write(io,'(a)')'     print *, rank(a), rank(b) ! Prints:  0  2'
write(io,'(a)')'   end program demo_rank'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[TS 29113]]'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Inquiry function'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     real(3f) - [INTRINSIC:NUMERIC] Convert to real type'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = real(x [, kind])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   real(x [, kind]) converts its argument X to a real type.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - Shall be INTEGER, REAL, or COMPLEX.'
write(io,'(a)')'   KIND  - (Optional) An INTEGER initialization expression'
write(io,'(a)')'   indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   These functions return a REAL variable or array under'
write(io,'(a)')'   the following rules:'
write(io,'(a)')''
write(io,'(a)')'   1. real(x) is converted to a default real type if X is an integer'
write(io,'(a)')'      or real variable.'
write(io,'(a)')''
write(io,'(a)')'   2. real(x) is converted to a real type with the kind type parameter'
write(io,'(a)')'      of X if X is a complex variable.'
write(io,'(a)')''
write(io,'(a)')'   3. real(x, kind) is converted to a real type with kind type'
write(io,'(a)')'      parameter KIND if X is a complex, integer, or real variable.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_real'
write(io,'(a)')'     complex :: x = (1.0, 2.0)'
write(io,'(a)')'     print *, real(x), real(x,8)'
write(io,'(a)')'   end program demo_real'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Elemental function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[dble]], [[float]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     repeat(3f) - [INTRINSIC:CHARACTER] Repeated string concatenation'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = repeat(string, ncopies)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Concatenates NCOPIES copies of a string.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   STRING  - Shall be scalar and of type CHARACTER.'
write(io,'(a)')'   NCOPIES  - Shall be scalar and of type INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   A new scalar of type CHARACTER built up from NCOPIES copies'
write(io,'(a)')'   of STRING.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_repeat'
write(io,'(a)')'      write(*,*) repeat("x", 5)   ! "xxxxx"'
write(io,'(a)')'    end program demo_repeat'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     reshape(3f) - [INTRINSIC:ARRAY RESHAPE] Function to reshape an array'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = reshape(source, shape[, pad, order])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Reshapes array SOURCE to correspond to SHAPE. If necessary,'
write(io,'(a)')'   the new array may be padded with elements from PAD or permuted'
write(io,'(a)')'   as defined by ORDER.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   SOURCE  - an array of any type.'
write(io,'(a)')'   SHAPE   - an array of rank one and type INTEGER. Its'
write(io,'(a)')'             values must be positive or zero.'
write(io,'(a)')'   PAD     - (Optional) an array of the same type as SOURCE.'
write(io,'(a)')'   ORDER   - (Optional) an array of type INTEGER and the'
write(io,'(a)')'             same shape as SHAPE. Its values shall be a permutation of the'
write(io,'(a)')'             numbers from 1 to n, where n is the size of SHAPE. If ORDER is'
write(io,'(a)')'             absent, the natural ordering shall be assumed.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The result is an array of shape SHAPE with the same type as SOURCE.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_reshape'
write(io,'(a)')'      integer, dimension(4) :: x=[(i,i=10,40,10)]'
write(io,'(a)')'      ! X is originally a vector with four elements'
write(io,'(a)')'      write(*,*) shape(x)                     ! prints "4"'
write(io,'(a)')'      write(*,*) shape(reshape(x, [2, 2]))    ! prints "2 2"'
write(io,'(a)')'    end program demo_reshape'
write(io,'(a)')''
write(io,'(a)')'  Results:'
write(io,'(a)')'           4'
write(io,'(a)')'           2           2'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[shape]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     rrspacing(3f) - [INTRINSIC:MODEL_COMPONENTS] Reciprocal of the relative spacing'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'   result = rrspacing(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   rrspacing(x) returns the reciprocal of the relative spacing of model'
write(io,'(a)')'   numbers near X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')'   X  - Shall be of type REAL.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')'   The return value is of the same type and kind as X.'
write(io,'(a)')'   The value returned is equal to'
write(io,'(a)')'   abs(fraction(x)) * float(radix(x))**digits(x).'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')'   [[spacing]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     same_type_as(3f) - [INTRINSIC] Query dynamic types for equality'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'   result = same_type_as(a, b)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   Query dynamic types for equality.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')'   A  - Shall be an object of extensible declared type or unlimited polymorphic.'
write(io,'(a)')'   B  - Shall be an object of extensible declared type or unlimited polymorphic.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')'   The return value is a scalar of type default logical. It is true if and'
write(io,'(a)')'   only if the dynamic type of A is the same as the dynamic type of B.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')'   [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')'   [[extends_type_of]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     scale(3f) - [INTRINSIC:MODEL_COMPONENTS] Scale a real value'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'   result = scale(x, i)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   scale(x,i) returns x * radix(x)**i.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')'   X  - The type of the argument shall be a REAL.'
write(io,'(a)')'   I  - The type of the argument shall be a INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')'   The return value is of the same type and kind as X.'
write(io,'(a)')'   Its value is x * radix(x)**i.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_scale'
write(io,'(a)')'      real :: x = 178.1387e-4'
write(io,'(a)')'      integer :: i = 5'
write(io,'(a)')'      print *, scale(x,i), x*radix(x)**i'
write(io,'(a)')'    end program demo_scale'
write(io,'(a)')'  Results:'
write(io,'(a)')''
write(io,'(a)')'    0.570043862      0.570043862'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')'   [[radix]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     scan(3f) - [INTRINSIC:CHARACTER] Scan a string for the presence of a set of characters'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = scan(string, set[, back [, kind]])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Scans a STRING for any of the characters in a SET'
write(io,'(a)')'   of characters.'
write(io,'(a)')''
write(io,'(a)')'   If BACK is either absent or equals FALSE, this function'
write(io,'(a)')'   returns the position of the leftmost character of STRING that is'
write(io,'(a)')'   in SET. If BACK equals TRUE, the rightmost position'
write(io,'(a)')'   is returned. If no character of SET is found in STRING, the'
write(io,'(a)')'   result is zero.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   STRING  - Shall be of type CHARACTER.'
write(io,'(a)')'   SET  - Shall be of type CHARACTER.'
write(io,'(a)')'   BACK  - (Optional) shall be of type LOGICAL.'
write(io,'(a)')'   KIND  - (Optional) An INTEGER initialization expression'
write(io,'(a)')'           indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER and of kind KIND. If'
write(io,'(a)')'   KIND is absent, the return value is of default integer kind.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_scan'
write(io,'(a)')'      write(*,*) scan("fortran", "ao")          ! 2, found ''o'''
write(io,'(a)')'      write(*,*) scan("fortran", "ao", .true.)  ! 6, found ''a'''
write(io,'(a)')'      write(*,*) scan("fortran", "c++")         ! 0, found none'
write(io,'(a)')'    end program demo_scan'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later, with KIND argument [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[verify]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     selected_char_kind(3f) - [INTRINSIC] Choose character kind'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = selected_char_kind(name)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   selected_char_kind(name) returns the kind value for the character'
write(io,'(a)')'   set named NAME, if a character set with such a name is supported, or'
write(io,'(a)')'   -1 otherwise. Currently, supported character sets include "ASCII"'
write(io,'(a)')''
write(io,'(a)')'   and "DEFAULT", which are equivalent, and "ISO_10646" (Universal'
write(io,'(a)')'   Character Set, UCS-4) which is commonly known as Unicode.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   NAME  - Shall be a scalar and of the default character type.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_selected_char_kind'
write(io,'(a)')'     use iso_fortran_env'
write(io,'(a)')'     implicit none'
write(io,'(a)')'     integer, parameter :: ascii = selected_char_kind ("ascii")'
write(io,'(a)')'     integer, parameter :: ucs4  = selected_char_kind (''ISO_10646'')'
write(io,'(a)')''
write(io,'(a)')'     character(kind=ascii, len=26) :: alphabet'
write(io,'(a)')'     character(kind=ucs4,  len=30) :: hello_world'
write(io,'(a)')''
write(io,'(a)')'     alphabet = ascii_"abcdefghijklmnopqrstuvwxyz"'
write(io,'(a)')'     hello_world = ucs4_''Hello World and Ni Hao -- '' &'
write(io,'(a)')'                   // char (int (z''4F60''), ucs4)     &'
write(io,'(a)')'                   // char (int (z''597D''), ucs4)'
write(io,'(a)')''
write(io,'(a)')'     write (*,*) alphabet'
write(io,'(a)')''
write(io,'(a)')'     open (output_unit, encoding=''UTF-8'')'
write(io,'(a)')'     write (*,*) trim (hello_world)'
write(io,'(a)')'   end program demo_selected_char_kind'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     selected_int_kind(3f) - [INTRINSIC] Choose integer kind'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = selected_int_kind(r)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   selected_int_kind(r) return the kind value of the smallest integer'
write(io,'(a)')'   type that can represent all values ranging from -10**R (exclusive)'
write(io,'(a)')'   to 10**R (exclusive). If there is no integer kind that accommodates'
write(io,'(a)')'   this range, selected_int_kind returns -1.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   R  - Shall be a scalar and of type INTEGER.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_selected_int_kind'
write(io,'(a)')'     integer,parameter :: k5 = selected_int_kind(5)'
write(io,'(a)')'     integer,parameter :: k15 = selected_int_kind(15)'
write(io,'(a)')'     integer(kind=k5) :: i5'
write(io,'(a)')'     integer(kind=k15) :: i15'
write(io,'(a)')''
write(io,'(a)')'     print *, huge(i5), huge(i15)'
write(io,'(a)')''
write(io,'(a)')'     ! the following inequalities are always true'
write(io,'(a)')'     print *, huge(i5) >= 10_k5**5-1'
write(io,'(a)')'     print *, huge(i15) >= 10_k15**15-1'
write(io,'(a)')'   end program demo_selected_int_kind'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     selected_real_kind(3f) - [INTRINSIC] Choose real kind'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = selected_real_kind([p, r, radix])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   selected_real_kind(p, r, radix) return the kind value of a real data'
write(io,'(a)')'   type with decimal precision of at least P digits, exponent range of'
write(io,'(a)')'   at least R, and with a radix of RADIX.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   P  - (Optional) shall be a scalar and of type INTEGER.'
write(io,'(a)')'   R  - (Optional) shall be a scalar and of type INTEGER.'
write(io,'(a)')'   RADIX  - (Optional) shall be a scalar and of type INTEGER.'
write(io,'(a)')''
write(io,'(a)')'   Before [[Fortran 2008]], at least one of the arguments R or P'
write(io,'(a)')'   shall be present; since [[Fortran 2008]], they are assumed to be zero'
write(io,'(a)')'   if absent.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   selected_real_kind returns the value of the kind type parameter of'
write(io,'(a)')'   a real data type with decimal precision of at least P digits, a'
write(io,'(a)')'   decimal exponent range of at least R, and with the requested'
write(io,'(a)')'   RADIX. If the RADIX parameter is absent, real kinds with'
write(io,'(a)')'   any radix can be returned. If more than one real data type meet the'
write(io,'(a)')'   criteria, the kind of the data type with the smallest decimal precision'
write(io,'(a)')'   is returned. If no real data type matches the criteria, the result is'
write(io,'(a)')''
write(io,'(a)')'* -1 if the processor does not support a real data type with a'
write(io,'(a)')'  precision greater than or equal to P, but the R and RADIX'
write(io,'(a)')'  requirements can be fulfilled'
write(io,'(a)')'* -2 if the processor does not support a real type with an exponent'
write(io,'(a)')'  range greater than or equal to R, but P and RADIX are'
write(io,'(a)')'  fulfillable'
write(io,'(a)')'* -3 if RADIX but not P and R requirements are fulfillable'
write(io,'(a)')'* -4 if RADIX and either P or R requirements are fulfillable'
write(io,'(a)')'* -5 if there is no real type with the given RADIX'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_selected_real_kind'
write(io,'(a)')'     integer,parameter :: p6 = selected_real_kind(6)'
write(io,'(a)')'     integer,parameter :: p10r100 = selected_real_kind(10,100)'
write(io,'(a)')'     integer,parameter :: r400 = selected_real_kind(r=400)'
write(io,'(a)')'     real(kind=p6) :: x'
write(io,'(a)')'     real(kind=p10r100) :: y'
write(io,'(a)')'     real(kind=r400) :: z'
write(io,'(a)')''
write(io,'(a)')'     print *, precision(x), range(x)'
write(io,'(a)')'     print *, precision(y), range(y)'
write(io,'(a)')'     print *, precision(z), range(z)'
write(io,'(a)')'   end program demo_selected_real_kind'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later; with RADIX [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[precision]], [[range]], [[radix]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     set_exponent(3f) - [INTRINSIC:MODEL_COMPONENTS] Set the exponent of the model'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = set_exponent(x, i)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   set_exponent(x, i) returns the real number whose fractional part'
write(io,'(a)')'   is that of X and whose exponent part is I.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - Shall be of type REAL.'
write(io,'(a)')'   I  - Shall be of type INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of the same type and kind as X.'
write(io,'(a)')'   The real number whose fractional part'
write(io,'(a)')'   is that that of X and whose exponent part if I is returned;'
write(io,'(a)')'   it is fraction(x) * radix(x)**i.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_setexp'
write(io,'(a)')'      real :: x = 178.1387e-4'
write(io,'(a)')'      integer :: i = 17'
write(io,'(a)')'      print *, set_exponent(x, i), fraction(x) * radix(x)**i'
write(io,'(a)')'    end program demo_setexp'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     shape(3f) - [INTRINSIC:ARRAY INQUIRY] Determine the shape of an array'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = shape(source[, kind])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Determines the shape of an array.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  SOURCE  - Shall be an array or scalar of any type. If SOURCE is'
write(io,'(a)')'  a pointer it must be associated and allocatable arrays must be'
write(io,'(a)')'  allocated.'
write(io,'(a)')'  KIND  - (Optional) An INTEGER initialization expression'
write(io,'(a)')'indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   An INTEGER array of rank one with as many elements as SOURCE'
write(io,'(a)')'   has dimensions. The elements of the resulting array correspond to the extend'
write(io,'(a)')'   of SOURCE along the respective dimensions. If SOURCE is a scalar,'
write(io,'(a)')'   the result is the rank one array of size zero. If KIND is absent, the'
write(io,'(a)')'   return value has the default integer kind otherwise the specified kind.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_shape'
write(io,'(a)')'     integer, dimension(-1:1, -1:2) :: a'
write(io,'(a)')'     write(*,*) shape(a)             ! (/ 3, 4 /)'
write(io,'(a)')'     write(*,*) size(shape(42))      ! (/ /)'
write(io,'(a)')'   end program demo_shape'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later; with KIND argument [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[reshape]], [[size]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     sign(3f) - [INTRINSIC:NUMERIC] Sign copying function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'   result = sign(a, b)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   sign(a,b) returns the value of A with the sign of B.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   A  - Shall be of type INTEGER or REAL'
write(io,'(a)')'   B  - Shall be of the same type and kind as A'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The kind of the return value is that of A and B.'
write(io,'(a)')'   If B >= 0 then the result is abs(a), else'
write(io,'(a)')'   it is -abs(a).'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_sign'
write(io,'(a)')'      print *, sign(-12,1)'
write(io,'(a)')'      print *, sign(-12,0)'
write(io,'(a)')'      print *, sign(-12,-1)'
write(io,'(a)')''
write(io,'(a)')'      print *, sign(-12.,1.)'
write(io,'(a)')'      print *, sign(-12.,0.)'
write(io,'(a)')'      print *, sign(-12.,-1.)'
write(io,'(a)')'    end program demo_sign'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     sin(3f) - [INTRINSIC:TRIGONOMETRIC] Sine function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = sin(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   sin(x) computes the sine of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type shall be REAL or COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value has same type and kind as X.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_sin'
write(io,'(a)')'      real :: x = 0.0'
write(io,'(a)')'      x = sin(x)'
write(io,'(a)')'    end program demo_sin'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[asin]], [[cos]], [[tan]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     sinh(3f) - [INTRINSIC:TRIGONOMETRIC] Hyperbolic sine function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = sinh(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   sinh(x) computes the hyperbolic sine of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  X  - The type shall be REAL or COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value has same type and kind as X.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_sinh'
write(io,'(a)')'     real(8) :: x = - 1.0_8'
write(io,'(a)')'     x = sinh(x)'
write(io,'(a)')'   end program demo_sinh'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later, for a complex argument [[Fortran 2008]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Elemental function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[asinh]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     size(3f) - [INTRINSIC:ARRAY INQUIRY] Determine the size of an array'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = size(array[, dim [, kind]])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Determine the extent of ARRAY along a specified dimension DIM,'
write(io,'(a)')'   or the total number of elements in ARRAY if DIM is absent.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   ARRAY  - Shall be an array of any type. If ARRAY is a pointer it'
write(io,'(a)')'            must be associated and allocatable arrays must be allocated.'
write(io,'(a)')'   DIM  - (Optional) shall be a scalar of type INTEGER and its'
write(io,'(a)')'          value shall be in the range from 1 to n, where n equals the rank of'
write(io,'(a)')'ARRAY.'
write(io,'(a)')'   KIND  - (Optional) An INTEGER initialization expression'
write(io,'(a)')'           indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER and of kind KIND. If'
write(io,'(a)')'   KIND is absent, the return value is of default integer kind.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_size'
write(io,'(a)')'    integer :: arr(0:2,-5:5)=reshape([(((i-1)*11+j,i=1,3),j=1,11)],[3,11])'
write(io,'(a)')'       write(*,*) ''SIZE of simple one-dimensional array='',size([ 11, 22, 33 ])    ! 3'
write(io,'(a)')''
write(io,'(a)')'       write(*,*)''body'''
write(io,'(a)')'       write(*,*)''SHAPE(arr)       :'',shape(arr)'
write(io,'(a)')'       write(*,*)''SIZE(arr)        :'',size(arr)'
write(io,'(a)')'       write(*,*)''SIZE(arr,DIM=1)  :'',size(arr,dim=1)'
write(io,'(a)')'       write(*,*)''SIZE(arr,DIM=2)  :'',size(arr,dim=2)'
write(io,'(a)')'       write(*,*)''note lower bound is not "1"'''
write(io,'(a)')'       write(*,*)''LBOUND(arr)      :'',lbound(arr)'
write(io,'(a)')'       write(*,*)''UBOUND(arr)      :'',ubound(arr)'
write(io,'(a)')'       write(*,*)''LBOUND(arr,DIM=1):'',lbound(arr,dim=1)'
write(io,'(a)')'       write(*,*)''UBOUND(arr,DIM=1):'',ubound(arr,dim=1)'
write(io,'(a)')'       write(*,*)''LBOUND(arr,DIM=2):'',lbound(arr,dim=2)'
write(io,'(a)')'       write(*,*)''UBOUND(arr,DIM=2):'',ubound(arr,dim=2)'
write(io,'(a)')''
write(io,'(a)')'       call interfaced(arr,arr)'
write(io,'(a)')'       call nointerface(arr)'
write(io,'(a)')'    contains'
write(io,'(a)')''
write(io,'(a)')'    subroutine interfaced(arr,arr2)'
write(io,'(a)')'    integer,intent(in)  :: arr(:,:)'
write(io,'(a)')'    integer,intent(in)  :: arr2(2,*)'
write(io,'(a)')'       write(*,*)''interfaced assumed-shape array'''
write(io,'(a)')'       write(*,*)''SHAPE(arr)       :'',shape(arr)'
write(io,'(a)')'       write(*,*)''SIZE(arr)        :'',size(arr)'
write(io,'(a)')'       write(*,*)''SIZE(arr,DIM=1)  :'',size(arr,dim=1)'
write(io,'(a)')'       write(*,*)''SIZE(arr,DIM=2)  :'',size(arr,dim=2)'
write(io,'(a)')'       write(*,*)''note lower bound is "1"'''
write(io,'(a)')'       write(*,*)''LBOUND(arr)      :'',lbound(arr)'
write(io,'(a)')'       write(*,*)''LBOUND(arr)      :'',lbound(arr)'
write(io,'(a)')'       write(*,*)''UBOUND(arr)      :'',ubound(arr)'
write(io,'(a)')'       write(*,*)''LBOUND(arr,DIM=1):'',lbound(arr,dim=1)'
write(io,'(a)')'       write(*,*)''UBOUND(arr,DIM=1):'',ubound(arr,dim=1)'
write(io,'(a)')'       write(*,*)''LBOUND(arr,DIM=2):'',lbound(arr,dim=2)'
write(io,'(a)')'       write(*,*)''UBOUND(arr,DIM=2):'',ubound(arr,dim=2)'
write(io,'(a)')'       write(*,*)''interfaced'''
write(io,'(a)')'       write(*,*)''SHAPE(arr)       :'',shape(arr)'
write(io,'(a)')'       write(*,*)''SIZE(arr)        :'',size(arr)'
write(io,'(a)')'       write(*,*)''SIZE(arr,DIM=1)  :'',size(arr,dim=1)'
write(io,'(a)')'       write(*,*)''SIZE(arr,DIM=2)  :'',size(arr,dim=2)'
write(io,'(a)')'       write(*,*)''note lower bound is "1"'''
write(io,'(a)')'       write(*,*)''LBOUND(arr)      :'',lbound(arr)'
write(io,'(a)')'       write(*,*)''LBOUND(arr)      :'',lbound(arr)'
write(io,'(a)')'       write(*,*)''UBOUND(arr)      :'',ubound(arr)'
write(io,'(a)')'       write(*,*)''LBOUND(arr,DIM=1):'',lbound(arr,dim=1)'
write(io,'(a)')'       write(*,*)''UBOUND(arr,DIM=1):'',ubound(arr,dim=1)'
write(io,'(a)')'       write(*,*)''LBOUND(arr,DIM=2):'',lbound(arr,dim=2)'
write(io,'(a)')'       write(*,*)''UBOUND(arr,DIM=2):'',ubound(arr,dim=2)'
write(io,'(a)')'    end subroutine interfaced'
write(io,'(a)')'    !!'
write(io,'(a)')'    ! NOTE: If NOINTERFACE(3f) had an assumed-shape argument with : for dimensions it'
write(io,'(a)')'    !       could only be properly called with an explicit interface'
write(io,'(a)')'    !!'
write(io,'(a)')'    subroutine nointerface(arr)'
write(io,'(a)')'    integer,intent(in) :: arr(3,*)'
write(io,'(a)')'       write(*,*)''nointerface'''
write(io,'(a)')'     !!write(*,*)''SHAPE(arr)       :'',shape(arr)  !! SHAPE(3f) CANNOT BE USED ON AN ASSUMED SIZE ARRAY'
write(io,'(a)')'     !!write(*,*)''SIZE(arr)        :'',size(arr)'
write(io,'(a)')'       write(*,*)''SIZE(arr,DIM=1)  :'',size(arr,dim=1)'
write(io,'(a)')'     !!write(*,*)''SIZE(arr,DIM=2)  :'',size(arr,dim=2) !! CANNOT DETERMINE SIZE OF ASSUMED SIZE ARRAY LAST DIMENSI'
write(io,'(a)')'       write(*,*)''note lower bound is "1"'''
write(io,'(a)')'       write(*,*)''LBOUND(arr)      :'',lbound(arr)'
write(io,'(a)')'     !!write(*,*)''UBOUND(arr)      :'',ubound(arr)'
write(io,'(a)')'       write(*,*)''LBOUND(arr,DIM=1):'',lbound(arr,dim=1)'
write(io,'(a)')'       write(*,*)''UBOUND(arr,DIM=1):'',ubound(arr,dim=1)'
write(io,'(a)')'       write(*,*)''LBOUND(arr,DIM=2):'',lbound(arr,dim=2)'
write(io,'(a)')'     !!write(*,*)''UBOUND(arr,DIM=2):'',ubound(arr,dim=2)'
write(io,'(a)')'    end subroutine nointerface'
write(io,'(a)')'    !!'
write(io,'(a)')'    end program demo_size'
write(io,'(a)')''
write(io,'(a)')'  Expected results:'
write(io,'(a)')''
write(io,'(a)')'    SIZE of simple one-dimensional array=           3'
write(io,'(a)')'    body'
write(io,'(a)')'    SHAPE(arr)       :           3          11'
write(io,'(a)')'    SIZE(arr)        :          33'
write(io,'(a)')'    SIZE(arr,DIM=1)  :           3'
write(io,'(a)')'    SIZE(arr,DIM=2)  :          11'
write(io,'(a)')'    note lower bound is not "1"'
write(io,'(a)')'    LBOUND(arr)      :           0          -5'
write(io,'(a)')'    UBOUND(arr)      :           2           5'
write(io,'(a)')'    LBOUND(arr,DIM=1):           0'
write(io,'(a)')'    UBOUND(arr,DIM=1):           2'
write(io,'(a)')'    LBOUND(arr,DIM=2):          -5'
write(io,'(a)')'    UBOUND(arr,DIM=2):           5'
write(io,'(a)')'    interfaced assumed-shape array'
write(io,'(a)')'    SHAPE(arr)       :           3          11'
write(io,'(a)')'    SIZE(arr)        :          33'
write(io,'(a)')'    SIZE(arr,DIM=1)  :           3'
write(io,'(a)')'    SIZE(arr,DIM=2)  :          11'
write(io,'(a)')'    note lower bound is "1"'
write(io,'(a)')'    LBOUND(arr)      :           1           1'
write(io,'(a)')'    LBOUND(arr)      :           1           1'
write(io,'(a)')'    UBOUND(arr)      :           3          11'
write(io,'(a)')'    LBOUND(arr,DIM=1):           1'
write(io,'(a)')'    UBOUND(arr,DIM=1):           3'
write(io,'(a)')'    LBOUND(arr,DIM=2):           1'
write(io,'(a)')'    UBOUND(arr,DIM=2):          11'
write(io,'(a)')'    interfaced'
write(io,'(a)')'    SHAPE(arr)       :           3          11'
write(io,'(a)')'    SIZE(arr)        :          33'
write(io,'(a)')'    SIZE(arr,DIM=1)  :           3'
write(io,'(a)')'    SIZE(arr,DIM=2)  :          11'
write(io,'(a)')'    note lower bound is "1"'
write(io,'(a)')'    LBOUND(arr)      :           1           1'
write(io,'(a)')'    LBOUND(arr)      :           1           1'
write(io,'(a)')'    UBOUND(arr)      :           3          11'
write(io,'(a)')'    LBOUND(arr,DIM=1):           1'
write(io,'(a)')'    UBOUND(arr,DIM=1):           3'
write(io,'(a)')'    LBOUND(arr,DIM=2):           1'
write(io,'(a)')'    UBOUND(arr,DIM=2):          11'
write(io,'(a)')'    nointerface'
write(io,'(a)')'    SIZE(arr,DIM=1)  :           3'
write(io,'(a)')'    note lower bound is "1"'
write(io,'(a)')'    LBOUND(arr)      :           1           1'
write(io,'(a)')'    LBOUND(arr,DIM=1):           1'
write(io,'(a)')'    UBOUND(arr,DIM=1):           3'
write(io,'(a)')'    LBOUND(arr,DIM=2):           1'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later, with KIND argument [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[shape]], [[reshape]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'   sngl(3f) - [INTRINSIC] Convert double precision real to default real'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'   result = sngl(a)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   sngl(a) converts the double precision real A to a default real'
write(io,'(a)')'   value. This is an archaic form of REAL that is specific to one type'
write(io,'(a)')'   for A.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')'   A  - The type shall be a double precision REAL.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')'   The return value is of type default REAL.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')'   Elemental function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')'   [[dble]]'
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     spacing(3f) - [INTRINSIC:MODEL_COMPONENTS] Smallest distance between two numbers of a given type'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = spacing(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Determines the distance between the argument X and the nearest'
write(io,'(a)')'   adjacent number of the same type.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - Shall be of type REAL.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The result is of the same type as the input argument X.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_spacing'
write(io,'(a)')'      integer, parameter :: sgl = selected_real_kind(p=6, r=37)'
write(io,'(a)')'      integer, parameter :: dbl = selected_real_kind(p=13, r=200)'
write(io,'(a)')''
write(io,'(a)')'      write(*,*) spacing(1.0_sgl)      ! "1.1920929e-07"          on i686'
write(io,'(a)')'      write(*,*) spacing(1.0_dbl)      ! "2.220446049250313e-016" on i686'
write(io,'(a)')'    end program demo_spacing'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Elemental function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[rrspacing]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     spread(3f) - [INTRINSIC:ARRAY CONSTRUCTION] Add a dimension to an array'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = spread(source, dim, ncopies)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Replicates a SOURCE array NCOPIES times along a specified'
write(io,'(a)')'   dimension DIM.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   SOURCE  - Shall be a scalar or an array of any type and'
write(io,'(a)')'             a rank less than seven.'
write(io,'(a)')'   DIM   - Shall be a scalar of type INTEGER with a'
write(io,'(a)')'           value in the range from 1 to n+1, where n equals the rank of SOURCE.'
write(io,'(a)')'   NCOPIES  - Shall be a scalar of type INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The result is an array of the same type as SOURCE and has rank n+1'
write(io,'(a)')'   where n equals the rank of SOURCE.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_spread'
write(io,'(a)')'      integer :: a = 1, b(2) = (/ 1, 2 /)'
write(io,'(a)')'      write(*,*) spread(a, 1, 2)            ! "1 1"'
write(io,'(a)')'      write(*,*) spread(b, 1, 2)            ! "1 1 2 2"'
write(io,'(a)')'    end program demo_spread'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[unpack]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'     sqrt(3f) - [INTRINSIC:MATHEMATICS] Square-root function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = sqrt(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'sqrt(x) computes the square root of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type shall be REAL or COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type REAL or COMPLEX. The kind type'
write(io,'(a)')'   parameter is the same as X.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_sqrt'
write(io,'(a)')'      real(8) :: x = 2.0_8'
write(io,'(a)')'      complex :: z = (1.0, 2.0)'
write(io,'(a)')'      x = sqrt(x)'
write(io,'(a)')'      z = sqrt(z)'
write(io,'(a)')'    end program demo_sqrt'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Elemental function'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     storage_size(3f) - [INTRINSIC:BIT INQUIRY] Storage size in bits'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = storage_size(a [, kind])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Returns the storage size of argument A in bits.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   A  - Shall be a scalar or array of any type.'
write(io,'(a)')'   KIND  - (Optional) shall be a scalar integer constant expression.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The result is a scalar integer with the kind type parameter specified'
write(io,'(a)')'   by KIND (or default integer type if KIND is missing). The result'
write(io,'(a)')'   value is the size expressed in bits for an element of an array that'
write(io,'(a)')'   has the dynamic type and type parameters of A.'
write(io,'(a)')'EXAMPLES'
write(io,'(a)')'  Sample program'
write(io,'(a)')''
write(io,'(a)')'    program demo_storage_size'
write(io,'(a)')'       write(*,*)''size of integer '',storage_size(0)'
write(io,'(a)')'       write(*,*)''size of real    '',storage_size(0.0)'
write(io,'(a)')'       write(*,*)''size of logical '',storage_size(.true.)'
write(io,'(a)')'       write(*,*)''size of complex '',storage_size((0.0,0.0))'
write(io,'(a)')'       write(*,*)''size of integer array '',storage_size([0,1,2,3,4,5,6,7,8,9])'
write(io,'(a)')'    end program demo_storage_size'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Inquiry function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[c_sizeof]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     sum(3f) - [INTRINSIC] sum the elements of an array'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')' Calling sequence:'
write(io,'(a)')''
write(io,'(a)')'   result = sum(array[, mask])'
write(io,'(a)')'   result = sum(array, dim[, mask])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Adds the elements of ARRAY along dimension DIM if the'
write(io,'(a)')'   corresponding element in MASK is TRUE.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   array   - Shall be an array of type INTEGER, REAL or COMPLEX.'
write(io,'(a)')'   dim     - (Optional) shall be a scalar of type INTEGER with a value'
write(io,'(a)')'                in the range from 1 to n, where n equals the rank of ARRAY.'
write(io,'(a)')'   mask    - (Optional) shall be of type LOGICAL and either be a'
write(io,'(a)')'                scalar or an array of the same shape as ARRAY.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The result is of the same type as ARRAY.'
write(io,'(a)')''
write(io,'(a)')'   If dim(3f) is absent, a scalar with the sum of all elements in ARRAY'
write(io,'(a)')'   is returned. Otherwise, an array of rank n-1, where n equals the rank of'
write(io,'(a)')'   ARRAY, and a shape similar to that of ARRAY with dimension DIM'
write(io,'(a)')'   dropped is returned.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_sum'
write(io,'(a)')'      integer :: x(5) = (/ 1, 2, 3, 4 ,5 /)'
write(io,'(a)')'      print *, sum(x)                        ! all elements, sum = 15'
write(io,'(a)')'      print *, sum(x, mask=mod(x, 2)==1)     ! odd elements, sum = 9'
write(io,'(a)')'    end program demo_sum'
write(io,'(a)')''
write(io,'(a)')'  Demonstrate Fortran 90 SUM function with MASK option'
write(io,'(a)')''
write(io,'(a)')'      ! John Mahaffy  2/16/96'
write(io,'(a)')'      implicit none'
write(io,'(a)')'      integer nd,ndh,nduh, j'
write(io,'(a)')'      parameter (nd=10,ndh=nd/2,nduh=nd-ndh)'
write(io,'(a)')'      real csum,cpsum,cbpsum'
write(io,'(a)')'      real, dimension(nd):: c=(/(j,j=-1,nd-2)/), b'
write(io,'(a)')'      data b/ndh*-1.0,nduh*2.0/'
write(io,'(a)')'      csum= sum(c(1:nd))'
write(io,'(a)')'      cpsum= sum (c(1:nd),mask=c.gt.0)'
write(io,'(a)')'      cbpsum= sum(c(1:nd),mask=b.gt.0.0)'
write(io,'(a)')'      print *, ''Sum of all elements in c = '' , csum'
write(io,'(a)')'      print *, ''Sum of Positive elements in c = '', cpsum'
write(io,'(a)')'      print *, ''Sum of elements in c when corresponding elements in b>0'' ,'' ='',cbpsum'
write(io,'(a)')'      end'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   intrinsics'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     system_clock(3f) - [INTRINSIC:SYSTEM ENVIRONMENT] Return numeric data from a real-time clock.'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   call system_clock([count, count_rate, count_max])'
write(io,'(a)')'   integer,intent(out),optional  :: count'
write(io,'(a)')'   integer,intent(out),optional  :: count_rate'
write(io,'(a)')'      or'
write(io,'(a)')'   real,intent(out),optional     :: count_rate'
write(io,'(a)')'   integer,intent(out,optional   :: count_max'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   system_clock lets you measure durations of time with the precision'
write(io,'(a)')'   of the smallest time increment generally available on a system by'
write(io,'(a)')'   returning processor-dependent values based on the current value of the'
write(io,'(a)')'   processor clock. The CLOCK value is incremented by one for each clock'
write(io,'(a)')'   count until the value count_max is reached and is then reset to zero'
write(io,'(a)')'   at the next count. CLOCK therefore is a modulo value that lies in the'
write(io,'(a)')'   range 0 to count_max. count_rate and count_max are assumed constant'
write(io,'(a)')'   (even though CPU rates can vary on a single platform).'
write(io,'(a)')''
write(io,'(a)')'   count_rate is system dependent and can vary depending on the kind of'
write(io,'(a)')'   the arguments.'
write(io,'(a)')''
write(io,'(a)')'   If there is no clock, or querying the clock fails, COUNT is set to'
write(io,'(a)')'   -huge(count), and count_rate and count_max are set to zero.'
write(io,'(a)')''
write(io,'(a)')'   system_clock is typically used to measure short time intervals (system'
write(io,'(a)')'   clocks may be 24-hour clocks or measure processor clock ticks since'
write(io,'(a)')'   boot, for example). It is most often used for measuring or tracking'
write(io,'(a)')'   the time spent in code blocks in lieu of using profiling tools.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'    COUNT        (optional) shall be an integer scalar.'
write(io,'(a)')'                 It is assigned a processor-dependent value based on the'
write(io,'(a)')'                 current value of the processor clock, or -HUGE (COUNT)'
write(io,'(a)')'                 if there is no clock. The processor-dependent value is'
write(io,'(a)')'                 incremented by one for each clock count until the value'
write(io,'(a)')'                 COUNT_MAX is reached and is reset to zero at the next'
write(io,'(a)')'                 count. It lies in the range 0 to COUNT_MAX if there is'
write(io,'(a)')'                 a clock.'
write(io,'(a)')'    COUNT_RATE   (optional) shall be an integer or real scalar.'
write(io,'(a)')'                 It is assigned a processor-dependent approximation'
write(io,'(a)')'                 to the number of processor clock counts per second,'
write(io,'(a)')'                 or zero if there is no clock.'
write(io,'(a)')'    COUNT_MAX    (optional) shall be an integer scalar. It is assigned the'
write(io,'(a)')'                 maximum value that COUNT can have, or zero if there is'
write(io,'(a)')'                 no clock.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'   Sample program:'
write(io,'(a)')''
write(io,'(a)')'      program demo_system_clock'
write(io,'(a)')'        integer :: count, count_rate, count_max'
write(io,'(a)')'        call system_clock(count, count_rate, count_max)'
write(io,'(a)')'        write(*,*) count, count_rate, count_max'
write(io,'(a)')'      end program demo_system_clock'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'   If the processor clock is a 24-hour clock that registers time at'
write(io,'(a)')'   approximately 18.20648193 ticks per second, at 11:30 A.M. the reference'
write(io,'(a)')''
write(io,'(a)')'      CALL SYSTEM_CLOCK (COUNT = C, COUNT_RATE = R, COUNT_MAX = M)'
write(io,'(a)')''
write(io,'(a)')'   defines'
write(io,'(a)')''
write(io,'(a)')'      C = (11*3600+30*60)*18.20648193 = 753748,'
write(io,'(a)')'      R = 18.20648193, and'
write(io,'(a)')'      M = 24*3600*18.20648193-1 = 1573039.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Subroutine'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[date_and_time]], [[cpu_time]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     tan(3f) - [INTRINSIC:TRIGONOMETRIC] Tangent function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = tan(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   tan(x) computes the tangent of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type shall be REAL or COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value has same type and kind as X.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_tan'
write(io,'(a)')'     real(8) :: x = 0.165_8'
write(io,'(a)')'     x = tan(x)'
write(io,'(a)')'   end program demo_tan'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later. For a complex argument, [[Fortran 2008]] or later.'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[atan]], [[cos]], [[sin]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     tanh(3f) - [INTRINSIC:TRIGONOMETRIC] Hyperbolic tangent function'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'x = tanh(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   tanh(x) computes the hyperbolic tangent of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - The type shall be REAL or COMPLEX.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value has same type and kind as X. If X is'
write(io,'(a)')'   complex, the imaginary part of the result is in radians. If X'
write(io,'(a)')'   is REAL, the return value lies in the range'
write(io,'(a)')''
write(io,'(a)')'      -1 <= tanh(x) <= 1.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_tanh'
write(io,'(a)')'     real(8) :: x = 2.1_8'
write(io,'(a)')'     x = tanh(x)'
write(io,'(a)')'   end program demo_tanh'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[FORTRAN 77]] and later, for a complex argument [[Fortran 2008]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental procedure|Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[atanh]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     this_image(3f) - [INTRINSIC] Cosubscript index of this image'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = this_image()'
write(io,'(a)')'   result = this_image(distance)'
write(io,'(a)')'   result = this_image(coarray [, dim])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'Returns the cosubscript for this image.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  DISTANCE  - (optional, intent(in)) Nonnegative scalar integer'
write(io,'(a)')'  (not permitted together with COARRAY).'
write(io,'(a)')'  COARRAY  - Coarray of any type (optional; if DIM present,'
write(io,'(a)')'  required).'
write(io,'(a)')'  DIM  - default integer scalar (optional). If present, DIM shall'
write(io,'(a)')'  be between one and the corank of COARRAY.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   Default integer. If COARRAY is not present, it is scalar; if'
write(io,'(a)')'   DISTANCE is not present or has value 0, its value is the image index'
write(io,'(a)')'   on the invoking image for the current team, for values smaller or'
write(io,'(a)')'   equal distance to the initial team, it returns the image index on the'
write(io,'(a)')'   ancestor team which has a distance of DISTANCE from the invoking'
write(io,'(a)')'   team. If DISTANCE is larger than the distance to the initial team,'
write(io,'(a)')'   the image index of the initial team is returned. Otherwise when the'
write(io,'(a)')'   COARRAY is present, if DIM is not present, a rank-1 array with'
write(io,'(a)')'   corank elements is returned, containing the cosubscripts for COARRAY'
write(io,'(a)')'   specifying the invoking image. If DIM is present, a scalar is'
write(io,'(a)')'   returned, with the value of the DIM element of'
write(io,'(a)')'   this_image(coarray).'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'   integer :: value[*]'
write(io,'(a)')'   integer :: i'
write(io,'(a)')'   value = this_image()'
write(io,'(a)')'   sync all'
write(io,'(a)')'   if (this_image() == 1) then'
write(io,'(a)')'     do i = 1, num_images()'
write(io,'(a)')'       write(*,''(2(a,i0))'') ''value['', i, ''] is '', value[i]'
write(io,'(a)')'     end do'
write(io,'(a)')'   end if'
write(io,'(a)')''
write(io,'(a)')'   ! Check whether the current image is the initial image'
write(io,'(a)')'   if (this_image(huge(1)) /= this_image())'
write(io,'(a)')'   error stop "something is rotten here"'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later. With DISTANCE argument, [[TS 18508]] or later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[num_images]], [[image_index]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     tiny(3f) - [INTRINSIC] Smallest positive number of a real kind'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = tiny(x)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   tiny(x) returns the smallest positive (non zero) number'
write(io,'(a)')'   in the model of the type of X.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   X  - Shall be of type REAL.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of the same type and kind as X'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_huge_tiny'
write(io,'(a)')'      print *, huge(0), huge(0.0), huge(0.0d0)'
write(io,'(a)')'      print *, tiny(0.0), tiny(0.0d0)'
write(io,'(a)')'    end program demo_huge_tiny'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     trailz(3f) - [INTRINSIC:BIT INQUIRY] Number of trailing zero bits of an integer'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = trailz(i)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'  TRAILZ returns the number of trailing zero bits of an integer.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   I  - Shall be of type INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The type of the return value is the default INTEGER.'
write(io,'(a)')'   If all the bits of I are zero, the result value is bit_size(i).'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_trailz'
write(io,'(a)')'      write (*,*) trailz(8)  ! prints 3'
write(io,'(a)')'    end program demo_trailz'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[bit_size]], [[popcnt]], [[poppar]], [[leadz]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     transfer(3f) - [INTRINSIC:BIT MANIPULATION] Transfer bit patterns'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = transfer(source, mold[, size])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Interprets the bitwise representation of SOURCE in memory as if it'
write(io,'(a)')'   is the representation of a variable or array of the same type and type'
write(io,'(a)')'   parameters as MOLD.'
write(io,'(a)')''
write(io,'(a)')'   This is approximately equivalent to the C concept of *casting* one'
write(io,'(a)')'   type to another.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   SOURCE  - Shall be a scalar or an array of any type.'
write(io,'(a)')'   MOLD  - Shall be a scalar or an array of any type.'
write(io,'(a)')'   SIZE  - (Optional) shall be a scalar of type INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The result has the same type as MOLD, with the bit level'
write(io,'(a)')'   representation of SOURCE. If SIZE is present, the result is'
write(io,'(a)')'   a one-dimensional array of length SIZE. If SIZE is absent'
write(io,'(a)')'   but MOLD is an array (of any size or shape), the result is a one-dimensional'
write(io,'(a)')'   array of the minimum length needed to contain the entirety'
write(io,'(a)')'   of the bitwise representation of SOURCE. If SIZE is absent'
write(io,'(a)')'   and MOLD is a scalar, the result is a scalar.'
write(io,'(a)')''
write(io,'(a)')'   If the bitwise representation of the result is longer than that of'
write(io,'(a)')'   SOURCE, then the leading bits of the result correspond to those of'
write(io,'(a)')'   SOURCE and any trailing bits are filled arbitrarily.'
write(io,'(a)')''
write(io,'(a)')'   When the resulting bit representation does not correspond to a valid'
write(io,'(a)')'   representation of a variable of the same type as MOLD, the results'
write(io,'(a)')'   are undefined, and subsequent operations on the result cannot be'
write(io,'(a)')'   guaranteed to produce sensible behavior. For example, it is possible to'
write(io,'(a)')'   create LOGICAL variables for which VAR and'
write(io,'(a)')'   .not. var both appear to be true.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_transfer'
write(io,'(a)')'      integer :: x = 2143289344'
write(io,'(a)')'      print *, transfer(x, 1.0)    ! prints "nan" on i686'
write(io,'(a)')'    end program demo_transfer'
write(io,'(a)')''
write(io,'(a)')'COMMENTS'
write(io,'(a)')''
write(io,'(a)')'   [[Joe Krahn]]: Fortran uses **molding** rather than **casting**.'
write(io,'(a)')''
write(io,'(a)')'   Casting, as in C, is an in-place reinterpretation. A cast is a device'
write(io,'(a)')'   that is built around an object to change it''s shape.'
write(io,'(a)')''
write(io,'(a)')'   Fortran TRANSFER reinterprets data out-of-place. It can be considered'
write(io,'(a)')'   **molding** rather than casting. A **mold** is a device that confers a'
write(io,'(a)')'   shape onto an object placed into it.'
write(io,'(a)')''
write(io,'(a)')'   The advantage of molding is that data is always valid in the context'
write(io,'(a)')'   of the variable that holds it. For many cases, a decent compiler should'
write(io,'(a)')'   optimize TRANSFER into a simple assignment.'
write(io,'(a)')''
write(io,'(a)')'   There are disadvantages of this approach. It is problematic to define a'
write(io,'(a)')'   union of data types because you must know the largest data object, which'
write(io,'(a)')'   can vary by compiler or compile options. In many cases, an EQUIVALENCE'
write(io,'(a)')'   would be far more effective, but Fortran Standards committees seem'
write(io,'(a)')'   oblivious to the benefits of EQUIVALENCEs when used sparingly.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 90]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     transpose(3f) - [INTRINSIC:ARRAY MANIPULATION] Transpose an array of rank two'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = transpose(matrix)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Transpose an array of rank two. Element (i, j) of the result has the value'
write(io,'(a)')'   matrix(j, i), for all i, j.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   MATRIX  - Shall be an array of any type and have a rank of two.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The result has the same type as MATRIX, and has shape'
write(io,'(a)')'   (/ m, n /) if MATRIX has shape (/ n, m /).'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   Fortran 95 and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     trim(3f) - [INTRINSIC:CHARACTER] Remove trailing blank characters of a string'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = trim(string)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Removes trailing blank characters of a string.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   STRING  - Shall be a scalar of type CHARACTER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   A scalar of type CHARACTER which length is that of STRING'
write(io,'(a)')'   less the number of trailing blanks.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_trim'
write(io,'(a)')'      character(len=10), parameter :: s = "gfortran  "'
write(io,'(a)')'      write(*,*) len(s), len(trim(s))  ! "10 8", with/without trailing blanks'
write(io,'(a)')'    end program demo_trim'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[adjustl]], [[adjustr]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     ubound(3f) - [INTRINSIC:ARRAY INQUIRY] Upper dimension bounds of an array'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = ubound(array [, dim [, kind]])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Returns the upper bounds of an array, or a single upper bound'
write(io,'(a)')'   along the DIM dimension.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   ARRAY  - Shall be an array, of any type.'
write(io,'(a)')'   DIM    - (Optional) Shall be a scalar INTEGER.'
write(io,'(a)')'   KIND   - (Optional) An INTEGER initialization expression'
write(io,'(a)')'            indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER and of kind KIND. If'
write(io,'(a)')'   KIND is absent, the return value is of default integer kind.'
write(io,'(a)')'   If DIM is absent, the result is an array of the upper bounds of'
write(io,'(a)')'   ARRAY. If DIM is present, the result is a scalar'
write(io,'(a)')'   corresponding to the upper bound of the array along that dimension. If'
write(io,'(a)')'   ARRAY is an expression rather than a whole array or array'
write(io,'(a)')'   structure component, or if it has a zero extent along the relevant'
write(io,'(a)')'   dimension, the upper bound is taken to be the number of elements along'
write(io,'(a)')'   the relevant dimension.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later, with KIND argument [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Inquiry function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[lbound]], [[co_ubound]], [[co_lbound]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     CO_UBOUND(3f) - [INTRINSIC] Upper codimension bounds of an array'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = CO_UBOUND(coarray [, dim [, kind]])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Returns the upper cobounds of a coarray, or a single upper cobound'
write(io,'(a)')'   along the DIM codimension.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   ARRAY  - Shall be an coarray, of any type.'
write(io,'(a)')'   DIM    - (Optional) Shall be a scalar INTEGER.'
write(io,'(a)')'   KIND   - (Optional) An INTEGER initialization expression indicating'
write(io,'(a)')'            the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER and of kind KIND. If KIND is'
write(io,'(a)')'   absent, the return value is of default integer kind. If DIM is'
write(io,'(a)')'   absent, the result is an array of the lower cobounds of COARRAY. If'
write(io,'(a)')'   DIM is present, the result is a scalar corresponding to the lower'
write(io,'(a)')'   cobound of the array along that codimension.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Inquiry function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[co_lbound]], [[lbound]], [[ubound]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     unpack(3f) - [INTRINSIC:ARRAY CONSTRUCTION] Store the elements of a vector in an array of higher rank'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = unpack(vector, mask, field)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Store the elements of VECTOR in an array of higher rank.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   VECTOR  - Shall be an array of any type and rank one. It shall'
write(io,'(a)')'   have at least as many elements as MASK has TRUE values.'
write(io,'(a)')'   MASK   - Shall be an array of type LOGICAL.'
write(io,'(a)')'   FIELD  - Shall be of the same type as VECTOR and have the same'
write(io,'(a)')'   shape as MASK.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The resulting array corresponds to FIELD with TRUE elements'
write(io,'(a)')'   of MASK replaced by values from VECTOR in array element order.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample program:'
write(io,'(a)')''
write(io,'(a)')'    program demo_unpack'
write(io,'(a)')'      integer :: vector(2)  = (/1,1/)'
write(io,'(a)')'      logical :: mask(4)  = (/ .true., .false., .false., .true. /)'
write(io,'(a)')'      integer :: field(2,2) = 0, unity(2,2)'
write(io,'(a)')''
write(io,'(a)')'      ! result: unity matrix'
write(io,'(a)')'      unity = unpack(vector, reshape(mask, (/2,2/)), field)'
write(io,'(a)')'    end program demo_unpack'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   Fortran 95 and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Transformational function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[pack]], [[spread]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'     verify(3f) - [INTRINSIC:CHARACTER] Scan a string for the absence of a set of characters'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = verify(string, set[, back [, kind]])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Verifies that all the characters in STRING belong to the set of'
write(io,'(a)')'   characters in SET.'
write(io,'(a)')''
write(io,'(a)')'   If BACK is either absent or equals FALSE, this function returns'
write(io,'(a)')'   the position of the leftmost character of STRING that is not in'
write(io,'(a)')'   SET. If BACK equals TRUE, the rightmost position is returned. If'
write(io,'(a)')'   all characters of STRING are found in SET, the result is zero.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  STRING  - Shall be of type CHARACTER.'
write(io,'(a)')'  SET     - Shall be of type CHARACTER.'
write(io,'(a)')'  BACK    - (Optional) shall be of type LOGICAL.'
write(io,'(a)')'  KIND    - (Optional) An INTEGER initialization expression'
write(io,'(a)')'  indicating the kind parameter of the result.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER and of kind KIND. If KIND is'
write(io,'(a)')'   absent, the return value is of default integer kind.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')' Sample program:'
write(io,'(a)')''
write(io,'(a)')'   program demo_verify'
write(io,'(a)')'     write(*,*) verify("fortran", "ao")           ! 1, found ''f'''
write(io,'(a)')'     write(*,*) verify("fortran", "foo")          ! 3, found ''r'''
write(io,'(a)')'     write(*,*) verify("fortran", "c++")          ! 1, found ''f'''
write(io,'(a)')'     write(*,*) verify("fortran", "c++", .true.)  ! 7, found ''n'''
write(io,'(a)')'     write(*,*) verify("fortran", "fortran")      ! 0'' found none'
write(io,'(a)')'   end program demo_verify'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 95]] and later, with KIND argument [[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   Elemental function'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[scan]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'    DSHIFTL(3f) - [INTRINSIC:BIT MANIPULATION] combines bits of arguments I and J'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = DSHIFTL(I, J, SHIFT)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'   DSHIFTL(I, J, SHIFT) combines bits of I and J. The rightmost'
write(io,'(a)')'   SHIFT bits of the result are the leftmost SHIFT bits of J, and'
write(io,'(a)')'   the remaining bits are the rightmost bits of I.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  I       Shall be of type INTEGER.'
write(io,'(a)')'  J       Shall be of type INTEGER, and of the same kind as I.'
write(io,'(a)')'  SHIFT   Shall be of type INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value has same type and kind as I.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[dshiftr]]'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'    DSHIFTR(3f) - [INTRINSIC:BIT MANIPULATION] combines bits of arguments I and J'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = DSHIFTL(I, J, SHIFT)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   DSHIFTR(I, J, SHIFT) combines bits of I and J. The leftmost'
write(io,'(a)')'   SHIFT bits of the result are the rightmost SHIFT bits of I, and'
write(io,'(a)')'   the remaining bits are the leftmost bits of J.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  I       Shall be of type INTEGER.'
write(io,'(a)')'  J       Shall be of type INTEGER, and of the same kind as I.'
write(io,'(a)')'  SHIFT   Shall be of type INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value has same type and kind as I.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[dshiftl]]'
write(io,'(a)')'NAME'
write(io,'(a)')'    shifta(3f) - [INTRINSIC:BIT MANIPULATION] shift bits right with fill'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'   result = SHIFTA(I, SHIFT)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   Returns a value corresponding to I with all of the bits shifted right'
write(io,'(a)')'   by SHIFT places. If the absolute value of SHIFT is greater than'
write(io,'(a)')'   BIT_SIZE(I), the value is undefined. Bits shifted out from the'
write(io,'(a)')'   right end are lost. The fill is arithmetic: the bits shifted in from'
write(io,'(a)')'   the left end are equal to the leftmost bit, which in two''s complement'
write(io,'(a)')'   representation is the sign bit.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')'  I        The type shall be INTEGER.'
write(io,'(a)')'  SHIFT    The type shall be INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')'   The return value is of type INTEGER and of the same kind as I.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')'   [[shiftl]], [[shiftr]]'
write(io,'(a)')'NAME'
write(io,'(a)')''
write(io,'(a)')'    shiftl(3f) - [INTRINSIC:BIT MANIPULATION] shift bits left'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = SHIFTL(I, SHIFT)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Returns a value corresponding to I with all of the bits shifted left'
write(io,'(a)')'   by SHIFT places. If the absolute value of SHIFT is greater than'
write(io,'(a)')'   BIT_SIZE(I), the value is undefined. Bits shifted out from the left'
write(io,'(a)')'   end are lost, and bits shifted in from the right end are set to 0.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'  I       The type shall be INTEGER.'
write(io,'(a)')'  SHIFT   The type shall be INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER and of the same kind as I.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[shifta]], [[shiftr]]'
write(io,'(a)')'NAME'
write(io,'(a)')'    shiftr(3f) - [INTRINSIC:BIT MANIPULATION] shift bits right'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'   result = SHIFTR(I, SHIFT)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Returns a value corresponding to I with all of the bits shifted right'
write(io,'(a)')'   by SHIFT places. If the absolute value of SHIFT is greater than'
write(io,'(a)')'   BIT_SIZE(I), the value is undefined. Bits shifted out from the right'
write(io,'(a)')'   end are lost, and bits shifted in from the left end are set to 0.'
write(io,'(a)')''
write(io,'(a)')'ARGUMENTS'
write(io,'(a)')''
write(io,'(a)')'   - I - The type shall be INTEGER.'
write(io,'(a)')'   - SHIFT - The type shall be INTEGER.'
write(io,'(a)')''
write(io,'(a)')'RETURN VALUE'
write(io,'(a)')''
write(io,'(a)')'   The return value is of type INTEGER and of the same kind as I.'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'   [[Fortran 2008]] and later'
write(io,'(a)')''
write(io,'(a)')'CLASS'
write(io,'(a)')''
write(io,'(a)')'   [[Elemental function]]'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'   [[shifta]], [[shiftl]]'
write(io,'(a)')''
write(io,'(a)')'EXAMPLES SECTION'
write(io,'(a)')''
write(io,'(a)')' XXXXXXX XXX XXX   XX    XX   XX XXXXXX  XXXXX   XXXXXXX  XXXXX'
write(io,'(a)')'  X    X  X   X     X     X   X   X    X   X      X    X X     X'
write(io,'(a)')'  X        X X      X     XX XX   X    X   X      X      X'
write(io,'(a)')'  X  X     X X     X X    XX XX   X    X   X      X  X   X'
write(io,'(a)')'  XXXX      X      X X    X X X   XXXXX    X      XXXX    XXXXX'
write(io,'(a)')'  X  X     X X    X   X   X X X   X        X      X  X         X'
write(io,'(a)')'  X        X X    XXXXX   X   X   X        X      X            X'
write(io,'(a)')'  X    X  X   X   X   X   X   X   X        X   X  X    X X     X'
write(io,'(a)')' XXXXXXX XXX XXX XXX XXX XXX XXX XXXX    XXXXXXX XXXXXXX  XXXXX'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'Array_Constructors(7f) - [FORTRAN] An array constructor can be used to create and assign values to rank-one arrays'
write(io,'(a)')'SYNTAX'
write(io,'(a)')'An array constructor takes the following form:'
write(io,'(a)')''
write(io,'(a)')'   (/ac-value-list/)'
write(io,'(a)')'   [ac-value-list]'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'OPTIONS'
write(io,'(a)')''
write(io,'(a)')'ac-value-list  Is a list of one or more expressions or implied-DO loops. Each ac-value'
write(io,'(a)')'               must have the same type and kind parameters, and be separated by commas.'
write(io,'(a)')''
write(io,'(a)')'implied-do     An implied-DO loop in an array constructor takes the following form:'
write(io,'(a)')''
write(io,'(a)')'                (ac-value-list, do-variable = expr1, expr2 [,expr3])'
write(io,'(a)')''
write(io,'(a)')'do-variable    Is the name of a scalar integer variable. Its scope is that of the implied-DO loop.'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'expr           Is a scalar integer expression. The expr1 and expr2 specify a range of'
write(io,'(a)')'               values for the loop; expr3 specifies the stride. The expr3 must be a'
write(io,'(a)')'               nonzero value; if it is omitted, it is assumed to be 1.'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'Description'
write(io,'(a)')''
write(io,'(a)')'The array constructed has the same type as the ac-value-list expressions.'
write(io,'(a)')''
write(io,'(a)')'If the sequence of values specified by the array constructor is empty'
write(io,'(a)')'(an empty array expression or the implied-DO loop produces no values),'
write(io,'(a)')'the rank-one array has a size of zero.'
write(io,'(a)')''
write(io,'(a)')'An ac-value is interpreted as follows:'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'Form of ac-value     Result'
write(io,'(a)')''
write(io,'(a)')'A scalar expression  Its value is an element of the new array.'
write(io,'(a)')'An array expression  The values of the elements in the expression (in'
write(io,'(a)')'                     array element order) are the corresponding sequence of elements in the'
write(io,'(a)')'                     new array.'
write(io,'(a)')'An implied-DO loop   It is expanded to form a list of array elements'
write(io,'(a)')'                     under control of the DO variable (like a DO construct).'
write(io,'(a)')''
write(io,'(a)')'The following shows the three forms of an ac-value:'
write(io,'(a)')''
write(io,'(a)')'  C1 = (/4,8,7,6/)                  ! A scalar expression'
write(io,'(a)')'  C2 = (/B(I, 1:5), B(I:J, 7:9)/)   ! An array expression'
write(io,'(a)')'  C3 = (/(I, I=1, 4)/)              ! An implied-DO loop'
write(io,'(a)')''
write(io,'(a)')'You can also mix these forms, for example:'
write(io,'(a)')''
write(io,'(a)')'  C4 = (/4, A(1:5), (I, I=1, 4), 7/)'
write(io,'(a)')''
write(io,'(a)')'If every expression in an array constructor is a constant expression,'
write(io,'(a)')'the array constructor is a constant expression.'
write(io,'(a)')''
write(io,'(a)')'If the expressions are of type character, Fortran 95/90 requires each'
write(io,'(a)')'expression to have the same character length.'
write(io,'(a)')''
write(io,'(a)')'However, Intel Fortran allows the character expressions to be of different'
write(io,'(a)')'character lengths. The length of the resultant character array is the'
write(io,'(a)')'maximum of the lengths of the individual character expressions. For'
write(io,'(a)')'example:'
write(io,'(a)')''
write(io,'(a)')'   print *,len ( (/''a'',''ab'',''abc'',''d''/) )'
write(io,'(a)')'   print *,''++''//(/''a'',''ab'',''abc'',''d''/)//''--'''
write(io,'(a)')''
write(io,'(a)')'This causes the following to be displayed:'
write(io,'(a)')''
write(io,'(a)')'           3'
write(io,'(a)')' ++a  --++ab --++abc--++d  --'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'If an implied-DO loop is contained within another implied-DO loop'
write(io,'(a)')'(nested), they cannot have the same DO variable (do-variable).'
write(io,'(a)')''
write(io,'(a)')'To define arrays of more than one dimension, use the RESHAPE intrinsic'
write(io,'(a)')'function.'
write(io,'(a)')''
write(io,'(a)')'The following are alternative forms for array constructors:'
write(io,'(a)')''
write(io,'(a)')'Square brackets (instead of parentheses and slashes) to enclose'
write(io,'(a)')'array constructors; for example, the following two array constructors'
write(io,'(a)')'are equivalent:'
write(io,'(a)')''
write(io,'(a)')'  INTEGER C(4)'
write(io,'(a)')'  C = (/4,8,7,6/)'
write(io,'(a)')'  C = [4,8,7,6]'
write(io,'(a)')''
write(io,'(a)')'EXAMPLES'
write(io,'(a)')''
write(io,'(a)')'The following example shows an array constructor using an implied-DO loop:'
write(io,'(a)')''
write(io,'(a)')'  INTEGER ARRAY_C(10)'
write(io,'(a)')'  ARRAY_C = (/(I, I=30, 48, 2)/)'
write(io,'(a)')''
write(io,'(a)')'The values of ARRAY_C are the even numbers 30 through 48.'
write(io,'(a)')''
write(io,'(a)')'Implied-DO expressions and values can be mixed in the value list of an'
write(io,'(a)')'array constructor. For example:'
write(io,'(a)')''
write(io,'(a)')' INTEGER A(10)'
write(io,'(a)')' A = (/1, 0, (I, I = -1, -6, -1), -7, -8 /)'
write(io,'(a)')' !Mixed values and implied-DO in value list.'
write(io,'(a)')''
write(io,'(a)')'This example sets the elements of A to the values, in order,'
write(io,'(a)')''
write(io,'(a)')'   1, 0, -1, -2, -3, -4, -5, -6, -7, -8.'
write(io,'(a)')''
write(io,'(a)')'The following example shows an array constructor of derived type that'
write(io,'(a)')'uses a structure constructor:'
write(io,'(a)')''
write(io,'(a)')'   TYPE EMPLOYEE'
write(io,'(a)')'     INTEGER ID'
write(io,'(a)')'     CHARACTER(LEN=30) NAME'
write(io,'(a)')'   END TYPE EMPLOYEE'
write(io,'(a)')''
write(io,'(a)')'   TYPE(EMPLOYEE) CC_4T(4)'
write(io,'(a)')'   CC_4T = (/EMPLOYEE(2732,"JONES"), EMPLOYEE(0217,"LEE"),     &'
write(io,'(a)')'             EMPLOYEE(1889,"RYAN"), EMPLOYEE(4339,"EMERSON")/)'
write(io,'(a)')''
write(io,'(a)')'The following example shows how the RESHAPE intrinsic function can be'
write(io,'(a)')'used to create a multidimensional array:'
write(io,'(a)')''
write(io,'(a)')'  E = (/2.3, 4.7, 6.6/)'
write(io,'(a)')'  D = RESHAPE(SOURCE = (/3.5, (/2.0, 1.0/), E/), SHAPE = (/2,3/))'
write(io,'(a)')''
write(io,'(a)')'D is a rank-two array with shape (2,3) containing the following elements:'
write(io,'(a)')''
write(io,'(a)')'   3.5    1.0    4.7'
write(io,'(a)')'   2.0    2.3    6.6'
write(io,'(a)')''
write(io,'(a)')'The following shows another example:'
write(io,'(a)')''
write(io,'(a)')' INTEGER B(2,3), C(8)'
write(io,'(a)')' ! Assign values to a (2,3) array.'
write(io,'(a)')' B = RESHAPE((/1, 2, 3, 4, 5, 6/),(/2,3/))'
write(io,'(a)')' ! Convert B to a vector before assigning values to'
write(io,'(a)')' ! vector C.'
write(io,'(a)')' C = (/ 0, RESHAPE(B,(/6/)), 7 /)'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'Example using general purpose fortran routines'
write(io,'(a)')''
write(io,'(a)')'   program demo_array_constructors ! initializing small arrays'
write(io,'(a)')'   use M_display, only : disp, disp_set'
write(io,'(a)')'   implicit none'
write(io,'(a)')'   integer :: i'
write(io,'(a)')'   integer, parameter :: yy(*) = [  10,20,30  ,  40,50,60  ] ! make some data in a vector, could type this where yy'
write(io,'(a)')'   ! xx is same thing as yy, just using syntax for filling it that makes it clearer what I want to do with the data'
write(io,'(a)')'   integer, parameter :: xx(*) = [ [10,20,30] , [40,50,60] ] ! make some data in a vector, could type this where xx'
write(io,'(a)')''
write(io,'(a)')'   integer, dimension(2,3)::aa = reshape(xx,shape(aa),order=[2,1])      ! 2d by rows using reshaped scalar expressi'
write(io,'(a)')'   integer, dimension(2,3)::bb = reshape(xx,shape(bb)             )     ! 2d by columns'
write(io,'(a)')'   integer, dimension(2,3)::cc = reshape(xx,shape(cc),order=[1,2])      ! 2d by columns'
write(io,'(a)')'   integer, dimension(2,3)::dd = reshape([(i*10,i=1,size(dd))],shape(dd)) ! an implied do by columns'
write(io,'(a)')''
write(io,'(a)')'   integer, dimension(2,3):: ff, gg, hh'
write(io,'(a)')'   ! CANNOT DO'
write(io,'(a)')'   !integer, dimension(2,3)::ff = [10,20,30,40,50,60 ]                                     ! 2d by columns'
write(io,'(a)')'   ! BUT CAN DO'
write(io,'(a)')'   data ff/10,20,30,40,50,60/  ! fill 2D with simple data statement'
write(io,'(a)')'   ! AND CAN DO'
write(io,'(a)')'   ! multi-dimensional by equivalence'
write(io,'(a)')'   integer                :: ee(2,3)'
write(io,'(a)')'   integer                :: e(size(ee))=xx'
write(io,'(a)')'   equivalence               (e(1),ee(1,1))'
write(io,'(a)')'   ! CANNOT DO'
write(io,'(a)')'   !integer, dimension(2,3)::gg = [10,20,30] , [40,50,60]'
write(io,'(a)')'   !integer, dimension(2,3)::gg = [[10,20,30] , [40,50,60]]'
write(io,'(a)')'   ! BUT CAN DO'
write(io,'(a)')'   data gg(1,:)/ 10, 20, 30 /     ! fill rows with data statements'
write(io,'(a)')'   data gg(2,:)/ 40, 50, 60 /'
write(io,'(a)')''
write(io,'(a)')'   data hh(:,1)/ 10, 40 /         ! fill columns with data statements'
write(io,'(a)')'   data hh(:,2)/ 20, 50 /'
write(io,'(a)')'   data hh(:,3)/ 30, 60 /'
write(io,'(a)')'      call disp_set(style=''left & number'')'
write(io,'(a)')''
write(io,'(a)')'      write(*,*)''SIZE(aa)='',size(aa)'
write(io,'(a)')'      write(*,*)''SHAPE(aa)='',shape(aa)'
write(io,'(a)')'      write(*,*)''xx='',xx'
write(io,'(a)')'      write(*,*)''yy='',yy'
write(io,'(a)')''
write(io,'(a)')'      call disp(''aa='',aa)'
write(io,'(a)')'      call disp(''bb='',bb)'
write(io,'(a)')'      call disp(''cc='',cc)'
write(io,'(a)')'      call disp(''dd='',dd)'
write(io,'(a)')''
write(io,'(a)')'      call disp(''ee='',ee)'
write(io,'(a)')''
write(io,'(a)')'      call disp(''ff='',ff)'
write(io,'(a)')'      call disp(''gg='',gg)'
write(io,'(a)')'      call disp(''hh='',hh)'
write(io,'(a)')''
write(io,'(a)')'      write(*,*)repeat(''='',80)'
write(io,'(a)')'      write(*,*)hh'
write(io,'(a)')'      write(*,*)repeat(''='',80)'
write(io,'(a)')'      call print_buildfmt(hh)'
write(io,'(a)')'      write(*,*)repeat(''='',80)'
write(io,'(a)')'      call print_fixedfmt(hh)'
write(io,'(a)')''
write(io,'(a)')'   contains'
write(io,'(a)')''
write(io,'(a)')'   subroutine print_buildfmt(arr)'
write(io,'(a)')'   use M_strings, only : v2s'
write(io,'(a)')'   implicit none'
write(io,'(a)')'   integer,intent(in) :: arr(:,:)'
write(io,'(a)')'   integer :: i'
write(io,'(a)')'   character(len=:),allocatable :: fmt'
write(io,'(a)')'      fmt=''("> [",''//v2s(size(arr,dim=2))//''(i0:,","),"]")'''
write(io,'(a)')'      write(*,*)''FMT='',fmt'
write(io,'(a)')'      write(*,fmt)(arr(i,:),i=1,size(arr,dim=1))'
write(io,'(a)')'   end subroutine print_buildfmt'
write(io,'(a)')''
write(io,'(a)')'   subroutine print_fixedfmt(arr)'
write(io,'(a)')'   implicit none'
write(io,'(a)')'   integer,intent(in) :: arr(:,:)'
write(io,'(a)')'   integer :: i'
write(io,'(a)')'      do i=1,size(arr,dim=1)'
write(io,'(a)')'         write(*, ''("> [",*(i0:,","))'' ,advance=''no'')arr(i,:)'
write(io,'(a)')'         write(*,''("]")'')'
write(io,'(a)')'      enddo'
write(io,'(a)')'   end subroutine print_fixedfmt'
write(io,'(a)')''
write(io,'(a)')'   end program demo_array_constructors ! initializing small arrays'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'    o DO construct'
write(io,'(a)')''
write(io,'(a)')'    o Derived types'
write(io,'(a)')''
write(io,'(a)')'    o Structure constructors'
write(io,'(a)')''
write(io,'(a)')'    o Array Elements for details on array element order'
write(io,'(a)')''
write(io,'(a)')'    o Array Assignment Statements for details on another way to assign values to arrays'
write(io,'(a)')''
write(io,'(a)')'    o Declaration Statements for Arrays for details on array specifications'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'   inquire(7f) - [FORTRAN:FILE_INQUIRE] File inquiry statement'
write(io,'(a)')''
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')''
write(io,'(a)')'   INQUIRE([UNIT=file_unit_number]|[FILE=file_name_expr])'
write(io,'(a)')''
write(io,'(a)')'    and  ACCESS = scalar_default_char_variable'
write(io,'(a)')'    or   ACTION = scalar_default_char_variable'
write(io,'(a)')'    or   ASYNCHRONOUS = scalar_default_char_variable'
write(io,'(a)')'    or   DIRECT = scalar_default_char_variable'
write(io,'(a)')''
write(io,'(a)')'    or   BLANK = scalar_default_char_variable'
write(io,'(a)')'    or   DECIMAL = scalar_default_char_variable'
write(io,'(a)')'    or   DELIM = scalar_default_char_variable'
write(io,'(a)')'    or   ENCODING = scalar_default_char_variable'
write(io,'(a)')'    or   PAD = scalar_default_char_variable'
write(io,'(a)')'    or   SIGN = scalar_default_char_variable'
write(io,'(a)')''
write(io,'(a)')'    or   ERR = label'
write(io,'(a)')'    or   IOMSG = iomsg_variable'
write(io,'(a)')'    or   IOSTAT = scalar_int_variable'
write(io,'(a)')''
write(io,'(a)')'    or   EXIST = scalar_logical_variable'
write(io,'(a)')'    or   FORM = scalar_default_char_variable'
write(io,'(a)')'    or   FORMATTED = scalar_default_char_variable'
write(io,'(a)')'    or   ID = scalar_int_expr'
write(io,'(a)')'    or   NAME = scalar_default_char_variable'
write(io,'(a)')'    or   NAMED = scalar_logical_variable'
write(io,'(a)')'    or   NEXTREC = scalar_int_variable'
write(io,'(a)')'    or   NUMBER = scalar_int_variable'
write(io,'(a)')'    or   OPENED = scalar_logical_variable'
write(io,'(a)')'    or   PENDING = scalar_logical_variable'
write(io,'(a)')'    or   POS = scalar_int_variable'
write(io,'(a)')'    or   POSITION = scalar_default_char_variable'
write(io,'(a)')'    or   READ = scalar_default_char_variable'
write(io,'(a)')'    or   READWRITE = scalar_default_char_variable'
write(io,'(a)')'    or   RECL = scalar_int_variable'
write(io,'(a)')'    or   ROUND = scalar_default_char_variable'
write(io,'(a)')'    or   SEQUENTIAL = scalar_default_char_variable'
write(io,'(a)')'    or   SIZE = scalar_int_variable'
write(io,'(a)')'    or   STREAM = scalar_default_char_variable'
write(io,'(a)')'    or   UNFORMATTED = scalar_default_char_variable'
write(io,'(a)')'    or   WRITE = scalar_default_char_variable'
write(io,'(a)')''
write(io,'(a)')'     or'
write(io,'(a)')''
write(io,'(a)')'    INQUIRE(IOLENGTH=scalar_int_variable) output_item_list'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'  The INQUIRE statement may be used to inquire about properties of a particular named file or of the connection'
write(io,'(a)')'  to a particular unit. There are three forms of the INQUIRE statement:'
write(io,'(a)')''
write(io,'(a)')'     o inquire by file, which uses the FILE= specifier'
write(io,'(a)')'     o inquire by unit, which uses the UNIT= specifier'
write(io,'(a)')'     o inquire by output list, which uses only the IOLENGTH= specifier.'
write(io,'(a)')''
write(io,'(a)')'  All specifier value assignments are performed according to the rules for assignment statements.'
write(io,'(a)')''
write(io,'(a)')'  For inquiry by unit, the unit specified need not exist or be connected to a file. If it is connected to a file, t'
write(io,'(a)')'  inquiry is being made about the connection and about the file connected.'
write(io,'(a)')''
write(io,'(a)')'  An INQUIRE statement may be executed before, while, or after a file is connected to a unit. All values assigned'
write(io,'(a)')'  by an INQUIRE statement are those that are current at the time the statement is executed.'
write(io,'(a)')''
write(io,'(a)')'  ERROR PROCESSING'
write(io,'(a)')''
write(io,'(a)')'  If an error condition occurs during execution of an INQUIRE statement, all of the inquiry specifier variables'
write(io,'(a)')'  become undefined, except for variables in the IOSTAT= and IOMSG= specifiers (if any).'
write(io,'(a)')''
write(io,'(a)')'  The IOSTAT=, ERR=, and IOMSG= specifiers are described in 9.11.'
write(io,'(a)')''
write(io,'(a)')'OPTIONS'
write(io,'(a)')''
write(io,'(a)')'  Unless constrained, the following inquiry specifiers may be used in either of the inquire by file or inquire by u'
write(io,'(a)')'  forms of the INQUIRE statement.'
write(io,'(a)')''
write(io,'(a)')'   o No specifier shall appear more than once in a given inquire_spec_list.'
write(io,'(a)')''
write(io,'(a)')'   o An inquire_spec_list shall contain one FILE= specifier or one UNIT= specifier, but not both.'
write(io,'(a)')''
write(io,'(a)')'   o In the inquire by unit form of the INQUIRE statement, if the optional characters UNIT= are omitted,'
write(io,'(a)')'     the file_unit-number shall be the first item in the inquire_spec_list.'
write(io,'(a)')''
write(io,'(a)')'   o If an ID= specifier appears in an inquire_spec_list, a PENDING= specifier shall also appear.'
write(io,'(a)')''
write(io,'(a)')'   o The label in the ERR= specifier shall be the statement label of a branch target statement that'
write(io,'(a)')'     appears in the same scoping unit as the INQUIRE statement.'
write(io,'(a)')''
write(io,'(a)')'  If file_unit-number identifies an internal unit, an error condition occurs.'
write(io,'(a)')''
write(io,'(a)')'  When a returned value of a specifier other than the NAME= specifier is of type character, the value returned is'
write(io,'(a)')'  in upper case.'
write(io,'(a)')''
write(io,'(a)')'  The specifier that receives the returned value is a a default scalar variable.'
write(io,'(a)')''
write(io,'(a)')'INPUTS'
write(io,'(a)')''
write(io,'(a)')'   FILE'
write(io,'(a)')''
write(io,'(a)')'   The value of the file_name_expr in the FILE= specifier specifies the name of the file being inquired about. The'
write(io,'(a)')'   named file need not exist or be connected to a unit. The value of the file_name_expr shall be of a form acceptab'
write(io,'(a)')'   to the processor as a file name. Any trailing blanks are ignored. The interpretation of case is processor depend'
write(io,'(a)')''
write(io,'(a)')'   UNIT'
write(io,'(a)')''
write(io,'(a)')'OUTPUTS'
write(io,'(a)')''
write(io,'(a)')'   ACCESS'
write(io,'(a)')''
write(io,'(a)')'     SEQUENTIAL if the connection is for sequential access'
write(io,'(a)')'     DIRECT     if the connection is for direct access'
write(io,'(a)')'     STREAM     if the connection is for stream access.'
write(io,'(a)')'     UNDEFINED  If there is no connection,'
write(io,'(a)')''
write(io,'(a)')'   ACTION'
write(io,'(a)')''
write(io,'(a)')'    READ       the connection is for input only,'
write(io,'(a)')'    WRITE      the connection is for output only'
write(io,'(a)')'    READWRITE  the connection is for both input and output.'
write(io,'(a)')'    UNDEFINED  if there is no connection,'
write(io,'(a)')''
write(io,'(a)')'   ASYNCHRONOUS'
write(io,'(a)')''
write(io,'(a)')'    YES        if the connection allows asynchronous input/output'
write(io,'(a)')'    NO         if the connection does not allow asynchronous input/output.'
write(io,'(a)')'    UNDEFINED  If there is no connection'
write(io,'(a)')''
write(io,'(a)')'  BLANK'
write(io,'(a)')''
write(io,'(a)')'    ZERO       blanks are interpreted as zeros on input'
write(io,'(a)')'    NULL       blanks are interpreted as a null on input'
write(io,'(a)')'    UNDEFINED  no connection or the connection is not for formatted input/output'
write(io,'(a)')''
write(io,'(a)')'  DECIMAL'
write(io,'(a)')''
write(io,'(a)')'    COMMA      treat a comma as the separator between mantisaa and decimal'
write(io,'(a)')'    POINT      use a decimal point as the separator'
write(io,'(a)')'    UNDEFINED  no connection or the connection is not for formatted input/output'
write(io,'(a)')''
write(io,'(a)')'  DELIM'
write(io,'(a)')''
write(io,'(a)')'    APOSTROPHE,  the delimiter mode in effect for a connection for formatted input/output.'
write(io,'(a)')'    QUOTE,'
write(io,'(a)')'    NONE'
write(io,'(a)')''
write(io,'(a)')'    UNDEFINED  no connection or the connection is not for formatted input/output'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'  DIRECT'
write(io,'(a)')''
write(io,'(a)')'    YES     if DIRECT is included in the set of allowed access methods for the file'
write(io,'(a)')'    NO      if DIRECT is not included in the set of allowed access methods for the file'
write(io,'(a)')'    UNKNOWN if the processor is unable to determine whether DIRECT is included in the set of'
write(io,'(a)')'              allowed access methods for the file.'
write(io,'(a)')''
write(io,'(a)')'  ENCODING'
write(io,'(a)')''
write(io,'(a)')'    UTF-8      if the connection is for formatted input/output with an encoding form of UTF-8'
write(io,'(a)')'    UNDEFINED  the connection is for unformatted input/output.'
write(io,'(a)')''
write(io,'(a)')'    If there is no connection,'
write(io,'(a)')''
write(io,'(a)')'    UTF-8        if the processor is able to determine that the encoding form of the file is UTF-8'
write(io,'(a)')'    UNKNOWN      if the processor is unable to determine the encoding form of the file'
write(io,'(a)')''
write(io,'(a)')'        NOTE'
write(io,'(a)')'        The value assigned may be something other than UTF-8, UNDEFINED,'
write(io,'(a)')'        or UNKNOWN if the processor supports other specific encoding forms'
write(io,'(a)')'        (e.g. UTF-16BE).'
write(io,'(a)')''
write(io,'(a)')'  EXIST'
write(io,'(a)')'   .true.    if there exists a file with the specified name if inquire is by FILE=filename statement'
write(io,'(a)')'             or if by UNIT=number and the specified unit exists.'
write(io,'(a)')'   .false.   otherwise, false is assigned.'
write(io,'(a)')''
write(io,'(a)')'  FORM'
write(io,'(a)')''
write(io,'(a)')'   FORMATTED    if the connection is for formatted input/output,'
write(io,'(a)')'   UNFORMATTED  if the connection is for unformatted input/output.'
write(io,'(a)')'   UNDEFINED    If there is no connection'
write(io,'(a)')''
write(io,'(a)')'  FORMATTED'
write(io,'(a)')''
write(io,'(a)')'   YES     if FORMATTED is included in the set of allowed forms for the file'
write(io,'(a)')'   NO      if FORMATTED is not included in the set of allowed forms for the file'
write(io,'(a)')'   UNKNOWN if the processor is unable to determine whether FORMATTED is included in the'
write(io,'(a)')'             set of allowed forms for the file.'
write(io,'(a)')''
write(io,'(a)')'  ID'
write(io,'(a)')''
write(io,'(a)')'   The value of the expression specified in the ID= specifier shall be the identifier of a pending data transfer op'
write(io,'(a)')'   for the specified unit. This specifier interacts with the PENDING= specifier (9.10.2.21).'
write(io,'(a)')''
write(io,'(a)')'  NAME'
write(io,'(a)')''
write(io,'(a)')'  The scalar_default_char_variable in the NAME= specifier is assigned the value of the name of the file if the file'
write(io,'(a)')'  has a name; otherwise, it becomes undefined.'
write(io,'(a)')''
write(io,'(a)')'        NOTE'
write(io,'(a)')'        If this specifier appears in an INQUIRE by file statement, its'
write(io,'(a)')'        value is not necessarily the same as the name given in the FILE='
write(io,'(a)')'        specifier. However, the value returned shall be suitable for'
write(io,'(a)')'        use as the value of the file_name_expr in the FILE= specifier'
write(io,'(a)')'        in an OPEN statement.'
write(io,'(a)')''
write(io,'(a)')'        The processor may return a file name qualified by a user'
write(io,'(a)')'        identification, device, directory, or other relevant information.'
write(io,'(a)')''
write(io,'(a)')'   The case of the characters assigned to scalar_default_char_variable is processor dependent.'
write(io,'(a)')''
write(io,'(a)')'   NAMED'
write(io,'(a)')''
write(io,'(a)')'   The scalar_logical_variable in the NAMED= specifier is assigned the value true if the file has a name; otherwise'
write(io,'(a)')'   it is assigned the value false.'
write(io,'(a)')''
write(io,'(a)')'   NEXTREC'
write(io,'(a)')''
write(io,'(a)')'   The scalar_int_variable in the NEXTREC= specifier is assigned the value n + 1, where n is the record number of'
write(io,'(a)')'   the last record read from or written to the connection for direct access. If there is a connection but no record'
write(io,'(a)')'   been read or written since the connection, the scalar_int_variable is assigned the value 1. If there is no conne'
write(io,'(a)')'   the connection is not for direct access, or the position is indeterminate because of a previous error condition,'
write(io,'(a)')'   scalar_int_variable becomes undefined. If there are pending data transfer operations for the specified unit, the'
write(io,'(a)')'   value assigned is computed as if all the pending data transfers had already completed.'
write(io,'(a)')''
write(io,'(a)')'   NUMBER'
write(io,'(a)')''
write(io,'(a)')'   The scalar_int_variable in the NUMBER= specifier is assigned the value of the external unit number of the unit'
write(io,'(a)')'   that is connected to the file. If there is no unit connected to the file, the value -1 is assigned.'
write(io,'(a)')''
write(io,'(a)')'   OPENED'
write(io,'(a)')''
write(io,'(a)')'   .true.   if the file specified is connected to a unit'
write(io,'(a)')'   .false. otherwise'
write(io,'(a)')''
write(io,'(a)')'   PAD'
write(io,'(a)')''
write(io,'(a)')'   YES,       corresponding to the pad mode in effect for a connection.'
write(io,'(a)')'   NO'
write(io,'(a)')''
write(io,'(a)')'   UNDEFINED  If there is no connection or if the connection is not for formatted input/output,'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'   PENDING'
write(io,'(a)')''
write(io,'(a)')'   The PENDING= specifier is used to determine whether previously pending asynchronous data transfers are'
write(io,'(a)')'   complete. A data transfer operation is previously pending if it is pending at the beginning of execution of the'
write(io,'(a)')'   INQUIRE statement.'
write(io,'(a)')''
write(io,'(a)')'   If an ID= specifier appears and the specified data transfer operation is complete, then the variable specified i'
write(io,'(a)')'   the PENDING= specifier is assigned the value false and the INQUIRE statement performs the wait operation'
write(io,'(a)')'   for the specified data transfer.'
write(io,'(a)')''
write(io,'(a)')'   If the ID= specifier is omitted and all previously pending data transfer operations for the specified unit are'
write(io,'(a)')'   complete, then the variable specified in the PENDING= specifier is assigned the value false and the INQUIRE'
write(io,'(a)')'   statement performs wait operations for all previously pending data transfers for the specified unit.'
write(io,'(a)')''
write(io,'(a)')'   In all other cases, the variable specified in the PENDING= specifier is assigned the value true and no wait'
write(io,'(a)')'   operations are performed; in this case the previously pending data transfers remain pending after the execution'
write(io,'(a)')'   of the INQUIRE statement.'
write(io,'(a)')''
write(io,'(a)')'        NOTE:'
write(io,'(a)')'        The processor has considerable flexibility in defining when'
write(io,'(a)')'        it considers a transfer to be complete. Any of the following'
write(io,'(a)')'        approaches could be used:'
write(io,'(a)')''
write(io,'(a)')'           o The INQUIRE statement could consider an asynchronous data'
write(io,'(a)')'             transfer to be incomplete until after'
write(io,'(a)')'             the corresponding wait operation. In this case PENDING='
write(io,'(a)')'             would always return true unless there were no previously'
write(io,'(a)')'             pending data transfers for the unit.'
write(io,'(a)')''
write(io,'(a)')'           o The INQUIRE statement could wait for all specified data'
write(io,'(a)')'             transfers to complete and then always return'
write(io,'(a)')'             false for PENDING=.'
write(io,'(a)')''
write(io,'(a)')'           o The INQUIRE statement could actually test the state of the'
write(io,'(a)')'             specified data transfer operations.'
write(io,'(a)')''
write(io,'(a)')'  POS'
write(io,'(a)')''
write(io,'(a)')'  The scalar_int_variable in the POS= specifier is assigned the number of the file storage unit immediately followi'
write(io,'(a)')'  the current position of a file connected for stream access. If the file is positioned at its terminal position, t'
write(io,'(a)')'  variable is assigned a value one greater than the number of the highest-numbered file storage unit in the file. I'
write(io,'(a)')'  the file is not connected for stream access or if the position of the file is indeterminate because of previous e'
write(io,'(a)')'  conditions, the variable becomes undefined.'
write(io,'(a)')''
write(io,'(a)')'  POSITION'
write(io,'(a)')''
write(io,'(a)')'  The scalar_default_char_variable in the POSITION= specifier is assigned the value REWIND if the connection'
write(io,'(a)')'  was opened for positioning at its initial point, APPEND if the connection was opened for positioning before its'
write(io,'(a)')'  endfile record or at its terminal point, and ASIS if the connection was opened without changing its position.'
write(io,'(a)')'  If there is no connection or if the file is connected for direct access, the scalar_default_char_variable is assi'
write(io,'(a)')'  the value UNDEFINED. If the file has been repositioned since the connection, the scalar_default_char_variable'
write(io,'(a)')'  is assigned a processor-dependent value, which shall not be REWIND unless the file is positioned at its initial'
write(io,'(a)')'  point and shall not be APPEND unless the file is positioned so that its endfile record is the next record or at i'
write(io,'(a)')'  terminal point if it has no endfile record.'
write(io,'(a)')''
write(io,'(a)')'  READ'
write(io,'(a)')''
write(io,'(a)')'  The scalar_default_char_variable in the READ= specifier is assigned the value YES if READ is included in the'
write(io,'(a)')'  set of allowed actions for the file, NO if READ is not included in the set of allowed actions for the file, and'
write(io,'(a)')'  UNKNOWN if the processor is unable to determine whether READ is included in the set of allowed actions for'
write(io,'(a)')'  the file.'
write(io,'(a)')''
write(io,'(a)')'  READWRITE'
write(io,'(a)')''
write(io,'(a)')'  The scalar_default_char_variable in the READWRITE= specifier is assigned the value YES if READWRITE is'
write(io,'(a)')'  included in the set of allowed actions for the file, NO if READWRITE is not included in the set of allowed action'
write(io,'(a)')'  for the file, and UNKNOWN if the processor is unable to determine whether READWRITE is included in the'
write(io,'(a)')'  set of allowed actions for the file.'
write(io,'(a)')''
write(io,'(a)')'  RECL'
write(io,'(a)')''
write(io,'(a)')'  The scalar_int_variable in the RECL= specifier is assigned the value of the record length of a connection for dir'
write(io,'(a)')'  access, or the value of the maximum record length of a connection for sequential access. If the connection is for'
write(io,'(a)')'  formatted input/output, the length is the number of characters for all records that contain only characters of'
write(io,'(a)')'  default kind. If the connection is for unformatted input/output, the length is measured in file storage units. If'
write(io,'(a)')'  there is no connection, or if the connection is for stream access, the scalar_int_variable becomes undefined.'
write(io,'(a)')''
write(io,'(a)')'  ROUND'
write(io,'(a)')''
write(io,'(a)')' The scalar_default_char_variable in the ROUND= specifier is assigned'
write(io,'(a)')' the value UP, DOWN, ZERO, NEAREST, COMPATIBLE, or PROCESSOR DEFINED,'
write(io,'(a)')' corresponding to the I/O rounding mode in effect for a connection for'
write(io,'(a)')' formatted input/output. If there is no connection or if the connection'
write(io,'(a)')' is not for formatted input/output, the scalar_default_char_variable'
write(io,'(a)')' is assigned the value UNDEFINED. The processor shall return the value'
write(io,'(a)')' PROCESSOR DEFINED only if the behavior of the current I/O rounding'
write(io,'(a)')' mode is different from that of the UP, DOWN,'
write(io,'(a)')' ZERO, NEAREST, and COMPATIBLE modes.'
write(io,'(a)')''
write(io,'(a)')' SEQUENTIAL'
write(io,'(a)')''
write(io,'(a)')' The scalar_default_char_variable in the SEQUENTIAL= specifier is assigned the value YES if SEQUENTIAL is'
write(io,'(a)')' included in the set of allowed access methods for the file, NO if SEQUENTIAL is not included in the set of allowed'
write(io,'(a)')' access methods for the file, and UNKNOWN if the processor is unable to determine whether SEQUENTIAL is'
write(io,'(a)')' included in the set of allowed access methods for the file.'
write(io,'(a)')''
write(io,'(a)')' SIGN'
write(io,'(a)')''
write(io,'(a)')'  The scalar_default_char_variable in the SIGN= specifier is assigned the'
write(io,'(a)')'  value PLUS, SUPPRESS, or PROCESSOR DEFINED, corresponding to the sign'
write(io,'(a)')'  mode in effect for a connection for formatted input/output. If there is'
write(io,'(a)')'  no connection, or if the connection is not for formatted input/output,'
write(io,'(a)')'  the scalar_default_char_variable is assigned the value UNDEFINED.'
write(io,'(a)')''
write(io,'(a)')'  SIZE'
write(io,'(a)')''
write(io,'(a)')'  The scalar_int_variable in the SIZE= specifier is assigned the size of the file in file storage units. If the fil'
write(io,'(a)')'  cannot be determined, the variable is assigned the value -1.'
write(io,'(a)')''
write(io,'(a)')'  For a file that may be connected for stream access, the file size is the number of the highest-numbered file stor'
write(io,'(a)')'  unit in the file.'
write(io,'(a)')''
write(io,'(a)')'  For a file that may be connected for sequential or direct access, the file size may be different from the number'
write(io,'(a)')'  storage units implied by the data in the records; the exact relationship is processor-dependent.'
write(io,'(a)')''
write(io,'(a)')'  STREAM'
write(io,'(a)')''
write(io,'(a)')'  The scalar_default_char_variable in the STREAM= specifier is assigned the value YES if STREAM is included in'
write(io,'(a)')'  the set of allowed access methods for the file, NO if STREAM is not included in the set of allowed access methods'
write(io,'(a)')'  for the file, and UNKNOWN if the processor is unable to determine whether STREAM is included in the set of'
write(io,'(a)')'  allowed access methods for the file.'
write(io,'(a)')''
write(io,'(a)')'  UNFORMATTED'
write(io,'(a)')''
write(io,'(a)')'  The scalar_default_char_variable in the UNFORMATTED= specifier is'
write(io,'(a)')'  assigned the value YES if UNFORMATTED is included in the set of allowed'
write(io,'(a)')'  forms for the file, NO if UNFORMATTED is not included in the set of'
write(io,'(a)')'  allowed forms for the file, and UNKNOWN if the processor is unable to'
write(io,'(a)')'  determine whether UNFORMATTED is included in the set of allowed forms'
write(io,'(a)')'  for the file.'
write(io,'(a)')''
write(io,'(a)')'  WRITE'
write(io,'(a)')''
write(io,'(a)')'  The scalar_default_char_variable in the WRITE= specifier is assigned the value YES if WRITE is included in the'
write(io,'(a)')'  set of allowed actions for the file, NO if WRITE is not included in the set of allowed actions for the file, and'
write(io,'(a)')'  UNKNOWN if the processor is unable to determine whether WRITE is included in the set of allowed actions for'
write(io,'(a)')'  the file.'
write(io,'(a)')''
write(io,'(a)')'INQUIRE BY OUTPUT LIST'
write(io,'(a)')''
write(io,'(a)')'  The scalar_int_variable in the IOLENGTH= specifier is assigned the processor-dependent number of file storage'
write(io,'(a)')'  units that would be required to store the data of the output list in an unformatted file. The value shall be suit'
write(io,'(a)')'  as a RECL= specifier in an OPEN statement that connects a file for unformatted direct access when there are'
write(io,'(a)')'  input/output statements with the same input/output list.'
write(io,'(a)')''
write(io,'(a)')'  The output list in an INQUIRE statement shall not contain any derived-type list items that require a defined'
write(io,'(a)')'  input/output procedure as described in subclause 9.6.3. If a derived-type list item appears in the output list, t'
write(io,'(a)')'  value returned for the IOLENGTH= specifier assumes that no defined input/output procedure will be invoked.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLES'
write(io,'(a)')'  Examples of INQUIRE statements are:'
write(io,'(a)')''
write(io,'(a)')'     INQUIRE (IOLENGTH = IOL) A (1:N)'
write(io,'(a)')'     INQUIRE (UNIT = JOAN, OPENED = LOG_01, NAMED = LOG_02, &'
write(io,'(a)')'        FORM = CHAR_VAR, IOSTAT = IOS)'
write(io,'(a)')'NAME'
write(io,'(a)')'    NAMELIST(7f) - [FORTRAN:STATEMENT] specify a group of data to be referred to by a single name in data input/out'
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'   NAMELIST /namelist-group-name/ namelist-group-object-list [[,] /namelist-group-name/'
write(io,'(a)')'            namelist-group-object-list ] ...'
write(io,'(a)')''
write(io,'(a)')'            namelist-group-object is variable-name'
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   A NAMELIST statement specifies a group of named data objects, which'
write(io,'(a)')'   may be referred to by a single name for the purpose of data transfer.'
write(io,'(a)')''
write(io,'(a)')'   The order in which the variables are specified in the NAMELIST'
write(io,'(a)')'   statement determines the order in which the values appear on output.'
write(io,'(a)')''
write(io,'(a)')'    o The namelist-group-name shall not be a name accessed by use association.'
write(io,'(a)')'    o A namelist-group-object shall not be an assumed-size array.'
write(io,'(a)')'    o A namelist-group-object shall not have the PRIVATE attribute if'
write(io,'(a)')'      the namelist-group-name has the PUBLIC attribute.'
write(io,'(a)')''
write(io,'(a)')'   Any namelist-group-name may occur more than once in the NAMELIST'
write(io,'(a)')'   statements in a scoping unit. The namelist-group-object-list following'
write(io,'(a)')'   each successive appearance of the same namelist-group-name in a'
write(io,'(a)')'   scoping unit is treated as a continuation of the list for that'
write(io,'(a)')'   namelist-group-name.'
write(io,'(a)')''
write(io,'(a)')'   A namelist group object may be a member of more than one namelist'
write(io,'(a)')'   group.'
write(io,'(a)')''
write(io,'(a)')'   A namelist group object shall either be accessed by use or host'
write(io,'(a)')'   association or shall have its type, type parameters, and shape'
write(io,'(a)')'   specified by previous specification statements or the procedure heading'
write(io,'(a)')'   in the same scoping unit or by the implicit typing rules in effect for'
write(io,'(a)')'   the scoping unit. If a namelist group object is typed by the implicit'
write(io,'(a)')'   typing rules, its appearance in any subsequent type declaration'
write(io,'(a)')'   statement shall confirm the implied type and type parameters.'
write(io,'(a)')''
write(io,'(a)')'   The specification-part of a BLOCK construct shall not contain a'
write(io,'(a)')'   NAMELIST statement.'
write(io,'(a)')''
write(io,'(a)')'   Why is NAMELIST not allowed in a BLOCK unit?'
write(io,'(a)')'   Would be handy for quick writes, like list-directed output'
write(io,'(a)')''
write(io,'(a)')'    block'
write(io,'(a)')'       namelist /nlist/ a,b,c,d'
write(io,'(a)')'       write(nlist)'
write(io,'(a)')'    endblock'
write(io,'(a)')''
write(io,'(a)')'   Input for a namelist input statement consists of'
write(io,'(a)')''
write(io,'(a)')'      1) optional blanks and namelist comments,'
write(io,'(a)')'      2) the character & followed immediately by the namelist-group-name as specified in the NAMELIST'
write(io,'(a)')'         statement,'
write(io,'(a)')'      3) one or more blanks,'
write(io,'(a)')'      4) a sequence of zero or more name-value subsequences separated by value separators, and'
write(io,'(a)')'      5) a slash to terminate the namelist input.'
write(io,'(a)')''
write(io,'(a)')'         A slash encountered in a namelist input record causes the input statement to terminate. A slash cannot be'
write(io,'(a)')'         used to separate two values in a namelist input statement.'
write(io,'(a)')''
write(io,'(a)')'   A group name or object name is without regard to case.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'   An example of a NAMELIST statement is:'
write(io,'(a)')''
write(io,'(a)')'     NAMELIST /NLIST/ A, B, C'
write(io,'(a)')''
write(io,'(a)')'   or a group may be defined by multiple statements using the same group name in a scoping unit:'
write(io,'(a)')''
write(io,'(a)')'     NAMELIST /NLIST/ A, B'
write(io,'(a)')'     NAMELIST /NLIST/ C'
write(io,'(a)')''
write(io,'(a)')'     ! READ/WRITE EXAMPLES: [ NML = ] namelist-group-name'
write(io,'(a)')'     READ(*,NML=NLIST)'
write(io,'(a)')'     WRITE(*,NLIST)'
write(io,'(a)')'     WRITE(*,NML=NLIST)'
write(io,'(a)')''
write(io,'(a)')'      program demo_namelist'
write(io,'(a)')'      implicit none'
write(io,'(a)')'      logical           :: l=.true.'
write(io,'(a)')'      character(len=10) :: c=''XXXXXXXXXX'''
write(io,'(a)')'      real              :: r=12.3456'
write(io,'(a)')'      integer           :: i=789'
write(io,'(a)')'      complex           :: x=(12345.6789,9876.54321)'
write(io,'(a)')'      doubleprecision   :: d= 123456789.123456789d0'
write(io,'(a)')'      namelist /nlist/ l,c,r,i,x,d'
write(io,'(a)')'         write(*,nlist)'
write(io,'(a)')'      end program demo_namelist'
write(io,'(a)')''
write(io,'(a)')'   Results:'
write(io,'(a)')''
write(io,'(a)')'      &NLIST'
write(io,'(a)')'       L=T,'
write(io,'(a)')'       C="XXXXXXXXXX",'
write(io,'(a)')'       R=  12.3456001    ,'
write(io,'(a)')'       I=        789,'
write(io,'(a)')'       X=(  12345.6787    ,  9876.54297    ),'
write(io,'(a)')'       D=  123456789.12345679     ,'
write(io,'(a)')'       /'
write(io,'(a)')''
write(io,'(a)')'   o Scanning on input till group name is found'
write(io,'(a)')'   o reading partial lists'
write(io,'(a)')'   o string quoting'
write(io,'(a)')'   o NAMELIST in internal read and write. See'
write(io,'(a)')''
write(io,'(a)')'    ./arguments/namelist'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'OTHER'
write(io,'(a)')''
write(io,'(a)')'  C915    (R913) A namelist-group-name shall be the name of a namelist group.'
write(io,'(a)')''
write(io,'(a)')'  C916    (R913) A namelist-group-name shall not appear if a REC= specifier, format, input-item-list, or an'
write(io,'(a)')'          output-item-list appears in the data transfer statement.'
write(io,'(a)')'  C917    (R913) An io-control-spec-list shall not contain both a format and a namelist-group-name.'
write(io,'(a)')'  C919    (R913) If namelist-group-name appears without a preceding NML=, it shall be the second item in the'
write(io,'(a)')'          io-control-spec-list and the first item shall be io-unit.'
write(io,'(a)')'  C928    (R913) If a DECIMAL=, BLANK=, PAD=, SIGN=, or ROUND= specifier appears, a format or'
write(io,'(a)')'          namelist-group-name shall also appear.'
write(io,'(a)')'  C929    (R913) If a DELIM= specifier appears, either format shall be an asterisk or namelist-group-name shall'
write(io,'(a)')'          appear.'
write(io,'(a)')'3 If the data transfer statement contains a format or namelist-group-name, the statement is a formatted in-'
write(io,'(a)')'  put/output statement; otherwise, it is an unformatted input/output statement.'
write(io,'(a)')''
write(io,'(a)')'1 The NML= specifier supplies the namelist-group-name (5.6). This name identifies a particular collection of data'
write(io,'(a)')'   objects on which transfer is to be performed.'
write(io,'(a)')''
write(io,'(a)')'2 If a namelist-group-name appears, the statement is a namelist input/output statement.'
write(io,'(a)')''
write(io,'(a)')'4 All values following the name= part of the namelist entity (10.11) within the input records are transmitted to'
write(io,'(a)')'   the matching entity specified in the namelist-group-object-list prior to processing any succeeding entity within'
write(io,'(a)')'   the input record for namelist input statements. If an entity is specified more than once within the input record'
write(io,'(a)')'   during a namelist formatted data transfer input statement, the last occurrence of the entity specifies the value'
write(io,'(a)')'   values to be used for that entity.'
write(io,'(a)')''
write(io,'(a)')'    9.6.4.6     Namelist formatting'
write(io,'(a)')''
write(io,'(a)')' 1 If namelist formatting has been established, editing is performed as described in 10.11.'
write(io,'(a)')''
write(io,'(a)')' 2 Every allocatable namelist-group-object in the namelist group shall be allocated and every namelist-group-object'
write(io,'(a)')'    that is a pointer shall be associated with a target. If a namelist-group-object is polymorphic or has an ultima'
write(io,'(a)')'    component that is allocatable or a pointer, that object shall be processed by a defined input/output procedure'
write(io,'(a)')'    (9.6.4.7).'
write(io,'(a)')'   9.6.5       Termination of data transfer statements'
write(io,'(a)')'1 Termination of an input/output data transfer statement occurs when'
write(io,'(a)')''
write(io,'(a)')'        format processing encounters a colon or data edit descriptor and there are no remaining elements in the'
write(io,'(a)')'        input-item-list or output-item-list,'
write(io,'(a)')'        unformatted or list-directed data transfer exhausts the input-item-list or output-item-list,'
write(io,'(a)')'        namelist output exhausts the namelist-group-object-list,'
write(io,'(a)')'        an error condition occurs,'
write(io,'(a)')'        an end-of-file condition occurs,'
write(io,'(a)')''
write(io,'(a)')'        a slash (/) is encountered as a value separator (10.10, 10.11) in the record being read during list-directe'
write(io,'(a)')'        or namelist input, or'
write(io,'(a)')'        an end-of-record condition occurs during execution of a nonadvancing input statement (9.11).'
write(io,'(a)')'2 If an error condition occurs during execution of an input/output statement that contains neither an ERR= nor'
write(io,'(a)')'  IOSTAT= specifier, error termination of the program is initiated. If an error condition occurs during execution'
write(io,'(a)')'  of an input/output statement that contains either an ERR= specifier or an IOSTAT= specifier then:'
write(io,'(a)')'        (1)    processing of the input/output list, if any, terminates;'
write(io,'(a)')''
write(io,'(a)')'        (2)    if the statement is a data transfer statement or the error occurs during a wait operation, all do-'
write(io,'(a)')'               variables in the statement that initiated the transfer become undefined;'
write(io,'(a)')'        (3)    if an IOSTAT= specifier appears, the scalar-int-variable in the IOSTAT= specifier becomes defined'
write(io,'(a)')'               as specified in 9.11.5;'
write(io,'(a)')'        (4)    if an IOMSG= specifier appears, the iomsg-variable becomes defined as specified in 9.11.6;'
write(io,'(a)')'        (5)    if the statement is a READ statement and it contains a SIZE= specifier, the scalar-int-variable in'
write(io,'(a)')'               the SIZE= specifier becomes defined as specified in 9.6.2.15;'
write(io,'(a)')'        (6)    if the statement is a READ statement or the error condition occurs in a wait operation for a transfe'
write(io,'(a)')'               initiated by a READ statement, all input items or namelist group objects in the statement that'
write(io,'(a)')'               initiated the transfer become undefined;'
write(io,'(a)')'        (7)    if an ERR= specifier appears, a branch to the statement labeled by the label in the ERR= specifier'
write(io,'(a)')'               occurs.'
write(io,'(a)')' 8 In a data transfer statement, the variable specified in an IOSTAT=, IOMSG=, or SIZE= specifier, if any, shall'
write(io,'(a)')'   not be associated with any entity in the data transfer input/output list (9.6.3) or namelist-group-object-list,'
write(io,'(a)')'   with a do-variable of an io-implied-do in the data transfer input/output list.'
write(io,'(a)')'    10.11        Namelist formatting'
write(io,'(a)')'    10.11.1      General'
write(io,'(a)')' 1 Namelist input/output allows data editing with NAME=value subsequences. This facilitates documentation of'
write(io,'(a)')'    input and output files and more flexibility on input.'
write(io,'(a)')''
write(io,'(a)')'    10.11.2      Name-value subsequences'
write(io,'(a)')' 1 The characters in one or more namelist records constitute a sequence of name-value subsequences, each of'
write(io,'(a)')'    which consists of an object designator followed by an equals and followed by one or more values and value'
write(io,'(a)')'    separators. The equals may optionally be preceded or followed by one or more contiguous blanks. The end of a'
write(io,'(a)')'    record has the same effect as a blank character, unless it is within a character constant. Any sequence of two'
write(io,'(a)')'    more consecutive blanks is treated as a single blank, unless it is within a character constant.'
write(io,'(a)')''
write(io,'(a)')' 2 The name may be any name in the namelist-group-object-list (5.6).'
write(io,'(a)')''
write(io,'(a)')' 3 A value separator for namelist formatting is the same as for list-directed formatting (10.10).'
write(io,'(a)')''
write(io,'(a)')'    10.11.3      Namelist input'
write(io,'(a)')'    10.11.3.1    Overall syntax'
write(io,'(a)')''
write(io,'(a)')' 2 In each name-value subsequence, the name shall be the name of a namelist group object list item with an optional'
write(io,'(a)')'    qualification and the name with the optional qualification shall not be a zero-sized array, a zero-sized array'
write(io,'(a)')'    or a zero-length character string. The optional qualification, if any, shall not contain a vector subscript.'
write(io,'(a)')''
write(io,'(a)')'   10.11.3.2    Namelist group object names'
write(io,'(a)')''
write(io,'(a)')'1 Within the input data, each name shall correspond to a particular namelist group object name. Subscripts,'
write(io,'(a)')'   strides, and substring range expressions used to qualify group object names shall be optionally signed integer'
write(io,'(a)')'   literal constants with no kind type parameters specified. If a namelist group object is an array, the input reco'
write(io,'(a)')'   corresponding to it may contain either the array name or the designator of a subobject of that array, using the'
write(io,'(a)')'   syntax of object designators (R601). If the namelist group object name is the name of a variable of derived type'
write(io,'(a)')'   the name in the input record may be either the name of the variable or the designator of one of its components,'
write(io,'(a)')'   indicated by qualifying the variable name with the appropriate component name. Successive qualifications may'
write(io,'(a)')'   be applied as appropriate to the shape and type of the variable represented.'
write(io,'(a)')''
write(io,'(a)')'2 The order of names in the input records need not match the order of the namelist group object items. The input'
write(io,'(a)')'   records need not contain all the names of the namelist group object items. The definition status of any names'
write(io,'(a)')'   from the namelist-group-object-list that do not occur in the input record remains unchanged. In the input record'
write(io,'(a)')'   each object name or subobject designator may be preceded and followed by one or more optional blanks but shall'
write(io,'(a)')'   not contain embedded blanks.'
write(io,'(a)')''
write(io,'(a)')'   10.11.3.3    Namelist group object list items'
write(io,'(a)')''
write(io,'(a)')'1 The name-value subsequences are evaluated serially, in left-to-right order. A namelist group object designator'
write(io,'(a)')'   may appear in more than one name-value sequence.'
write(io,'(a)')''
write(io,'(a)')'2 When the name in the input record represents an array variable or a variable of derived type, the effect is as'
write(io,'(a)')'   if the variable represented were expanded into a sequence of scalar list items, in the same way that formatted'
write(io,'(a)')'   input/output list items are expanded (9.6.3). Each input value following the equals shall then be acceptable to'
write(io,'(a)')'   format specifications for the type of the list item in the corresponding position in the expanded sequence, exce'
write(io,'(a)')'   as noted in this subclause. The number of values following the equals shall not exceed the number of list items'
write(io,'(a)')'   in the expanded sequence, but may be less; in the latter case, the effect is as if sufficient null values had be'
write(io,'(a)')'   appended to match any remaining list items in the expanded sequence.'
write(io,'(a)')''
write(io,'(a)')'        NOTE 10.35'
write(io,'(a)')'        For example, if the name in the input record is the name of an integer array of size 100, at most 100 value'
write(io,'(a)')'        each of which is either a digit string or a null value, may follow the equals; these values would then be'
write(io,'(a)')'        assigned to the elements of the array in array element order.'
write(io,'(a)')''
write(io,'(a)')'3 A slash encountered as a value separator during the execution of a namelist input statement causes termination'
write(io,'(a)')'   of execution of that input statement after transference of the previous value. If there are additional items in'
write(io,'(a)')'   namelist group object being transferred, the effect is as if null values had been supplied for them.'
write(io,'(a)')''
write(io,'(a)')'4 A namelist comment may appear after any value separator except a slash. A namelist comment is also permitted'
write(io,'(a)')'   to start in the first nonblank position of an input record except within a character literal constant.'
write(io,'(a)')''
write(io,'(a)')'5 Successive namelist records are read by namelist input until a slash is encountered; the remainder of the record'
write(io,'(a)')'   is ignored and need not follow the rules for namelist input values.'
write(io,'(a)')''
write(io,'(a)')'   10.11.3.4    Namelist input values'
write(io,'(a)')''
write(io,'(a)')'1 Each value is either a null value (10.11.3.5), c, r *c, or r *, where c is a literal constant, optionally signed'
write(io,'(a)')'   or real, and r is an unsigned, nonzero, integer literal constant. A kind type parameter shall not be specified f'
write(io,'(a)')'   or r. The constant c is interpreted as though it had the same kind type parameter as the corresponding effective'
write(io,'(a)')'   item. The r *c form is equivalent to r successive appearances of the constant c, and the r * form is equivalent'
write(io,'(a)')'   r successive null values. Neither of these forms may contain embedded blanks, except where permitted within'
write(io,'(a)')'   the constant c.'
write(io,'(a)')''
write(io,'(a)')'2 The datum c (10.11) is any input value acceptable to format specifications for a given type, except for a restric'
write(io,'(a)')'   on the form of input values corresponding to list items of types logical, integer, and character as specified in'
write(io,'(a)')'   subclause. The form of a real or complex value is dependent on the decimal edit mode in effect (10.6). The form'
write(io,'(a)')''
write(io,'(a)')'  of an input value shall be acceptable for the type of the namelist group object list item. The number and forms'
write(io,'(a)')'  of the input values that may follow the equals in a name-value subsequence depend on the shape and type of'
write(io,'(a)')'  the object represented by the name in the input record. When the name in the input record is that of a scalar'
write(io,'(a)')'  variable of an intrinsic type, the equals shall not be followed by more than one value. Blanks are never used'
write(io,'(a)')'  as zeros, and embedded blanks are not permitted in constants except within character constants and complex'
write(io,'(a)')'  constants as specified in this subclause.'
write(io,'(a)')''
write(io,'(a)')'3 When the next effective item is of type real, the input form of the input value is that of a numeric input field.'
write(io,'(a)')'  numeric input field is a field suitable for F editing (10.7.2.3.2) that is assumed to have no fractional digits u'
write(io,'(a)')'  a decimal symbol appears within the field.'
write(io,'(a)')''
write(io,'(a)')'4 When the next effective item is of type complex, the input form of the input value consists of a left parenthesis'
write(io,'(a)')'  followed by an ordered pair of numeric input fields separated by a comma (if the decimal edit mode is POINT) or'
write(io,'(a)')'  a semicolon (if the decimal edit mode is COMMA), and followed by a right parenthesis. The first numeric input'
write(io,'(a)')'  field is the real part of the complex constant and the second part is the imaginary part. Each of the numeric'
write(io,'(a)')'  input fields may be preceded or followed by any number of blanks and ends of records. The end of a record may'
write(io,'(a)')'  occur between the real part and the comma or semicolon, or between the comma or semicolon and the imaginary'
write(io,'(a)')'  part.'
write(io,'(a)')''
write(io,'(a)')'5 When the next effective item is of type logical, the input form of the input value shall not include equals or va'
write(io,'(a)')'  separators among the optional characters permitted for L editing (10.7.3).'
write(io,'(a)')''
write(io,'(a)')'6 When the next effective item is of type integer, the value in the input record is interpreted as if an Iw edit'
write(io,'(a)')'  descriptor with a suitable value of w were used.'
write(io,'(a)')''
write(io,'(a)')'7 When the next effective item is of type character, the input form consists of a delimited sequence of zero or mor'
write(io,'(a)')'  rep-char s whose kind type parameter is implied by the kind of the corresponding list item. Such a sequence'
write(io,'(a)')'  may be continued from the end of one record to the beginning of the next record, but the end of record shall'
write(io,'(a)')'  not occur between a doubled apostrophe in an apostrophe-delimited sequence, nor between a doubled quote in a'
write(io,'(a)')'  quote-delimited sequence. The end of the record does not cause a blank or any other character to become part'
write(io,'(a)')'  of the sequence. The sequence may be continued on as many records as needed. The characters blank, comma,'
write(io,'(a)')'  semicolon, and slash may appear in such character sequences.'
write(io,'(a)')''
write(io,'(a)')'          NOTE 10.36'
write(io,'(a)')'          A character sequence corresponding to a namelist input item of character type shall be delimited either w'
write(io,'(a)')'          apostrophes or with quotes. The delimiter is required to avoid ambiguity between undelimited character'
write(io,'(a)')'          sequences and object names. The value of the DELIM= specifier, if any, in the OPEN statement for an'
write(io,'(a)')'          external file is ignored during namelist input (9.5.6.8).'
write(io,'(a)')''
write(io,'(a)')'8 Let len be the length of the next effective item, and let w be the length of the character sequence. If len is le'
write(io,'(a)')'  than or equal to w, the leftmost len characters of the sequence are transmitted to the next effective item. If le'
write(io,'(a)')'  is greater than w, the constant is transmitted to the leftmost w characters of the next effective item and the'
write(io,'(a)')'  remaining len-w characters of the next effective item are filled with blanks. The effect is as though the sequenc'
write(io,'(a)')'  were assigned to the next effective item in an intrinsic assignment statement (7.2.1.3).'
write(io,'(a)')''
write(io,'(a)')'  10.11.3.5      Null values'
write(io,'(a)')''
write(io,'(a)')'1 A null value is specified by'
write(io,'(a)')''
write(io,'(a)')'          the r * form,'
write(io,'(a)')'          blanks between two consecutive nonblank value separators following an equals,'
write(io,'(a)')'          zero or more blanks preceding the first value separator and following an equals, or'
write(io,'(a)')'          two consecutive nonblank value separators.'
write(io,'(a)')''
write(io,'(a)')'2 A null value has no effect on the definition status of the corresponding input list item. If the namelist group'
write(io,'(a)')'  object list item is defined, it retains its previous value; if it is undefined, it remains undefined. A null valu'
write(io,'(a)')''
write(io,'(a)')'  not be used as either the real or imaginary part of a complex constant, but a single null value may represent an'
write(io,'(a)')'  entire complex constant.'
write(io,'(a)')''
write(io,'(a)')'        NOTE 10.37'
write(io,'(a)')'        The end of a record following a value separator, with or without intervening blanks, does not specify a nul'
write(io,'(a)')'        value in namelist input.'
write(io,'(a)')''
write(io,'(a)')'  10.11.3.6    Blanks'
write(io,'(a)')''
write(io,'(a)')'1 All blanks in a namelist input record are considered to be part of some value separator except for'
write(io,'(a)')''
write(io,'(a)')'        blanks embedded in a character constant,'
write(io,'(a)')'        embedded blanks surrounding the real or imaginary part of a complex constant,'
write(io,'(a)')'        leading blanks following the equals unless followed immediately by a slash or comma, or a semicolon if the'
write(io,'(a)')'        decimal edit mode is comma, and'
write(io,'(a)')'        blanks between a name and the following equals.'
write(io,'(a)')''
write(io,'(a)')'  10.11.3.7    Namelist Comments'
write(io,'(a)')''
write(io,'(a)')'1 Except within a character literal constant, a "!" character after a value separator or in the first nonblank posi'
write(io,'(a)')'  of a namelist input record initiates a comment. The comment extends to the end of the current input record and'
write(io,'(a)')'  may contain any graphic character in the processor-dependent character set. The comment is ignored. A slash'
write(io,'(a)')'  within the namelist comment does not terminate execution of the namelist input statement. Namelist comments'
write(io,'(a)')'  are not allowed in stream input because comments depend on record structure.'
write(io,'(a)')''
write(io,'(a)')'        NOTE 10.38'
write(io,'(a)')'        Namelist input example:'
write(io,'(a)')''
write(io,'(a)')'        INTEGER I; REAL X (8); CHARACTER (11) P; COMPLEX Z;'
write(io,'(a)')'        LOGICAL G'
write(io,'(a)')'        NAMELIST / TODAY / G, I, P, Z, X'
write(io,'(a)')'        READ (*, NML = TODAY)'
write(io,'(a)')''
write(io,'(a)')'        The input data records are:'
write(io,'(a)')''
write(io,'(a)')'        &TODAY I = 12345, X(1) = 12345, X(3:4) = 2*1.5, I=6, ! This is a comment.'
write(io,'(a)')'        P = ''''ISN''T_BOB''S'''', Z = (123,0)/'
write(io,'(a)')''
write(io,'(a)')'        The results stored are:'
write(io,'(a)')'                Variable                         Value'
write(io,'(a)')'                I                                6'
write(io,'(a)')'                X (1)                            12345.0'
write(io,'(a)')'                X (2)                            unchanged'
write(io,'(a)')'                X (3)                            1.5'
write(io,'(a)')'                X (4)                            1.5'
write(io,'(a)')'                X (5)   X (8)                    unchanged'
write(io,'(a)')'                P                                ISN''T BOB''S'
write(io,'(a)')'                Z                                (123.0,0.0)'
write(io,'(a)')'                G                                unchanged'
write(io,'(a)')''
write(io,'(a)')'  10.11.4      Namelist output'
write(io,'(a)')'  10.11.4.1    Form of namelist output'
write(io,'(a)')''
write(io,'(a)')'1 The form of the output produced is the same as that required for input, except for the forms of real, character,'
write(io,'(a)')'  and logical values. The name in the output is in upper case. With the exception of adjacent undelimited character'
write(io,'(a)')'  values, the values are separated by one or more blanks or by a comma, or a semicolon if the decimal edit mode'
write(io,'(a)')'  is COMMA, optionally preceded by one or more blanks and optionally followed by one or more blanks.'
write(io,'(a)')''
write(io,'(a)')'2 Namelist output shall not include namelist comments.'
write(io,'(a)')''
write(io,'(a)')'3 The processor may begin new records as necessary. However, except for complex constants and character values,'
write(io,'(a)')'  the end of a record shall not occur within a constant, character value, or name, and blanks shall not appear'
write(io,'(a)')'  within a constant, character value, or name.'
write(io,'(a)')''
write(io,'(a)')'        NOTE 10.39'
write(io,'(a)')'        The length of the output records is not specified exactly and may be processor dependent.'
write(io,'(a)')''
write(io,'(a)')'  10.11.4.2    Namelist output editing'
write(io,'(a)')''
write(io,'(a)')'1 Values in namelist output records are edited as for list-directed output (10.10.4).'
write(io,'(a)')''
write(io,'(a)')'        NOTE 10.40'
write(io,'(a)')'        Namelist output records produced with a DELIM= specifier with a value of NONE and which contain a'
write(io,'(a)')'        character sequence might not be acceptable as namelist input records.'
write(io,'(a)')''
write(io,'(a)')'  10.11.4.3    Namelist output records'
write(io,'(a)')''
write(io,'(a)')'1 If two or more successive values for the same namelist group item in an output record produced have identical'
write(io,'(a)')'  values, the processor has the option of producing a repeated constant of the form r *c instead of the sequence of'
write(io,'(a)')'  identical values.'
write(io,'(a)')''
write(io,'(a)')'2 The name of each namelist group object list item is placed in the output record followed by an equals and a list'
write(io,'(a)')'  of values of the namelist group object list item.'
write(io,'(a)')''
write(io,'(a)')'3 An ampersand character followed immediately by a namelist-group-name will be produced by namelist formatting'
write(io,'(a)')'  at the start of the first output record to indicate which particular group of data objects is being output. A sla'
write(io,'(a)')'  is produced by namelist formatting to indicate the end of the namelist formatting.'
write(io,'(a)')''
write(io,'(a)')'4 A null value is not produced by namelist formatting.'
write(io,'(a)')''
write(io,'(a)')'5 Except for new records created by explicit formatting within a defined output procedure or by continuation of'
write(io,'(a)')'  delimited character sequences, each output record begins with a blank character.'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'  STOP(7f),ALLSTOP(7f)  - [FORTRAN:STATEMENT] initiates termination of execution'
write(io,'(a)')''
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'  STOP [ stop-code ]'
write(io,'(a)')'  ALL STOP [ stop-code ]'
write(io,'(a)')''
write(io,'(a)')'  stop-code    is  scalar-char-initialization-expr'
write(io,'(a)')'               or  scalar-int-initialization-expr'
write(io,'(a)')''
write(io,'(a)')'  The scalar-char-initialization-expr shall be of default kind.'
write(io,'(a)')''
write(io,'(a)')'  The scalar-int-initialization-expr shall be of default kind.'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'  Execution of a STOP statement initiates normal termination of execution. Execution of an ALL STOP'
write(io,'(a)')'  statement initiates error termination of execution.'
write(io,'(a)')''
write(io,'(a)')'  When an image is terminated by a STOP or ALL STOP statement, its stop code, if any, is made available in a'
write(io,'(a)')'  processor-dependent manner. If any exception is signaling on that image, the processor shall issue a warning'
write(io,'(a)')'  indicating which exceptions are signaling; this warning shall be on the unit identified by the named constant'
write(io,'(a)')'  ERROR_UNIT. It is recommended that the stop code is made available by formatted output to the same unit.'
write(io,'(a)')''
write(io,'(a)')'  When normal termination occurs on more than one image, it is expected that a processor-dependent summary'
write(io,'(a)')'  of any stop codes and signaling exceptions will be made available.'
write(io,'(a)')''
write(io,'(a)')'  If the stop-code is an integer, it is recommended that the value also be used as the process exit status, if the'
write(io,'(a)')'  processor supports that concept. If the integer stop-code is used as the process exit status, the processor'
write(io,'(a)')'  might be able to interpret only values within a limited range, or only a limited portion of the integer value'
write(io,'(a)')'  (for example, only the least-significant 8 bits).'
write(io,'(a)')''
write(io,'(a)')'  If the stop-code is of type character or does not appear, or if an END PROGRAM statement is executed,'
write(io,'(a)')'  it is recommended that the value zero be supplied as the process exit status, if the processor supports that'
write(io,'(a)')'  concept.'
write(io,'(a)')'NAME'
write(io,'(a)')'    include(7f) - [FORTRAN] including source text'
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'    INCLUDE char-literal-constant'
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'  Additional text may be incorporated into the source text of a program'
write(io,'(a)')'  unit during processing. This is accomplished with the INCLUDE line,'
write(io,'(a)')'  which has the form'
write(io,'(a)')''
write(io,'(a)')'         INCLUDE char-literal-constant'
write(io,'(a)')''
write(io,'(a)')'  An INCLUDE line is not a Fortran statement.'
write(io,'(a)')''
write(io,'(a)')'  The char-literal-constant shall not have a kind type parameter value'
write(io,'(a)')'  that is a named-constant.'
write(io,'(a)')'  The interpretation of char-literal-constant is processor dependent. An'
write(io,'(a)')'  example of a possible valid interpretation is that char-literal-constant'
write(io,'(a)')'  is the name of a file that contains the source text to be included.'
write(io,'(a)')''
write(io,'(a)')'  An INCLUDE line shall appear on a single source line where a statement'
write(io,'(a)')'  may appear; it shall be the only nonblank text on this line other than'
write(io,'(a)')'  an optional trailing comment. Thus, a statement label is not allowed.'
write(io,'(a)')''
write(io,'(a)')'  The effect of the INCLUDE line is as if the referenced source text'
write(io,'(a)')'  physically replaced the INCLUDE line prior to program'
write(io,'(a)')'  processing. Included text may contain any source text, including'
write(io,'(a)')'  additional INCLUDE lines; such nested INCLUDE lines are similarly'
write(io,'(a)')'  replaced with the specified source text. The maximum depth of nesting'
write(io,'(a)')'  of any nested INCLUDE lines is processor dependent. Inclusion of the'
write(io,'(a)')'  source text referenced by an INCLUDE line shall not, at any level of'
write(io,'(a)')'  nesting, result in inclusion of the same source text.'
write(io,'(a)')''
write(io,'(a)')'  When an INCLUDE line is resolved, the first included statement line'
write(io,'(a)')'  shall not be a continuation line and the last included statement line'
write(io,'(a)')'  shall not be continued.'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'  NOTE'
write(io,'(a)')''
write(io,'(a)')'          In some circumstances, for example where source code is'
write(io,'(a)')'          maintained in an INCLUDE file for use in programs whose source'
write(io,'(a)')'          form might be either fixed or free, observing the following'
write(io,'(a)')'          rules allows the code to be used with either source form.'
write(io,'(a)')''
write(io,'(a)')'          *   Confine statement labels to character positions 1 to'
write(io,'(a)')'              5 and statements to character positions 7 to 72.'
write(io,'(a)')'          *   Treat blanks as being significant.'
write(io,'(a)')'          *   Use only the exclamation mark (!) to indicate'
write(io,'(a)')'              a comment, but do not start the comment in character'
write(io,'(a)')'              position 6.'
write(io,'(a)')'          *   For continued statements, place an ampersand (&) in'
write(io,'(a)')'              both character position 73 of a continued line and character'
write(io,'(a)')'              position 6 of a continuation line.'
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'NAME'
write(io,'(a)')'    scratch(7f) - [FORTRAN:OPEN] where scratch files are typically written by OPEN(3f)'
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'    open( .... status=''scratch'')'
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'    Where files opened with status=''scratch'' are written is implementation-dependent.'
write(io,'(a)')'    Often the file is unlinked so that it goes away unconditionally when the program'
write(io,'(a)')'    starts, so in many *nix environments you cannot see the scratch file that is often'
write(io,'(a)')'    used. So the compiler documentation should be referred to, but typically'
write(io,'(a)')'    a scratch file is opened with a unique filename in one of the following directories:'
write(io,'(a)')''
write(io,'(a)')'      o in the directory pointed to by the environment variable $TMPDIR, if defined.'
write(io,'(a)')'      o next directories pointed to by $TMP and $TEMP are used if the variables are'
write(io,'(a)')'        defined.'
write(io,'(a)')'      o if none of the variables are defined, then the /tmp directory is typically used'
write(io,'(a)')'        on *nix systems, and the current directory is often used on other systems.'
write(io,'(a)')''
write(io,'(a)')'    This can be important if you are generating large scratch files, as you may want'
write(io,'(a)')'    to specify they are created in a secure directory or on a high-speed server such'
write(io,'(a)')'    as a Lustre file server or memory-resident file system. Consider'
write(io,'(a)')''
write(io,'(a)')'      o Scratch files are often opened using the current permission mask'
write(io,'(a)')'        (umask) combined with possible operating-system or kernel defaults'
write(io,'(a)')'        and file-system-dependent attributes, so make sure scratch files are'
write(io,'(a)')'        properly secure'
write(io,'(a)')'      o files are written in an area that you can write to and have sufficient'
write(io,'(a)')'        space in'
write(io,'(a)')'      o that the scratch space provides optimal performance'
write(io,'(a)')'      o make sure the system cleans up properly'
write(io,'(a)')'        when programs are aborted.'
write(io,'(a)')''
write(io,'(a)')'    The behavior is very system-dependent.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE:'
write(io,'(a)')'   System-dependent example:'
write(io,'(a)')''
write(io,'(a)')'    open(newunit=lun,status=''scratch'')'
write(io,'(a)')'    inquire(unit=lun,file=filename)'
write(io,'(a)')'    write(*,*)''filename='',filename)'
write(io,'(a)')'    end'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'initialize_arrays(7f) - [FORTRAN:FAQ] Initializing small 2D numeric arrays with array constructors'
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'Intuitively, one might assume that if one wants to initialize a'
write(io,'(a)')'small array by rows that something like the following will work:'
write(io,'(a)')''
write(io,'(a)')'   ! DOES NOT WORK'
write(io,'(a)')'   integer :: xx(3,5)= [ 1, 2, 3, 4, 5], &'
write(io,'(a)')'                       [10,20,30,40,50], &'
write(io,'(a)')'                       [11,22,33,44,55]'
write(io,'(a)')''
write(io,'(a)')'or perhaps'
write(io,'(a)')''
write(io,'(a)')'   ! DOES NOT WORK'
write(io,'(a)')'   integer :: xx(3,5)= [ [ 1, 2, 3, 4, 5], &'
write(io,'(a)')'                         [10,20,30,40,50], &'
write(io,'(a)')'                         [11,22,33,44,55]  ]'
write(io,'(a)')''
write(io,'(a)')'Someday something simpler might work, but currently the following syntax'
write(io,'(a)')'is required to specify the values in an intuitive row-column sequence'
write(io,'(a)')'using an array constructor:'
write(io,'(a)')''
write(io,'(a)')'   integer,save :: xx(3,5)= reshape([&'
write(io,'(a)')''
write(io,'(a)')'       1, 2, 3, 4, 5, &'
write(io,'(a)')'      10,20,30,40,50, &'
write(io,'(a)')'      11,22,33,44,55  &'
write(io,'(a)')''
write(io,'(a)')'      ],shape(xx),order[2,1])'
write(io,'(a)')''
write(io,'(a)')'This is because an array constructor can be used to create and assign'
write(io,'(a)')'values only to rank-one arrays. To define arrays of more than one'
write(io,'(a)')'dimension with an array constructor, you must use the RESHAPE(3f) intrinsic'
write(io,'(a)')'function.'
write(io,'(a)')''
write(io,'(a)')'Note that the ORDER= option on RESHAPE(3f) is used to allow the values'
write(io,'(a)')'to be specified in row-column order instead of the default behavior,'
write(io,'(a)')'which fills columns first.'
write(io,'(a)')''
write(io,'(a)')'Also note that if the expressions are of type character, Fortran 95/90'
write(io,'(a)')'requires each expression to have the same character length (there is a'
write(io,'(a)')'common compiler extension that extends all strings to the length of the'
write(io,'(a)')'longest value specified, but depending on it reduces portability).'
write(io,'(a)')''
write(io,'(a)')'## Printing small arrays in row-column format'
write(io,'(a)')''
write(io,'(a)')'When working with small arrays the issue that there is no default Fortran'
write(io,'(a)')'routine for printing an array in row-column order becomes apparent. So'
write(io,'(a)')'lets create a simple solution for integer arrays (PRINT_MATRIX_INT(3f)):'
write(io,'(a)')''
write(io,'(a)')'   program demo_array_constructor ! initializing small arrays'
write(io,'(a)')'   implicit none'
write(io,'(a)')'   integer,save :: xx(3,5)= reshape([&'
write(io,'(a)')''
write(io,'(a)')'       1, 2, 3, 4, 5, &'
write(io,'(a)')'      10,20,30,40,50, &'
write(io,'(a)')'      11,22,33,44,-1055  &'
write(io,'(a)')''
write(io,'(a)')'    ],shape(xx),order=[2,1])'
write(io,'(a)')''
write(io,'(a)')'   call print_matrix_int(''xx array:'',xx)'
write(io,'(a)')''
write(io,'(a)')'   contains'
write(io,'(a)')''
write(io,'(a)')'   subroutine print_matrix_int(title,arr)'
write(io,'(a)')'   implicit none'
write(io,'(a)')''
write(io,'(a)')'   character(len=*),parameter::ident= "@(#)print_matrix_int(3f) - print small 2d integer arrays in row-column forma'
write(io,'(a)')''
write(io,'(a)')'   character(len=*),intent(in)  :: title'
write(io,'(a)')'   integer,intent(in)           :: arr(:,:)'
write(io,'(a)')'   integer                      :: i'
write(io,'(a)')'   character(len=:),allocatable :: biggest'
write(io,'(a)')''
write(io,'(a)')'      write(*,*)trim(title)                                                 ! print title'
write(io,'(a)')'      biggest=''           ''                                                 ! make buffer to write integer into'
write(io,'(a)')'      write(biggest,''(i0)'')ceiling(log10(real(maxval(abs(arr)))))+1         ! find how many characters to use for'
write(io,'(a)')'      biggest=''(" > [",*(i''//trim(biggest)//'':,","))''                       ! use this format to write a row'
write(io,'(a)')'      do i=1,size(arr,dim=1)                                                ! print one row of array at a time'
write(io,'(a)')'         write(*,fmt=biggest,advance=''no'')arr(i,:)'
write(io,'(a)')'         write(*,''(" ]")'')'
write(io,'(a)')'      enddo'
write(io,'(a)')''
write(io,'(a)')'   end subroutine print_matrix_int'
write(io,'(a)')''
write(io,'(a)')'   end program demo_array_constructor'
write(io,'(a)')''
write(io,'(a)')'Results:'
write(io,'(a)')''
write(io,'(a)')'   xx array:'
write(io,'(a)')'   > [  1,  2,  3,  4,  5 ]'
write(io,'(a)')'   > [ 10, 20, 30, 40, 50 ]'
write(io,'(a)')'   > [ 11, 22, 33, 44, 55 ]'
write(io,'(a)')''
write(io,'(a)')'We could do a more robust version that handles REAL and COMPLEX values'
write(io,'(a)')'as well as NaN values, but it has already been done. If you need to'
write(io,'(a)')'print a variety of small matrices see:'
write(io,'(a)')''
write(io,'(a)')'  dispmodule(3f), "A Fortran 95 module for pretty-printing matrices".'
write(io,'(a)')'  Kristjan Jonasson, Department of Computer Science,'
write(io,'(a)')'  School of Science and Engineering, University of Iceland,'
write(io,'(a)')'  Hjardarhaga 4, 107 Reykjavik, Iceland (jonasson@hi.is).'
write(io,'(a)')''
write(io,'(a)')'#Initializing a 2D array using DATA statements'
write(io,'(a)')''
write(io,'(a)')'Note that DATA statements are very flexible, and allow for perhaps the'
write(io,'(a)')'most intelligible way of specifying small arrays row by row. For example:'
write(io,'(a)')''
write(io,'(a)')'   ! fill rows using DATA statements'
write(io,'(a)')'   integer,save,dimension(3,5) :: gg'
write(io,'(a)')'   data gg(1,:)/  1,  2,  3,  4,  5 /'
write(io,'(a)')'   data gg(2,:)/ 10, 20, 30, 40, 50 /'
write(io,'(a)')'   data gg(3,:)/ 11, 22, 33, 44, 55 /'
write(io,'(a)')''
write(io,'(a)')'There are other ways to use a DATA statement to fill in row-column order,'
write(io,'(a)')'including use of the SIZE(3f) function and an implied-DO:'
write(io,'(a)')''
write(io,'(a)')'   ! use implied-DO so data can be declared in row-column order'
write(io,'(a)')'   integer, dimension(3,5) :: ff'
write(io,'(a)')'   DATA (( ff(J,I), I=1,size(ff,dim=2)), J=1,size(ff,dim=1)) / &'
write(io,'(a)')'      01,02,03,04,05, &'
write(io,'(a)')'      10,20,30,40,50, &'
write(io,'(a)')'      11,22,33,44,55  /'
write(io,'(a)')''
write(io,'(a)')'##Initializing a 2D array from a vector using EQUIVALENCE'
write(io,'(a)')''
write(io,'(a)')'Sometimes instead of using RESHAPE(3f) you will see someone initialize a'
write(io,'(a)')'vector and then equivalence it to a multi-dimensional array; especially'
write(io,'(a)')'if the code has a reason to access the data as both a vector and a matrix:'
write(io,'(a)')''
write(io,'(a)')'   ! multi-dimensional row1, row2, .... by equivalence'
write(io,'(a)')'   integer,parameter :: d1=3,d2=5'
write(io,'(a)')'   integer           :: ee(d1,d2)'
write(io,'(a)')'   ! note that the DATA statements could be used to initialize the array instead'
write(io,'(a)')'   integer           :: e(d1*d2) =[1,10,11, 2,20,22, 3,30,33, 4,40,44, 5,50,55]'
write(io,'(a)')'   equivalence       (e(1),ee(1,1))'
write(io,'(a)')''
write(io,'(a)')'##Notes'
write(io,'(a)')''
write(io,'(a)')'Remember that for simple initializations vector statements can be used'
write(io,'(a)')''
write(io,'(a)')'   real :: arr(10,20)=0.0'
write(io,'(a)')'   ! array constructors can be used to define constants, not just vectors'
write(io,'(a)')'   integer,parameter :: ii(10,10)=[(i,i=1,size(ii))] ! odd numbers using implied-DO'
write(io,'(a)')''
write(io,'(a)')'and that if things are too complicated you can just set the values in the executable'
write(io,'(a)')'body of the code.'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'   data(7f) - [FORTRAN] DATA statement'
write(io,'(a)')''
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'   data-stmt is   DATA data-stmt-set [ [ , ] data-stmt-set ] ...'
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   The DATA statement specifies explicit initialization.'
write(io,'(a)')''
write(io,'(a)')'   If a nonpointer object has default initialization, it shall not appear in a data-stmt-object-list.'
write(io,'(a)')''
write(io,'(a)')'   A variable that appears in a DATA statement and has not been typed previously may appear in a subsequent type'
write(io,'(a)')'   declaration only if that declaration confirms the implicit typing. An array name, array section, or array elemen'
write(io,'(a)')'   that appears in a DATA statement shall have had its array properties established by a previous specification'
write(io,'(a)')'   statement.'
write(io,'(a)')''
write(io,'(a)')'   Except for variables in named common blocks, a named variable has the SAVE attribute if any part of it is'
write(io,'(a)')'   initialized in a DATA statement, and this may be confirmed by explicit specification.'
write(io,'(a)')''
write(io,'(a)')'      R535    data-stmt-set                 is   data-stmt-object-list / data-stmt-value-list /'
write(io,'(a)')''
write(io,'(a)')'      R536    data-stmt-object              is variable'
write(io,'(a)')'                                            or data-implied-do'
write(io,'(a)')''
write(io,'(a)')'      R537    data-implied-do               is   ( data-i-do-object-list , data-i-do-variable ='
write(io,'(a)')'                                                    scalar-int-initialization-expr ,'
write(io,'(a)')'                                                    scalar-int-initialization-expr'
write(io,'(a)')'                                                    [ , scalar-int-initialization-expr ] )'
write(io,'(a)')''
write(io,'(a)')'      R538    data-i-do-object              is array-element'
write(io,'(a)')'                                            or scalar-structure-component'
write(io,'(a)')'                                            or data-implied-do'
write(io,'(a)')''
write(io,'(a)')'      R539    data-i-do-variable            is   do-variable'
write(io,'(a)')''
write(io,'(a)')'      C563    A data-stmt-object or data-i-do-object shall not be a coindexed variable.'
write(io,'(a)')''
write(io,'(a)')'      C564    (R536) In a variable that is a data-stmt-object, each subscript, section subscript, substring startin'
write(io,'(a)')'              and substring ending point shall be an initialization expression.'
write(io,'(a)')''
write(io,'(a)')'      C565    (R536) A variable whose designator appears as a data-stmt-object or a data-i-do-object shall not be a'
write(io,'(a)')'              dummy argument, accessed by use or host association, in a named common block unless the DATA'
write(io,'(a)')'              statement is in a block data program unit, in blank common, a function name, a function result name,'
write(io,'(a)')'              an automatic object, or an allocatable variable.'
write(io,'(a)')''
write(io,'(a)')'      C566    (R536) A data-i-do-object or a variable that appears as a data-stmt-object shall not be an object des'
write(io,'(a)')'              in which a pointer appears other than as the entire rightmost part-ref .'
write(io,'(a)')''
write(io,'(a)')'      C567    (R538) The array-element shall be a variable.'
write(io,'(a)')''
write(io,'(a)')'      C568    (R538) The scalar-structure-component shall be a variable.'
write(io,'(a)')''
write(io,'(a)')'      C569    (R538) The scalar-structure-component shall contain at least one part-ref that contains a subscript-l'
write(io,'(a)')''
write(io,'(a)')'      C570    (R538) In an array-element or scalar-structure-component that is a data-i-do-object, any subscript sh'
write(io,'(a)')'              be an initialization expression, and any primary within that subscript that is a data-i-do-variable s'
write(io,'(a)')'              be a DO variable of this data-implied-do or of a containing data-implied-do.'
write(io,'(a)')''
write(io,'(a)')'      R540     data-stmt-value               is   [ data-stmt-repeat * ] data-stmt-constant'
write(io,'(a)')''
write(io,'(a)')'      R541     data-stmt-repeat              is scalar-int-constant'
write(io,'(a)')'                                             or scalar-int-constant-subobject'
write(io,'(a)')''
write(io,'(a)')'      C571     (R541) The data-stmt-repeat shall be positive or zero. If the data-stmt-repeat is a named constant,'
write(io,'(a)')'               shall have been declared previously in the scoping unit or made accessible by use or host associatio'
write(io,'(a)')''
write(io,'(a)')'      R542     data-stmt-constant            is   scalar-constant'
write(io,'(a)')'                                             or   scalar-constant-subobject'
write(io,'(a)')'                                             or   signed-int-literal-constant'
write(io,'(a)')'                                             or   signed-real-literal-constant'
write(io,'(a)')'                                             or   null-init'
write(io,'(a)')'                                             or   initial-data-target'
write(io,'(a)')'                                             or   structure-constructor'
write(io,'(a)')''
write(io,'(a)')'      C572     (R542) If a DATA statement constant value is a named constant or a structure constructor, the named'
write(io,'(a)')'               constant or derived type shall have been declared previously in the scoping unit or accessed by use'
write(io,'(a)')'               host association.'
write(io,'(a)')''
write(io,'(a)')'      C573     (R542) If a data-stmt-constant is a structure-constructor , it shall be an initialization expression'
write(io,'(a)')''
write(io,'(a)')'      R543     int-constant-subobject        is   constant-subobject'
write(io,'(a)')''
write(io,'(a)')'      C574     (R543) int-constant-subobject shall be of type integer.'
write(io,'(a)')''
write(io,'(a)')'      R544     constant-subobject            is   designator'
write(io,'(a)')''
write(io,'(a)')'      C575     (R544) constant-subobject shall be a subobject of a constant.'
write(io,'(a)')''
write(io,'(a)')'      C576     (R544) Any subscript, substring starting point, or substring ending point shall be an initialization'
write(io,'(a)')''
write(io,'(a)')'   The data-stmt-object-list is expanded to form a sequence of pointers and scalar variables, referred to as "seque'
write(io,'(a)')'   of variables" in subsequent text. A nonpointer array whose unqualified name appears as a data-stmt-object or'
write(io,'(a)')'   data-i-do-object is equivalent to a complete sequence of its array elements in array element order (6.5.3.2). An'
write(io,'(a)')'   array section is equivalent to the sequence of its array elements in array element order. A data-implied-do is'
write(io,'(a)')'   expanded to form a sequence of array elements and structure components, under the control of the data-i-do-varia'
write(io,'(a)')'   as in the DO construct (8.1.7.6).'
write(io,'(a)')''
write(io,'(a)')'   The data-stmt-value-list is expanded to form a sequence of data-stmt-constants. A data-stmt-repeat indicates the'
write(io,'(a)')'   number of times the following data-stmt-constant is to be included in the sequence; omission of a data-stmt-repe'
write(io,'(a)')'   has the effect of a repeat factor of 1.'
write(io,'(a)')''
write(io,'(a)')'   A zero-sized array or a data-implied-do with an iteration count of zero contributes no variables to the expanded'
write(io,'(a)')'   sequence of variables, but a zero-length scalar character variable does contribute a variable to the expanded'
write(io,'(a)')'   sequence. A data-stmt-constant with a repeat factor of zero contributes no data-stmt-constants to the expanded'
write(io,'(a)')'   sequence of scalar data-stmt-constants.'
write(io,'(a)')''
write(io,'(a)')'   The expanded sequences of variables and data-stmt-constants are in one-to-one correspondence. Each data-stmt-con'
write(io,'(a)')'   specifies the initial value, initial data target, or null-init for the corresponding variable. The lengths of'
write(io,'(a)')'   the two expanded sequences shall be the same.'
write(io,'(a)')''
write(io,'(a)')'   A data-stmt-constant shall be null-init or initial-data-target if and only if the corresponding data-stmt-object'
write(io,'(a)')'   the POINTER attribute. If data-stmt-constant is null-init, the initial association status of the corresponding d'
write(io,'(a)')'   statement object is disassociated. If data-stmt-constant is initial-data-target the corresponding data statement'
write(io,'(a)')'   object shall be data-pointer-initialization compatible with the initial data target; the data statement object i'
write(io,'(a)')'   initially associated with the target.'
write(io,'(a)')''
write(io,'(a)')'   A data-stmt-constant other than boz-literal-constant, null-init, or initial-data-target shall be compatible with'
write(io,'(a)')'   corresponding variable according to the rules of intrinsic assignment (7.2.1.2). The variable is initially defin'
write(io,'(a)')'   with the value specified by the data-stmt-constant; if necessary, the value is converted according to the rules'
write(io,'(a)')'   intrinsic assignment (7.2.1.3) to a value that agrees in type, type parameters, and shape with the variable.'
write(io,'(a)')''
write(io,'(a)')'   If a data-stmt-constant is a boz-literal-constant, the corresponding variable shall be of type integer.'
write(io,'(a)')'   The boz-literal-constant is treated as if it were converted by the intrinsic function INT (13.7.81) to type inte'
write(io,'(a)')'   kind type parameter of the variable.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLES'
write(io,'(a)')'   Examples of DATA statements are:'
write(io,'(a)')''
write(io,'(a)')'          CHARACTER (LEN = 10) NAME'
write(io,'(a)')'          INTEGER, DIMENSION (0:9) :: MILES'
write(io,'(a)')'          REAL, DIMENSION (100, 100) :: SKEW'
write(io,'(a)')'          TYPE (NODE), POINTER :: HEAD_OF_LIST'
write(io,'(a)')'          TYPE (PERSON) MYNAME, YOURNAME'
write(io,'(a)')'          DATA NAME / ''JOHN DOE'' /, MILES / 10 * 0 /'
write(io,'(a)')'          DATA ((SKEW (K, J), J = 1, K), K = 1, 100) / 5050 * 0.0 /'
write(io,'(a)')'          DATA ((SKEW (K, J), J = K + 1, 100), K = 1, 99) / 4950 * 1.0 /'
write(io,'(a)')'          DATA HEAD_OF_LIST / NULL() /'
write(io,'(a)')'          DATA MYNAME / PERSON (21, ''JOHN SMITH'') /'
write(io,'(a)')'          DATA YOURNAME % AGE, YOURNAME % NAME / 35, ''FRED BROWN'' /'
write(io,'(a)')''
write(io,'(a)')'   The character variable NAME is initialized with the value JOHN DOE with padding on the right because'
write(io,'(a)')'   the length of the constant is less than the length of the variable. All ten elements of the integer array'
write(io,'(a)')'   MILES are initialized to zero. The two-dimensional array SKEW is initialized so that the lower triangle'
write(io,'(a)')'   of SKEW is zero and the strict upper triangle is one. The structures MYNAME and YOURNAME are'
write(io,'(a)')'   declared using the derived type PERSON from Note 4.17. The pointer HEAD OF LIST is declared using'
write(io,'(a)')'   the derived type NODE from Note 4.37; it is initially disassociated. MYNAME is initialized by a structure'
write(io,'(a)')'   constructor. YOURNAME is initialized by supplying a separate value for each component.'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'   OPEN(7f) - [FORTRAN:IO] Initiates or modifies a connection between an external file and a specified unit.'
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')''
write(io,'(a)')'  OPEN (connect-spec-list)'
write(io,'(a)')''
write(io,'(a)')'  connect-spec  is   [ UNIT = ] file-unit-number'
write(io,'(a)')'                or   ACCESS = scalar-default-char-expr'
write(io,'(a)')'                or   ACTION = scalar-default-char-expr'
write(io,'(a)')'                or   ASYNCHRONOUS = scalar-default-char-expr'
write(io,'(a)')'                or   BLANK = scalar-default-char-expr'
write(io,'(a)')'                or   DECIMAL = scalar-default-char-expr'
write(io,'(a)')'                or   DELIM = scalar-default-char-expr'
write(io,'(a)')'                or   ENCODING = scalar-default-char-expr'
write(io,'(a)')'                or   ERR = label'
write(io,'(a)')'                or   FILE = file-name-expr'
write(io,'(a)')'                            file-name-expr is scalar-default-char-expr'
write(io,'(a)')'                or   FORM = scalar-default-char-expr'
write(io,'(a)')'                or   IOMSG = iomsg-variable'
write(io,'(a)')'                             iomsg-variable is scalar-default-char-variable'
write(io,'(a)')'                or   IOSTAT = scalar-int-variable'
write(io,'(a)')'                or   NEWUNIT = scalar-int-variable'
write(io,'(a)')'                or   PAD = scalar-default-char-expr'
write(io,'(a)')'                or   POSITION = scalar-default-char-expr'
write(io,'(a)')'                or   RECL = scalar-int-expr'
write(io,'(a)')'                or   ROUND = scalar-default-char-expr'
write(io,'(a)')'                or   SIGN = scalar-default-char-expr'
write(io,'(a)')'                or   STATUS = scalar-default-char-expr'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   An OPEN statement initiates or modifies the connection between an external file and a specified unit. The'
write(io,'(a)')'   OPEN statement may be used to connect an existing file to a unit, create a file that is preconnected, create a f'
write(io,'(a)')'   and connect it to a unit, or change certain modes of a connection between a file and a unit.'
write(io,'(a)')''
write(io,'(a)')'   An external unit may be connected by an OPEN statement in the main program or any subprogram and, once'
write(io,'(a)')'   connected, a reference to it may appear in any program unit of the program.'
write(io,'(a)')''
write(io,'(a)')'   If the file to be connected to the unit does not exist but is the same as the file to which the unit is preconne'
write(io,'(a)')'   the modes specified by an OPEN statement become a part of the connection.'
write(io,'(a)')''
write(io,'(a)')'   If the file to be connected to the unit is not the same as the file to which the unit is connected, the effect i'
write(io,'(a)')'   if a CLOSE statement without a STATUS= specifier had been executed for the unit immediately prior to the'
write(io,'(a)')'   execution of an OPEN statement.'
write(io,'(a)')''
write(io,'(a)')'   If a unit is connected to a file that exists, execution of an OPEN statement for that unit is permitted. If the'
write(io,'(a)')'   FILE= specifier is not included in such an OPEN statement, the file to be connected to the unit is the same as'
write(io,'(a)')'   the file to which the unit is already connected.'
write(io,'(a)')''
write(io,'(a)')'   If the file to be connected to the unit is the same as the file to which the unit is connected, only the specifi'
write(io,'(a)')'   changeable modes (9.5.2) may have values different from those currently in effect. If the POSITION= specifier'
write(io,'(a)')'   appears in such an OPEN statement, the value specified shall not disagree with the current position of the file.'
write(io,'(a)')'   If the STATUS= specifier is included in such an OPEN statement, it shall be specified with the value OLD.'
write(io,'(a)')'   Execution of such an OPEN statement causes any new values of the specifiers for changeable modes to be in'
write(io,'(a)')'   effect, but does not cause any change in any of the unspecified specifiers and the position of the file is unaff'
write(io,'(a)')'   The ERR=, IOSTAT=, and IOMSG= specifiers from any previously executed OPEN statement have no effect'
write(io,'(a)')'   on any currently executed OPEN statement.'
write(io,'(a)')''
write(io,'(a)')'   A STATUS= specifier with a value of OLD is always allowed when the file to be connected to the unit is the same'
write(io,'(a)')'   as the file to which the unit is connected. In this case, if the status of the file was SCRATCH before execution'
write(io,'(a)')'   the OPEN statement, the file will still be deleted when the unit is closed, and the file is still considered to'
write(io,'(a)')'   a status of SCRATCH.'
write(io,'(a)')''
write(io,'(a)')'   If a file is already connected to a unit, an OPEN statement on that file with a different unit shall not be exec'
write(io,'(a)')''
write(io,'(a)')'OPTIONS'
write(io,'(a)')''
write(io,'(a)')'A specifier that requires a scalar-default-char-expr may have a'
write(io,'(a)')'limited list of character values. These values are listed for each'
write(io,'(a)')'such specifier. Any trailing blanks are ignored. The value specified'
write(io,'(a)')'is without regard to case. Some specifiers have a default value if the'
write(io,'(a)')'specifier is omitted. No specifier shall appear more than once in a'
write(io,'(a)')'given connect-spec-list.'
write(io,'(a)')''
write(io,'(a)')'If the NEWUNIT= specifier does not appear, a file-unit-number shall'
write(io,'(a)')'be specified; if the optional characters UNIT= are omitted, the'
write(io,'(a)')'file-unit-number shall be the first item in the connect-spec-list.'
write(io,'(a)')''
write(io,'(a)')'The label used in the ERR= specifier shall be the statement label of'
write(io,'(a)')'a branch target statement that appears in the same scoping unit as the'
write(io,'(a)')'OPEN statement.'
write(io,'(a)')''
write(io,'(a)')'If a NEWUNIT= specifier appears, a file-unit-number shall not appear.'
write(io,'(a)')''
write(io,'(a)')'STATUS   If the STATUS= specifier has the value NEW or REPLACE, the FILE= specifier shall appear. If the STATUS='
write(io,'(a)')'         specifier has the value SCRATCH, the FILE= specifier shall not appear. If the STATUS= specifier has the va'
write(io,'(a)')'         OLD, the FILE= specifier shall appear unless the unit is connected and the file connected to the unit exis'
write(io,'(a)')''
write(io,'(a)')'NEWUNIT  If the NEWUNIT= specifier appears in an OPEN statement, either the FILE= specifier shall appear, or the'
write(io,'(a)')'         STATUS= specifier shall appear with a value of SCRATCH. The unit identified by a NEWUNIT value shall not'
write(io,'(a)')'         be preconnected.'
write(io,'(a)')''
write(io,'(a)')'IOSTAT=, ERR=, and IOMSG=   specifiers are described in 9.11.'
write(io,'(a)')''
write(io,'(a)')'ACCESS   The scalar-default-char-expr shall evaluate to SEQUENTIAL, DIRECT, or STREAM. The ACCESS= specifier'
write(io,'(a)')'         specifies the access method for the connection of the file as being sequential, direct, or stream. If this'
write(io,'(a)')'         omitted, the default value is SEQUENTIAL. For an existing file, the specified access method shall be inclu'
write(io,'(a)')'         the set of allowed access methods for the file. For a new file, the processor creates the file with a set'
write(io,'(a)')'         access methods that includes the specified method.'
write(io,'(a)')''
write(io,'(a)')'ACTION   The scalar-default-char-expr shall evaluate to READ, WRITE, or READWRITE. READ specifies that the'
write(io,'(a)')'         WRITE, PRINT, and ENDFILE statements shall not refer to this connection. WRITE specifies that READ'
write(io,'(a)')'         statements shall not refer to this connection. READWRITE permits any input/output statements to refer to t'
write(io,'(a)')'         connection. If this specifier is omitted, the default value is processor dependent. If READWRITE is includ'
write(io,'(a)')'         the set of allowable actions for a file, both READ and WRITE also shall be included in the set of allowed'
write(io,'(a)')'         for that file. For an existing file, the specified action shall be included in the set of allowed actions'
write(io,'(a)')'         For a new file, the processor creates the file with a set of allowed actions that includes the specified a'
write(io,'(a)')''
write(io,'(a)')'ASYNCHRONOUS   The scalar-default-char-expr shall evaluate to YES or NO. If YES is specified, asynchronous input/ou'
write(io,'(a)')'               the unit is allowed. If NO is specified, asynchronous input/output on the unit is not allowed. If th'
write(io,'(a)')'               omitted, the default value is NO.'
write(io,'(a)')''
write(io,'(a)')'BLANK   The scalar-default-char-expr shall evaluate to NULL or ZERO. The BLANK= specifier is permitted only for a'
write(io,'(a)')'        connection for formatted input/output. It specifies the current value of the blank interpretation mode'
write(io,'(a)')'        (10.8.6, 9.6.2.6) for input for this connection. This mode has no effect on output. It is a changeable mode'
write(io,'(a)')'        If this specifier is omitted in an OPEN statement that initiates a connection, the default value is NULL.'
write(io,'(a)')''
write(io,'(a)')'DECIMAL   The scalar-default-char-expr shall evaluate to COMMA or POINT. The DECIMAL= specifier is permitted only'
write(io,'(a)')'          for a connection for formatted input/output. It specifies the current value of the decimal edit mode'
write(io,'(a)')'          (10.6, 10.8.8, 9.6.2.7)'
write(io,'(a)')'          for this connection. This is a changeable mode (9.5.2). If this specifier is omitted in an OPEN statement'
write(io,'(a)')'          that initiates a connection, the default value is POINT.'
write(io,'(a)')''
write(io,'(a)')'DELIM   The scalar-default-char-expr shall evaluate to APOSTROPHE, QUOTE, or NONE. The DELIM= specifier is'
write(io,'(a)')'        permitted only for a connection for formatted input/output. It specifies the current value of the delimiter'
write(io,'(a)')'        (9.6.2.8) for list-directed (10.10.4) and namelist (10.11.4.2) output for the connection. This mode has no'
write(io,'(a)')'        on input. It is a changeable mode (9.5.2). If this specifier is omitted in an OPEN statement that initiates'
write(io,'(a)')'        connection, the default value is NONE.'
write(io,'(a)')''
write(io,'(a)')'ENCODING   The scalar-default-char-expr shall evaluate to UTF-8 or DEFAULT. The ENCODING= specifier is permitted'
write(io,'(a)')'           only for a connection for formatted input/output. The value UTF-8 specifies that the encoding form of th'
write(io,'(a)')'           UTF-8 as specified by ISO/IEC 10646-1:2000. Such a file is called a Unicode file, and all characters the'
write(io,'(a)')'           of ISO 10646 character type. The value UTF-8 shall not be specified if the processor does not support th'
write(io,'(a)')'           10646 character type. The value DEFAULT specifies that the encoding form of the file is processor-depend'
write(io,'(a)')'           If this specifier is omitted in an OPEN statement that initiates a connection, the default value is DEFA'
write(io,'(a)')''
write(io,'(a)')'FILE   The value of the FILE= specifier is the name of the file to be connected to the specified unit. Any trailing'
write(io,'(a)')'       are ignored. The file-name-expr shall be a name that is allowed by the processor. If this specifier is omitt'
write(io,'(a)')'       the unit is not connected to a file, the STATUS= specifier shall be specified with a value of SCRATCH; in th'
write(io,'(a)')'       case, the connection is made to a processor-dependent file. The interpretation of case is processor dependen'
write(io,'(a)')''
write(io,'(a)')'FORM   The scalar-default-char-expr shall evaluate to FORMATTED or UNFORMATTED. The FORM= specifier determines'
write(io,'(a)')'       whether the file is being connected for formatted or unformatted input/output. If this specifier is omitted,'
write(io,'(a)')'       the default value is UNFORMATTED if the file is being connected for direct access or stream access, and the'
write(io,'(a)')'       default value is FORMATTED if the file is being connected for sequential access. For an existing file, the s'
write(io,'(a)')'       form shall be included in the set of allowed forms for the file. For a new file, the processor creates the f'
write(io,'(a)')'       set of allowed forms that includes the specified form.'
write(io,'(a)')''
write(io,'(a)')'NEWUNIT   The variable is defined with a processor determined NEWUNIT value if no error occurs during the execution'
write(io,'(a)')'          the OPEN statement. If an error occurs, the processor shall not change the value of the variable.'
write(io,'(a)')''
write(io,'(a)')'          A NEWUNIT value is a negative number, and shall not be equal to -1, any of the named constants ERROR_UNIT'
write(io,'(a)')'          INPUT_UNIT, or OUTPUT_UNIT from the intrinsic module ISO_FORTRAN_ENV (13.8.2), any value'
write(io,'(a)')'          used by the processor for the unit argument to a defined input/output procedure, nor any previous NEWUNIT'
write(io,'(a)')'          value that identifies a file that is currently connected.'
write(io,'(a)')''
write(io,'(a)')'PAD    The scalar-default-char-expr shall evaluate to YES or NO. The PAD= specifier is permitted only for a connect'
write(io,'(a)')'       for formatted input/output. It specifies the current value of the pad mode (9.6.4.4.3, 9.6.2.10) for input f'
write(io,'(a)')'       connection. This mode has no effect on output. It is a changeable mode (9.5.2). If this specifier is omitted'
write(io,'(a)')'       OPEN statement that initiates a connection, the default value is YES.'
write(io,'(a)')''
write(io,'(a)')'POSITION   The scalar-default-char-expr shall evaluate to ASIS, REWIND, or APPEND. The connection shall be for sequ'
write(io,'(a)')'           or stream access. A new file is positioned at its initial point. REWIND positions an existing file at it'
write(io,'(a)')'           point. APPEND positions an existing file such that the endfile record is the next record, if it has one.'
write(io,'(a)')'           existing file does not have an endfile record, APPEND positions the file at its terminal point. ASIS lea'
write(io,'(a)')'           position unchanged if the file exists and already is connected. ASIS leaves the position unspecified if'
write(io,'(a)')'           but is not connected. If this specifier is omitted, the default value is ASIS.'
write(io,'(a)')''
write(io,'(a)')'RECL       The value of the RECL= specifier shall be positive. It specifies the length of each record in a file bei'
write(io,'(a)')'           for direct access, or specifies the maximum length of a record in a file being connected for sequential'
write(io,'(a)')'           specifier shall not appear when a file is being connected for stream access. This specifier shall appear'
write(io,'(a)')'           file is being connected for direct access. If this specifier is omitted when a file is being connected f'
write(io,'(a)')'           access, the default value is processor dependent. If the file is being connected for formatted input/out'
write(io,'(a)')'           length is the number of characters for all records that contain only characters of default kind. When a'
write(io,'(a)')'           contains any nondefault characters, the effect of the RECL= specifier is processor dependent. If the fil'
write(io,'(a)')'           connected for unformatted input/output, the length is measured in file storage units. For an existing fi'
write(io,'(a)')'           value of the RECL= specifier shall be included in the set of allowed record lengths for the file. For a'
write(io,'(a)')'           processor creates the file with a set of allowed record lengths that includes the specified value.'
write(io,'(a)')''
write(io,'(a)')'ROUND      The scalar-default-char-expr shall evaluate to one of UP, DOWN, ZERO, NEAREST, COMPATIBLE, or PROCESSOR'
write(io,'(a)')'           The ROUND= specifier is permitted only for a connection for formatted input/output. It'
write(io,'(a)')'           specifies the current value of the I/O rounding mode (10.7.2.3.7, 9.6.2.13) for this connection. This is'
write(io,'(a)')'           mode (9.5.2). If this specifier is omitted in an OPEN statement that initiates a connection, the I/O rou'
write(io,'(a)')'           mode is processor dependent; it shall be one of the above modes.'
write(io,'(a)')''
write(io,'(a)')'           A processor is free to select any I/O rounding mode for the default mode. The mode might correspond'
write(io,'(a)')'           to UP, DOWN, ZERO, NEAREST, or COMPATIBLE; or it might be a completely different I/O rounding mode.'
write(io,'(a)')''
write(io,'(a)')'SIGN       The scalar-default-char-expr shall evaluate to one of PLUS, SUPPRESS, or PROCESSOR DEFINED. The'
write(io,'(a)')'          SIGN= specifier is permitted only for a connection for formatted input/output. It specifies the current v'
write(io,'(a)')'          the sign mode (10.8.4, 9.6.2.14) for this connection. This is a changeable mode (9.5.2). If this specifie'
write(io,'(a)')'          in an OPEN statement that initiates a connection, the default value is PROCESSOR DEFINED.'
write(io,'(a)')''
write(io,'(a)')'STATUS    The scalar-default-char-expr shall evaluate to OLD, NEW, SCRATCH, REPLACE, or UNKNOWN. If OLD is'
write(io,'(a)')'          specified, the file shall exist. If NEW is specified, the file shall not exist.'
write(io,'(a)')''
write(io,'(a)')'          Successful execution of an OPEN statement with NEW specified creates the file and changes the status to O'
write(io,'(a)')'          If REPLACE is specified and the file does not already exist, the file is created and the status is change'
write(io,'(a)')'          If REPLACE is specified and the file does exist, the file is deleted, a new file is created with the same'
write(io,'(a)')'          the status is changed to OLD. If SCRATCH is specified, the file is created and connected to the specified'
write(io,'(a)')'          for use by the program but is deleted at the execution of a CLOSE statement referring to the same unit or'
write(io,'(a)')'          the normal termination of the program.'
write(io,'(a)')''
write(io,'(a)')'          SCRATCH shall not be specified with a named file.'
write(io,'(a)')''
write(io,'(a)')'          If UNKNOWN is specified, the status is processor dependent. If this specifier is omitted, the default val'
write(io,'(a)')'          UNKNOWN.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLES'
write(io,'(a)')''
write(io,'(a)')'An example of an OPEN statement is:'
write(io,'(a)')''
write(io,'(a)')'   integer :: IOS'
write(io,'(a)')'   character(len=256) :: MESSAGE'
write(io,'(a)')'   OPEN (10, FILE=''employee.names'', ACTION=''READ'', IOSTAT=IOS,IOMSG=MESSAGE)'
write(io,'(a)')'   IF (IOS < 0) THEN'
write(io,'(a)')'           ! Perform end-of-file processing on the file connected to unit 3.'
write(io,'(a)')'           CALL END_PROCESSING()'
write(io,'(a)')'   ELSE IF (IOS > 0) THEN'
write(io,'(a)')'           ! Perform error processing'
write(io,'(a)')'           write(*,''(a)'')trim(message)'
write(io,'(a)')'           CALL ERROR_PROCESSING()'
write(io,'(a)')'           stop'
write(io,'(a)')'   END IF'
write(io,'(a)')'NAME'
write(io,'(a)')'     use(7f) - [FORTRAN] gives a program unit accessibility to public entities in a module.'
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'   USE [, mode-nature ::] namespace [, rename-list]'
write(io,'(a)')'   USE [, mode-nature ::] namespace [,ONLY: only-list]'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   The USE statement makes the specified namespace accessible to the'
write(io,'(a)')'   current scoping unit. It also provides a means of renaming or limiting'
write(io,'(a)')'   the accessibility of entities in the namespace.'
write(io,'(a)')''
write(io,'(a)')'   WHERE:'
write(io,'(a)')''
write(io,'(a)')'   mode-nature    Is INTRINSIC or NON_INTRINSIC. If INTRINSIC is used, namespace'
write(io,'(a)')'                  must be the name of an intrinsic module. If NON_INTRINSIC is used,'
write(io,'(a)')'                  namespace must be the name of an nonintrinsic module. If mod-nature is'
write(io,'(a)')'                  not specified, namespace must be the name of an intrinsic or nonintrinsic'
write(io,'(a)')'                  module. If both are provided, the nonintrinsic module is used. It is an'
write(io,'(a)')'                  error to specify a user module and an intrinsic module of the same name'
write(io,'(a)')'                  in the same program unit.'
write(io,'(a)')'   namespace    is a publicly accessible namespace; ie. it is the name of a module.'
write(io,'(a)')''
write(io,'(a)')'   rename-list  is a comma-separated list of local-name => use-name'
write(io,'(a)')'   only-list    is a comma-separated list of access-id or [local-name => use-name]'
write(io,'(a)')''
write(io,'(a)')'                 local-name      is the local name for the entity specified by use-name'
write(io,'(a)')'                                 Is the name of the entity in the program unit using the module or is'
write(io,'(a)')'                                 "OPERATOR (op-name)", where op-name is the name of a defined operator'
write(io,'(a)')'                                 in the program unit using the module.'
write(io,'(a)')'                 use-name        is the name of a public entity in the specified namespace'
write(io,'(a)')'                 access-id       is use-name or generic-spec'
write(io,'(a)')'                 generic-spec    is generic-name'
write(io,'(a)')'                                 or OPERATOR (defined-operator)'
write(io,'(a)')'                                 or ASSIGNMENT (=)'
write(io,'(a)')''
write(io,'(a)')'                               generic-name is the name of a generic procedure'
write(io,'(a)')''
write(io,'(a)')'                               defined-operator is one of the intrinsic operators'
write(io,'(a)')''
write(io,'(a)')'                               or .op-name.'
write(io,'(a)')''
write(io,'(a)')'                               .op-name. is a user-defined name for the operation'
write(io,'(a)')''
write(io,'(a)')'   REMARKS'
write(io,'(a)')''
write(io,'(a)')'   rename-list and ONLY: only-list may only appear if the namespace being'
write(io,'(a)')'   used was implemented with Fortran for .NET'
write(io,'(a)')''
write(io,'(a)')'   A USE statement without ONLY provides access to all PUBLIC entities in'
write(io,'(a)')'   the specified namespace.'
write(io,'(a)')''
write(io,'(a)')'   A USE statement with ONLY provides access only to those entities that'
write(io,'(a)')'   appear in the only-list.'
write(io,'(a)')''
write(io,'(a)')'   If more than one USE statement appears in a scoping unit, the rename-lists'
write(io,'(a)')'   and only-lists are treated as one concatenated rename-list.'
write(io,'(a)')''
write(io,'(a)')'   If two or more generic interfaces that are accessible in the same'
write(io,'(a)')'   scoping unit have the same name, same operator, or are assignments,'
write(io,'(a)')'   they are interpreted as a single generic interface.'
write(io,'(a)')''
write(io,'(a)')'   Two or more accessible entities, other than generic interfaces, can'
write(io,'(a)')'   have the same name only if no entity is referenced by this name in the'
write(io,'(a)')'   scoping unit.'
write(io,'(a)')''
write(io,'(a)')'   If local-name is absent, the use-name is available by use association.'
write(io,'(a)')''
write(io,'(a)')'   An entity can be accessed by more than one local-name.'
write(io,'(a)')''
write(io,'(a)')'   A local-name must not be declared with different attributes in the'
write(io,'(a)')'   scoping unit that contains the USE statement, except that it can appear'
write(io,'(a)')'   in a PUBLIC or PRIVATE statement in the scoping unit of a module.'
write(io,'(a)')''
write(io,'(a)')'   Forward references to modules are not allowed. That is, if a module is'
write(io,'(a)')'   used in the same source file in which it resides, the module program'
write(io,'(a)')'   unit must appear before its use.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLES'
write(io,'(a)')' Samples:'
write(io,'(a)')''
write(io,'(a)')'   module example ! example is the namespace name'
write(io,'(a)')'      type type1 ! type1 is the class prototype name'
write(io,'(a)')'      contains'
write(io,'(a)')'         procedure, nopass :: static_method1'
write(io,'(a)')'      end type type1'
write(io,'(a)')'      type type2 ! type1 is the class prototype name'
write(io,'(a)')'      contains'
write(io,'(a)')'         procedure, nopass :: static_method2'
write(io,'(a)')'      end type type2'
write(io,'(a)')'   contains'
write(io,'(a)')'      subroutine static_method1(arg)'
write(io,'(a)')'         integer :: arg'
write(io,'(a)')'         ! code to implement method goes here'
write(io,'(a)')'      end subroutine static_method1'
write(io,'(a)')'      subroutine static_method2(arg)'
write(io,'(a)')'         integer :: arg'
write(io,'(a)')'         ! code to implement method goes here'
write(io,'(a)')'      end subroutine static_method2'
write(io,'(a)')'   end module example'
write(io,'(a)')''
write(io,'(a)')'   use example ! all public objects in namespace example available'
write(io,'(a)')''
write(io,'(a)')'   use example, only: type1 ! class prototype type1 available,'
write(io,'(a)')'                            ! class prototype type2 not available'
write(io,'(a)')''
write(io,'(a)')'   ! within this scoping unit, type1 is referred to as "mytype"'
write(io,'(a)')'   use example, mytype => type1'
write(io,'(a)')''
write(io,'(a)')'SEE ALSO'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'   implied_do(7f) - [FORTRAN] documentation on usage of implied do in Fortran'
write(io,'(a)')''
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Examples using implied DO loops in Fortran code.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLES'
write(io,'(a)')''
write(io,'(a)')' Sample Programs:'
write(io,'(a)')''
write(io,'(a)')'   program demo_implied_do'
write(io,'(a)')'   implicit none'
write(io,'(a)')'      integer :: i'
write(io,'(a)')'      ! [A-Z] [a-z] alphabet'
write(io,'(a)')'      character(len=1),parameter :: a2z(26*2)=[(char(i),i=65,90),(char(i),i=97,122)]'
write(io,'(a)')'      write(*,*)''Alphabet='',a2z'
write(io,'(a)')'   end program demo_implied_do'
write(io,'(a)')''
write(io,'(a)')' Expected output:'
write(io,'(a)')''
write(io,'(a)')'   Alphabet=ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
write(io,'(a)')''
write(io,'(a)')' Examples of array constructors containing an implied DO are:'
write(io,'(a)')''
write(io,'(a)')'   (/ (I, I = 1, 1075) /)'
write(io,'(a)')''
write(io,'(a)')' and'
write(io,'(a)')''
write(io,'(a)')'   N=20'
write(io,'(a)')'   [ 3.6, (3.6 / I, I = 1, N) ]'
write(io,'(a)')''
write(io,'(a)')' For an io-implied-do, the loop initialization and execution are the same as for a DO construct.'
write(io,'(a)')' An example of an output list with an implied DO is:'
write(io,'(a)')''
write(io,'(a)')'   WRITE (LP, FMT = ''(10F8.2)'') (LOG (A (I)), I = 1, N + 9, K), G'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'   fortran(7f) - [FORTRAN] Fortran Example'
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'   array_constructors (7f) - [FORTRAN] An array constructor can be used to create and assign values to rank-one arr'
write(io,'(a)')'   backspace (7)         [FORTRAN:FILE_POSITIONING] - backspace one record on specified I/O unit'
write(io,'(a)')'   block (7)             [FORTRAN:EXECUTION CONTROL] construct'
write(io,'(a)')'   case (7)              [FORTRAN:EXECUTION CONTROL] masked array assignment'
write(io,'(a)')'   continue (7)          [FORTRAN:EXECUTION CONTROL] construct'
write(io,'(a)')'   cycle (7)             [FORTRAN:EXECUTION CONTROL] construct'
write(io,'(a)')'   data (7)              [FORTRAN] DATA statement'
write(io,'(a)')'   do (7)                [FORTRAN:EXECUTION CONTROL] construct'
write(io,'(a)')'   endselect (7)         [FORTRAN:EXECUTION CONTROL] masked array assignment'
write(io,'(a)')'   exit (7)              [FORTRAN:EXECUTION CONTROL] statement'
write(io,'(a)')'   flush (7)             [FORTRAN:IO] flush I/O buffers of specified files'
write(io,'(a)')'   fortran_continuation_line (7)  [FORTRAN] Fortran Continuation Lines'
write(io,'(a)')'   if (7)                  [FORTRAN:EXECUTION CONTROL] selects a block based on a sequence of logical expressions.'
write(io,'(a)')'   implicit (7)            [FORTRAN:STATEMENT] specify default type (if any) associated to a starting letter'
write(io,'(a)')'   implied_do (7)          [FORTRAN] documentation on usage of implied do in Fortran'
write(io,'(a)')'   include (7)             [FORTRAN] including source text'
write(io,'(a)')'   initialize_arrays (7)   [FORTRAN:FAQ] Initializing small 2D numeric arrays with array constructors'
write(io,'(a)')'   inquire(7f)             [FORTRAN:FILE_INQUIRE] File inquiry statement'
write(io,'(a)')'   intrinsics (7)          [FORTRAN]intrinsic man(1) pages'
write(io,'(a)')'   intrinsics_project (7)  [FORTRAN] intrinsic man(1) pages'
write(io,'(a)')'   namelist (7)          [FORTRAN:STATEMENT] specify a group of data to be referred to by a single name in data inp'
write(io,'(a)')'   nullify (7)           [FORTRAN:STATEMENT] causes pointers to be disassociated'
write(io,'(a)')'   open (7)              [FORTRAN:IO] Initiates or modifies a connection between an external file and a specified u'
write(io,'(a)')'   save (7)              [FORTRAN:STATEMENT:ATTRIBUTE] specifies that a local variable retains its status and value'
write(io,'(a)')'   scratch (7)           [FORTRAN:OPEN] where scratch files are typically written by OPEN(3f)'
write(io,'(a)')'   select (7)            [FORTRAN:EXECUTION CONTROL] masked array assignment'
write(io,'(a)')'   sign (7)              [FORTRAN:IO] option to force optional plus sign on output values'
write(io,'(a)')'   stop (7)              [FORTRAN:STATEMENT] initiates termination of execution'
write(io,'(a)')'   use (7)               [FORTRAN] gives a program unit accessibility to public entities in a module.'
write(io,'(a)')'   where (7)             [FORTRAN:ASSIGNMENT] masked array assignment'
write(io,'(a)')''
write(io,'(a)')'   abs (3)               [INTRINSIC:NUMERIC] Absolute value'
write(io,'(a)')'   achar (3)             [INTRINSIC:CHARACTER] returns a character in a specified position in the ASCII collating s'
write(io,'(a)')'   acos (3)              [INTRINSIC:TRIGONOMETRIC] Arccosine function'
write(io,'(a)')'   acosh (3)             [INTRINSIC:TRIGONOMETRIC] Inverse hyperbolic cosine function'
write(io,'(a)')'   adjustl (3)           [INTRINSIC:CHARACTER] Left adjust a string'
write(io,'(a)')'   adjustr (3)           [INTRINSIC:CHARACTER] Right adjust a string'
write(io,'(a)')'   aimag (3)             [INTRINSIC:NUMERIC] Imaginary part of complex number'
write(io,'(a)')'   aint (3)              [INTRINSIC:NUMERIC] Truncate to a whole number'
write(io,'(a)')'   all (3)               [INTRINSIC:TRANSFORMATIONAL FUNCTION] determines if all the values are true'
write(io,'(a)')'   allocated (3)         [INTRINSIC:ARRAY INQUIRY] Status of an allocatable entity'
write(io,'(a)')'   anint (3)             [INTRINSIC:NUMERIC] Nearest whole number'
write(io,'(a)')'   any (3)               [INTRINSIC:TRANSFORMATIONAL FUNCTION] determines if any of the values in the logical array'
write(io,'(a)')'   asin (3)              [INTRINSIC:TRIGONOMETRIC] Arcsine function'
write(io,'(a)')'   asinh (3)             [INTRINSIC:TRIGONOMETRIC] Inverse hyperbolic sine function'
write(io,'(a)')'   associated (3)        [INTRINSIC] Status of a pointer or pointer/target pair'
write(io,'(a)')'   atan (3)              [INTRINSIC:TRIGONOMETRIC] Arctangent function'
write(io,'(a)')'   atan2 (3)             [INTRINSIC:TRIGONOMETRIC] Arctangent function'
write(io,'(a)')'   atanh (3)             [INTRINSIC:TRIGONOMETRIC] Inverse hyperbolic tangent function'
write(io,'(a)')'   atomic_add (3)        [INTRINSIC] Atomic ADD operation'
write(io,'(a)')'   atomic_and (3)        [INTRINSIC:ATOMIC:BIT MANIPULATION] Atomic bitwise AND operation'
write(io,'(a)')'   atomic_cas (3)        [INTRINSIC] Atomic compare and swap'
write(io,'(a)')'   atomic_define (3)     [INTRINSIC] Setting a variable atomically'
write(io,'(a)')'   atomic_fetch_add (3)  [INTRINSIC] Atomic ADD operation with prior fetch'
write(io,'(a)')'   atomic_fetch_and (3)  [INTRINSIC:ATOMIC:BIT MANIPULATION] Atomic bitwise AND operation with prior fetch'
write(io,'(a)')'   atomic_fetch_or (3)   [INTRINSIC:ATOMIC:BIT MANIPULATION] Atomic bitwise OR operation with prior fetch'
write(io,'(a)')'   atomic_fetch_xor (3)  [INTRINSIC:ATOMIC:BIT MANIPULATION] Atomic bitwise XOR operation with prior fetch'
write(io,'(a)')'   atomic_or (3)         [INTRINSIC:ATOMIC:BIT MANIPULATION] Atomic bitwise OR operation'
write(io,'(a)')'   atomic_ref (3)        [INTRINSIC] Obtaining the value of a variable atomically'
write(io,'(a)')'   atomic_xor (3)        [INTRINSIC:ATOMIC:BIT MANIPULATION] Atomic bitwise OR operation'
write(io,'(a)')'   bessel_j0 (3)         [INTRINSIC:MATHEMATICS] Bessel function of the first kind of order 0'
write(io,'(a)')'   bessel_j1 (3)         [INTRINSIC:MATHEMATICS] Bessel function of the first kind of order 1'
write(io,'(a)')'   bessel_jn (3)         [INTRINSIC:MATHEMATICS] Bessel function of the first kind'
write(io,'(a)')'   bessel_y0 (3)         [INTRINSIC:MATHEMATICS] Bessel function of the second kind of order 0'
write(io,'(a)')'   bessel_y1 (3)         [INTRINSIC:MATHEMATICS] Bessel function of the second kind of order 1'
write(io,'(a)')'   bessel_yn (3)         [INTRINSIC:MATHEMATICS] Bessel function of the second kind'
write(io,'(a)')'   bge (3)               [INTRINSIC:BIT COMPARE] Bitwise greater than or equal to'
write(io,'(a)')'   bgt (3)               [INTRINSIC:BIT COMPARE] Bitwise greater than'
write(io,'(a)')'   bit_size (3)          [INTRINSIC:BIT INQUIRY] Bit size inquiry function'
write(io,'(a)')'   ble (3)               [INTRINSIC:BIT COMPARE] Bitwise less than or equal to'
write(io,'(a)')'   blt (3)               [INTRINSIC:BIT COMPARE] Bitwise less than'
write(io,'(a)')'   btest (3)             [INTRINSIC:BIT MANIPULATION] Bit test function'
write(io,'(a)')'   c_associated (3)      [INTRINSIC:ISO_C_BINDING] Status of a C pointer'
write(io,'(a)')'   c_f_pointer (3)       [INTRINSIC:ISO_C_BINDING] Convert C into Fortran pointer'
write(io,'(a)')'   c_f_procpointer (3)   [INTRINSIC:ISO_C_BINDING] Convert C into Fortran procedure pointer'
write(io,'(a)')'   c_funloc (3)          [INTRINSIC:ISO_C_BINDING] Obtain the C address of a procedure'
write(io,'(a)')'   c_loc (3)             [INTRINSIC:ISO_C_BINDING] Obtain the C address of an object'
write(io,'(a)')'   c_sizeof (3)          [INTRINSIC:ISO_C_BINDING] Size in bytes of an expression'
write(io,'(a)')'   ceiling (3)           [INTRINSIC:NUMERIC] Integer ceiling function'
write(io,'(a)')'   char (3)              [INTRINSIC:CHARACTER] Character conversion function'
write(io,'(a)')'   cmplx (3)             [INTRINSIC:NUMERIC] Complex conversion function'
write(io,'(a)')'   co_broadcast (3)      [INTRINSIC] Copy a value to all images the current set of images'
write(io,'(a)')'   co_lbound (3)         [INTRINSIC] Lower codimension bounds of an array'
write(io,'(a)')'   co_max (3)            [INTRINSIC] Maximal value on the current set of images'
write(io,'(a)')'   co_min (3)            [INTRINSIC] Minimal value on the current set of images'
write(io,'(a)')'   co_reduce (3)         [INTRINSIC] Reduction of values on the current set of images'
write(io,'(a)')'   co_sum (3)            [INTRINSIC] Sum of values on the current set of images'
write(io,'(a)')'   co_ubound (3)         [INTRINSIC] Upper codimension bounds of an array'
write(io,'(a)')'   command_argument_count (3)  [INTRINSIC:SYSTEM ENVIRONMENT] Get number of command line arguments'
write(io,'(a)')'   compiler_options (3)  [INTRINSIC] Options passed to the compiler'
write(io,'(a)')'   compiler_version (3)  [INTRINSIC] Compiler version string'
write(io,'(a)')'   conjg (3)             [INTRINSIC:NUMERIC] Complex conjugate function'
write(io,'(a)')'   cos (3)               [INTRINSIC:TRIGONOMETRIC] Cosine function'
write(io,'(a)')'   cosh (3)              [INTRINSIC:TRIGONOMETRIC] Hyperbolic cosine function'
write(io,'(a)')'   count (3)             [INTRINSIC:TRANSFORMATIONAL FUNCTION] Count function'
write(io,'(a)')'   cpu_time (3)          [INTRINSIC:SYSTEM ENVIRONMENT] return CPU processor time in seconds'
write(io,'(a)')'   cshift (3)            [INTRINSIC:TRANSFORMATIONAL FUNCTION] Circular shift elements of an array'
write(io,'(a)')'   date_and_time (3)     [INTRINSIC:SYSTEM ENVIRONMENT] gets current time'
write(io,'(a)')'   dble (3)              [INTRINSIC:NUMERIC] Double conversion function'
write(io,'(a)')'   digits (3)            [INTRINSIC] Significant digits function'
write(io,'(a)')'   dim (3)               [INTRINSIC:NUMERIC] Positive difference'
write(io,'(a)')'   dot_product (3)       [INTRINSIC:TRANSFORMATIONAL FUNCTION] Dot product function'
write(io,'(a)')'   dprod (3)             [INTRINSIC:NUMERIC] Double product function'
write(io,'(a)')'   dshiftl (3)           [INTRINSIC:BIT MANIPULATION] combines bits of arguments I and J'
write(io,'(a)')'   dshiftr (3)           [INTRINSIC:BIT MANIPULATION] combines bits of arguments I and J'
write(io,'(a)')'   eoshift (3)           [INTRINSIC:TRANSFORMATIONAL FUNCTION] End-off shift elements of an array'
write(io,'(a)')'   epsilon (3)           [INTRINSIC] Epsilon function'
write(io,'(a)')'   erf (3)               [INTRINSIC:MATHEMATICS] Error function'
write(io,'(a)')'   erfc (3)              [INTRINSIC:MATHEMATICS] Complementary error function'
write(io,'(a)')'   erfc_scaled (3)       [INTRINSIC:MATHEMATICS] Error function'
write(io,'(a)')'   event_query (3)       [INTRINSIC] Query whether a coarray event has occurred'
write(io,'(a)')'   execute_command_line (3)  [INTRINSIC:SYSTEM ENVIRONMENT] Execute a shell command'
write(io,'(a)')'   exp (3)               [INTRINSIC:MATHEMATICS] Exponential function'
write(io,'(a)')'   exponent (3)          [INTRINSIC:MODEL_COMPONENTS] Exponent function'
write(io,'(a)')'   extends_type_of (3)   [INTRINSIC] True if and only if the dynamic type of A is an extension of the dynamic type'
write(io,'(a)')'   findloc (3)           [INTRINSIC] Location of the first element of ARRAY identified by MASK along dimension DIM'
write(io,'(a)')'   float (3)             [INTRINSIC] Convert integer to default real'
write(io,'(a)')'   floor (3)             [INTRINSIC:NUMERIC] Integer floor function'
write(io,'(a)')'   fraction (3)          [INTRINSIC:MODEL_COMPONENTS] Fractional part of the model representation'
write(io,'(a)')'   gamma (3)             [INTRINSIC:MATHEMATICS] Gamma function'
write(io,'(a)')'   get_command (3)       [INTRINSIC:SYSTEM ENVIRONMENT] Get the entire command line'
write(io,'(a)')'   get_command_argument (3)  [INTRINSIC:SYSTEM ENVIRONMENT] Get command line arguments'
write(io,'(a)')'   get_environment_variable (3)  [INTRINSIC:SYSTEM ENVIRONMENT] Get an environmental variable'
write(io,'(a)')'   huge (3)              [INTRINSIC] Largest number of a kind'
write(io,'(a)')'   hypot (3)             [INTRINSIC:MATHEMATICS] Euclidean distance function'
write(io,'(a)')'   iachar (3)            [INTRINSIC:CHARACTER] Code in ASCII collating sequence'
write(io,'(a)')'   iall (3)              [INTRINSIC:BIT MANIPULATION] Bitwise and of array elements'
write(io,'(a)')'   iand (3)              [INTRINSIC:BIT MANIPULATION] Bitwise logical and'
write(io,'(a)')'   iany (3)              [INTRINSIC:BIT MANIPULATION] Bitwise or of array elements'
write(io,'(a)')'   ibclr (3)             [INTRINSIC:BIT MANIPULATION] Clear bit'
write(io,'(a)')'   ibits (3)             [INTRINSIC:BIT MANIPULATION] Bit extraction'
write(io,'(a)')'   ibset (3)             [INTRINSIC:BIT MANIPULATION] Set bit'
write(io,'(a)')'   ichar (3)             [INTRINSIC:CHARACTER] Character-to-integer conversion function'
write(io,'(a)')'   ieor (3)              [INTRINSIC:BIT MANIPULATION] Bitwise logical exclusive or'
write(io,'(a)')'   image_index (3)       [INTRINSIC] Cosubscript to image index conversion'
write(io,'(a)')'   index (3)             [INTRINSIC:CHARACTER] Position of a substring within a string'
write(io,'(a)')'   int (3)               [INTRINSIC:NUMERIC] Convert to integer type'
write(io,'(a)')'   intrinsics (1)        [FUNIX] output text versions of Fortran intrinsic man(1) pages'
write(io,'(a)')'   intrinsics (7)        [FORTRAN]intrinsic man(1) pages'
write(io,'(a)')'   intrinsics_project (7)  [FORTRAN] intrinsic man(1) pages'
write(io,'(a)')'   ior (3)               [INTRINSIC:BIT MANIPULATION] Bitwise logical inclusive or'
write(io,'(a)')'   iparity (3)           [INTRINSIC:BIT MANIPULATION] Bitwise exclusive or of array elements'
write(io,'(a)')'   is_contiguous (3)     [INTRINSIC:ARRAY INQUIRY] test if object is contiguous'
write(io,'(a)')'   is_iostat_end (3)     [INTRINSIC] True if and only if a value indicates an end-of-file condition.'
write(io,'(a)')'   is_iostat_eor (3)     [INTRINSIC] True if and only if a value indicates an end-of-record condition.'
write(io,'(a)')'   ishft (3)             [INTRINSIC:BIT MANIPULATION] Shift bits'
write(io,'(a)')'   ishftc (3)            [INTRINSIC:BIT MANIPULATION] Shift bits circularly'
write(io,'(a)')'   kind (3)              [INTRINSIC] Kind of an entity'
write(io,'(a)')'   lbound (3)            [INTRINSIC:ARRAY INQUIRY] Lower dimension bounds of an array'
write(io,'(a)')'   lcobound (3)          [INTRINSIC] Lower codimension bounds of an array'
write(io,'(a)')'   leadz (3)             [INTRINSIC:BIT INQUIRY] Number of leading zero bits of an integer'
write(io,'(a)')'   len (3)               [INTRINSIC:CHARACTER] Length of a character entity'
write(io,'(a)')'   len_trim (3)          [INTRINSIC:CHARACTER] Length of a character entity without trailing blank characters'
write(io,'(a)')'   lge (3)               [INTRINSIC:CHARACTER] Lexical greater than or equal'
write(io,'(a)')'   lgt (3)               [INTRINSIC:CHARACTER] Lexical greater than'
write(io,'(a)')'   lle (3)               [INTRINSIC:CHARACTER] Lexical less than or equal'
write(io,'(a)')'   llt (3)               [INTRINSIC:CHARACTER] Lexical less than'
write(io,'(a)')'   log (3)               [INTRINSIC:MATHEMATICS] Logarithm function'
write(io,'(a)')'   log10 (3)             [INTRINSIC:MATHEMATICS] Base 10 logarithm function'
write(io,'(a)')'   log_gamma (3)         [INTRINSIC:MATHEMATICS] Logarithm of the Gamma function'
write(io,'(a)')'   logical (3)           [INTRINSIC:BIT MANIPULATION] Bitwise logical and'
write(io,'(a)')'   maskl (3)             [INTRINSIC] Left justified mask'
write(io,'(a)')'   maskr (3)             [INTRINSIC] Right justified mask'
write(io,'(a)')'   matmul (3)            [INTRINSIC:TRANSFORMATIONAL FUNCTION] matrix multiplication'
write(io,'(a)')'   max (3)               [INTRINSIC:NUMERIC] Maximum value of an argument list'
write(io,'(a)')'   maxexponent (3)       [INTRINSIC] Maximum exponent of a real kind'
write(io,'(a)')'   maxloc (3)            [INTRINSIC:TRANSFORMATIONAL FUNCTION] Location of the maximum value within an array'
write(io,'(a)')'   maxval (3)            [INTRINSIC:TRANSFORMATIONAL FUNCTION] determines the maximum value in an array or row'
write(io,'(a)')'   merge (3)             [INTRINSIC:ARRAY CONSTRUCTION] Merge variables'
write(io,'(a)')'   merge_bits (3)        [INTRINSIC:BIT MANIPULATION] Merge of bits under mask'
write(io,'(a)')'   min (3)               [INTRINSIC:NUMERIC] Minimum value of an argument list'
write(io,'(a)')'   minexponent (3)       [INTRINSIC] Minimum exponent of a real kind'
write(io,'(a)')'   minloc (3)            [INTRINSIC:TRANSFORMATIONAL FUNCTION] Location of the minimum value within an array'
write(io,'(a)')'   minval (3)            [INTRINSIC:TRANSFORMATIONAL FUNCTION] Minimum value of an array'
write(io,'(a)')'   mod (3)               [INTRINSIC:NUMERIC] Remainder function'
write(io,'(a)')'   modulo (3)            [INTRINSIC:NUMERIC] Modulo function'
write(io,'(a)')'   move_alloc (3)        [INTRINSIC] Move allocation from one object to another'
write(io,'(a)')'   mvbits (3)            [INTRINSIC:BIT MANIPULATION] Move bits from one integer to another'
write(io,'(a)')'   nearest (3)           [INTRINSIC:MODEL_COMPONENTS] Nearest representable number'
write(io,'(a)')'   new_line (3)          [INTRINSIC] New line character'
write(io,'(a)')'   nint (3)              [INTRINSIC:NUMERIC] Nearest whole number'
write(io,'(a)')'   norm2 (3)             [INTRINSIC:MATHEMATICS] Euclidean vector norm'
write(io,'(a)')'   not (3)               [INTRINSIC:BIT MANIPULATION] Logical negation'
write(io,'(a)')'   null (3)              [INTRINSIC:TRANSFORMATIONAL FUNCTION] Function that returns an disassociated pointer'
write(io,'(a)')'   num_images (3)        [INTRINSIC] Number of images'
write(io,'(a)')'   pack (3)              [INTRINSIC:ARRAY CONSTRUCTION] Pack an array into an array of rank one'
write(io,'(a)')'   parity (3)            [INTRINSIC:TRANSFORMATIONAL FUNCTION] Reduction with exclusive OR()'
write(io,'(a)')'   popcnt (3)            [INTRINSIC:BIT INQUIRY] Number of bits set'
write(io,'(a)')'   poppar (3)            [INTRINSIC:BIT INQUIRY] Parity of the number of bits set'
write(io,'(a)')'   precision (3)         [INTRINSIC] Decimal precision of a real kind'
write(io,'(a)')'   present (3)           [INTRINSIC] Determine whether an optional dummy argument is specified'
write(io,'(a)')'   product (3)           [INTRINSIC:TRANSFORMATIONAL FUNCTION] Product of array elements'
write(io,'(a)')'   radix (3)             [INTRINSIC] Base of a model number'
write(io,'(a)')'   random_number (3)     [INTRINSIC] Pseudo-random number'
write(io,'(a)')'   random_seed (3)       [INTRINSIC] Initialize a pseudo-random number sequence'
write(io,'(a)')'   range (3)             [INTRINSIC] Decimal exponent range of a real kind'
write(io,'(a)')'   rank (3)              [INTRINSIC:ARRAY INQUIRY] Rank of a data object'
write(io,'(a)')'   real (3)              [INTRINSIC:NUMERIC] Convert to real type'
write(io,'(a)')'   repeat (3)            [INTRINSIC:CHARACTER] Repeated string concatenation'
write(io,'(a)')'   reshape (3)           [INTRINSIC:ARRAY RESHAPE] Function to reshape an array'
write(io,'(a)')'   rrspacing (3)         [INTRINSIC:MODEL_COMPONENTS] Reciprocal of the relative spacing'
write(io,'(a)')'   same_type_as (3)      [INTRINSIC] Query dynamic types for equality'
write(io,'(a)')'   scale (3)             [INTRINSIC:MODEL_COMPONENTS] Scale a real value'
write(io,'(a)')'   scan (3)              [INTRINSIC:CHARACTER] Scan a string for the presence of a set of characters'
write(io,'(a)')'   selected_char_kind (3)  [INTRINSIC] Choose character kind'
write(io,'(a)')'   selected_int_kind (3)  [INTRINSIC] Choose integer kind'
write(io,'(a)')'   selected_real_kind (3)  [INTRINSIC] Choose real kind'
write(io,'(a)')'   set_exponent (3)      [INTRINSIC:MODEL_COMPONENTS] Set the exponent of the model'
write(io,'(a)')'   shape (3)             [INTRINSIC:ARRAY INQUIRY] Determine the shape of an array'
write(io,'(a)')'   shifta (3)            [INTRINSIC:BIT MANIPULATION] shift bits right with fill'
write(io,'(a)')'   shiftl (3)            [INTRINSIC:BIT MANIPULATION] shift bits left'
write(io,'(a)')'   shiftr (3)            [INTRINSIC:BIT MANIPULATION] shift bits right'
write(io,'(a)')'   sign (3)              [INTRINSIC:NUMERIC] Sign copying function'
write(io,'(a)')'   sin (3)               [INTRINSIC:TRIGONOMETRIC] Sine function'
write(io,'(a)')'   sinh (3)              [INTRINSIC:TRIGONOMETRIC] Hyperbolic sine function'
write(io,'(a)')'   size (3)              [INTRINSIC:ARRAY INQUIRY] Determine the size of an array'
write(io,'(a)')'   sngl (3)              [INTRINSIC] Convert double precision real to default real'
write(io,'(a)')'   spacing (3)           [INTRINSIC:MODEL_COMPONENTS] Smallest distance between two numbers of a given type'
write(io,'(a)')'   spread (3)            [INTRINSIC:ARRAY CONSTRUCTION] Add a dimension to an array'
write(io,'(a)')'   sqrt (3)              [INTRINSIC:MATHEMATICS] Square-root function'
write(io,'(a)')'   storage_size (3)      [INTRINSIC:BIT INQUIRY] Storage size in bits'
write(io,'(a)')'   sum (3)               [INTRINSIC] sum the elements of an array'
write(io,'(a)')'   system_clock (3)      [INTRINSIC:SYSTEM ENVIRONMENT] Time function'
write(io,'(a)')'   tan (3)               [INTRINSIC:TRIGONOMETRIC] Tangent function'
write(io,'(a)')'   tanh (3)              [INTRINSIC:TRIGONOMETRIC] Hyperbolic tangent function'
write(io,'(a)')'   this_image (3)        [INTRINSIC] Cosubscript index of this image'
write(io,'(a)')'   tiny (3)              [INTRINSIC] Smallest positive number of a real kind'
write(io,'(a)')'   trailz (3)            [INTRINSIC:BIT INQUIRY] Number of trailing zero bits of an integer'
write(io,'(a)')'   transfer (3)          [INTRINSIC:BIT MANIPULATION] Transfer bit patterns'
write(io,'(a)')'   transpose (3)         [INTRINSIC:ARRAY MANIPULATION] Transpose an array of rank two'
write(io,'(a)')'   trim (3)              [INTRINSIC:CHARACTER] Remove trailing blank characters of a string'
write(io,'(a)')'   ubound (3)            [INTRINSIC:ARRAY INQUIRY] Upper dimension bounds of an array'
write(io,'(a)')'   ucobound (3)          [INTRINSIC] Upper codimension bounds of an array'
write(io,'(a)')'   unpack (3)            [INTRINSIC:ARRAY CONSTRUCTION] Store the elements of a vector in an array of higher rank'
write(io,'(a)')'   verify (3)            [INTRINSIC:CHARACTER] Scan a string for the absence of a set of characters'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'  Sample'
write(io,'(a)')''
write(io,'(a)')'   program demo_fortran'
write(io,'(a)')'   implicit none'
write(io,'(a)')'   character(len=*),parameter :: ident="@(#)example(1f): example program"'
write(io,'(a)')'   integer :: bb'
write(io,'(a)')'   integer :: i_myloop'
write(io,'(a)')'      call sub1(10,bb)'
write(io,'(a)')'      write(*,*)''BB='',bb'
write(io,'(a)')'   !-----------------------------------------------------------------------'
write(io,'(a)')'   MYLOOP: do I_MYLOOP=1,10  ! DO loop'
write(io,'(a)')'      cycle MYLOOP           ! start next pass of loop'
write(io,'(a)')'      exit  MYLOOP           ! go to next statement after corresponding ENDDO'
write(io,'(a)')'   enddo MYLOOP'
write(io,'(a)')'   !-----------------------------------------------------------------------'
write(io,'(a)')'   block'
write(io,'(a)')'   character(LEN=1) :: c'
write(io,'(a)')'   select case (c)'
write(io,'(a)')'   case (''a'' : ''j'')'
write(io,'(a)')'      write(*,*)  ''One of the first ten letters'''
write(io,'(a)')'   case (''l'' : ''p'', ''u'' : ''y'')'
write(io,'(a)')'      write(*,*)  ''One of l, m, n, o, p, u, v, w, x, y'''
write(io,'(a)')'   case (''z'', ''q'' : ''t'')'
write(io,'(a)')'      WRITE(*,*)  ''One of z, q, r, s, t'''
write(io,'(a)')'   case default'
write(io,'(a)')'      write(*,*)  ''Other characters, which may not be letters'''
write(io,'(a)')'   endselect'
write(io,'(a)')'   endblock'
write(io,'(a)')'   !-----------------------------------------------------------------------'
write(io,'(a)')'   CHAR: block'
write(io,'(a)')'   ! ALLOCATABLE CHARACTER ARRAY'
write(io,'(a)')'   character(len=80),allocatable :: help_text(:)'
write(io,'(a)')'   integer                       :: i'
write(io,'(a)')'   help_text=[ &'
write(io,'(a)')'   &''12345678901234567890123456789012345678901234567890123456789012345678901234567890'',&'
write(io,'(a)')'   &''This is example help text for the example program                               '',&'
write(io,'(a)')'   &''The example program uses kracken(3f) for command line parsing.                  '',&'
write(io,'(a)')'   &''                                                                                '',&'
write(io,'(a)')'   &''                                                                                '',&'
write(io,'(a)')'   &''                                                                                '',&'
write(io,'(a)')'   &''                                                                                '']'
write(io,'(a)')'   WRITE(*,''(a)'')(help_text(i),i=1,size(help_text))'
write(io,'(a)')'   endblock CHAR'
write(io,'(a)')'   !-----------------------------------------------------------------------'
write(io,'(a)')''
write(io,'(a)')'     contains'
write(io,'(a)')''
write(io,'(a)')'     subroutine sub1(a,b,c)'
write(io,'(a)')'     integer,intent(in)                                 :: a'
write(io,'(a)')'     integer,intent(out)                                :: b'
write(io,'(a)')'     character(len=:),intent(out),allocatable,optional  :: c'
write(io,'(a)')'        b=2*a'
write(io,'(a)')'        if(present(c))then'
write(io,'(a)')'           c=''Hello World'''
write(io,'(a)')'        endif'
write(io,'(a)')'     end subroutine sub1'
write(io,'(a)')''
write(io,'(a)')'     integer function signum (n)'
write(io,'(a)')'     !An integer signum function'
write(io,'(a)')'     integer,intent(in) :: n'
write(io,'(a)')'     select case (n)'
write(io,'(a)')'     case  (:-1)  ;  signum  =  -1'
write(io,'(a)')'     case  (0)    ;  signum  =   0'
write(io,'(a)')'     case  (1:)   ;  signum  =   1'
write(io,'(a)')'     end select'
write(io,'(a)')'     end function signum'
write(io,'(a)')''
write(io,'(a)')'   end program demo_fortran'
write(io,'(a)')'NAME'
write(io,'(a)')'iso_c_binding(7f) - [FORTRAN ]a standard intrinsic module which defines named constants, types, and procedures for'
write(io,'(a)')''
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')''
write(io,'(a)')'   Interoperability with C'
write(io,'(a)')'      1 General'
write(io,'(a)')'      2 The ISO C BINDING intrinsic module'
write(io,'(a)')'         15.2.1 Summary of contents'
write(io,'(a)')'         15.2.2 Named constants and derived types in the module'
write(io,'(a)')'         15.2.3 Procedures in the module'
write(io,'(a)')'      3 Interoperability between Fortran and C entities'
write(io,'(a)')'         15.3.1 General'
write(io,'(a)')'         15.3.2 Interoperability of intrinsic types'
write(io,'(a)')'         15.3.3 Interoperability with C pointer types'
write(io,'(a)')'         15.3.4 Interoperability of derived types and C struct types'
write(io,'(a)')'         15.3.5 Interoperability of scalar variables'
write(io,'(a)')'         15.3.6 Interoperability of array variables'
write(io,'(a)')'         15.3.7 Interoperability of procedures and procedure interfaces'
write(io,'(a)')'      4 Interoperation with C global variables'
write(io,'(a)')'         15.4.1 General'
write(io,'(a)')'         15.4.2 Binding labels for common blocks and variables'
write(io,'(a)')'      5 Interoperation with C functions'
write(io,'(a)')'         15.5.1 Definition and reference of interoperable procedures'
write(io,'(a)')'         15.5.2 Binding labels for procedures'
write(io,'(a)')'         15.5.3 Exceptions and IEEE arithmetic procedures'
write(io,'(a)')''
write(io,'(a)')'STANDARD'
write(io,'(a)')''
write(io,'(a)')'[[Fortran 2003]] and later'
write(io,'(a)')''
write(io,'(a)')'INTRINSIC PROCEDURES'
write(io,'(a)')''
write(io,'(a)')'   The following intrinsic procedures are provided by the module; their'
write(io,'(a)')'   definition can be found in man(1) pages:'
write(io,'(a)')''
write(io,'(a)')'   * c_associated'
write(io,'(a)')'   * c_f_pointer'
write(io,'(a)')'   * c_f_procpointer'
write(io,'(a)')'   * c_funloc'
write(io,'(a)')'   * c_loc'
write(io,'(a)')'   * c_sizeof'
write(io,'(a)')''
write(io,'(a)')'NAMED CONSTANTS'
write(io,'(a)')''
write(io,'(a)')'iso_c_binding(7f) module also provides the following named constants of'
write(io,'(a)')'type default integer, which can be used as `kind` type parameters.'
write(io,'(a)')''
write(io,'(a)')'   #-------------#-------------------------#-----------------------#----------#'
write(io,'(a)')'   | Fortran Type| Named constant          | C type                | Note     |'
write(io,'(a)')'   |-------------|-------------------------|-----------------------|----------|'
write(io,'(a)')'   |  integer    |  c_int                  |  int                  |          |'
write(io,'(a)')'   |  integer    |  c_short                |  short int            |          |'
write(io,'(a)')'   |  integer    |  c_long                 |  long int             |          |'
write(io,'(a)')'   |  integer    |  c_long_long            |  long long int        |          |'
write(io,'(a)')'   |  integer    |  c_signed_char          |  signed char/         |          |'
write(io,'(a)')'   |             |                         |  unsigned  char       |          |'
write(io,'(a)')'   |  integer    |  c_size_t               |  size_t               |          |'
write(io,'(a)')'   |  integer    |  c_int8_t               |  int8_t               |          |'
write(io,'(a)')'   |  integer    |  c_int16_t              |  int16_t              |          |'
write(io,'(a)')'   |  integer    |  c_int32_t              |  int32_t              |          |'
write(io,'(a)')'   |  integer    |  c_int64_t              |  int64_t              |          |'
write(io,'(a)')'   |  integer    |  c_int_least8_t         |  int_least8_t         |          |'
write(io,'(a)')'   |  integer    |  c_int_least16_t        |  int_least16_t        |          |'
write(io,'(a)')'   |  integer    |  c_int_least32_t        |  int_least32_t        |          |'
write(io,'(a)')'   |  integer    |  c_int_least64_t        |  int_least64_t        |          |'
write(io,'(a)')'   |  integer    |  c_int_fast8_t          |  int_fast8_t          |          |'
write(io,'(a)')'   |  integer    |  c_int_fast16_t         |  int_fast16_t         |          |'
write(io,'(a)')'   |  integer    |  c_int_fast32_t         |  int_fast32_t         |          |'
write(io,'(a)')'   |  integer    |  c_int_fast64_t         |  int_fast64_t         |          |'
write(io,'(a)')'   |  integer    |  c_intmax_t             |  intmax_t             |          |'
write(io,'(a)')'   |  integer    |  c_intptr_t             |  intptr_t             |          |'
write(io,'(a)')'   |  integer    |  c_ptrdiff_t            |  intptr_t             | TS 29113 |'
write(io,'(a)')'   |  real       |  c_float                |  float                |          |'
write(io,'(a)')'   |  real       |  c_double               |  double               |          |'
write(io,'(a)')'   |  real       |  c_long_double          |  long double          |          |'
write(io,'(a)')'   |  complex    |  c_float_complex        |  float _Complex       |          |'
write(io,'(a)')'   |  complex    |  c_double_complex       |  double _Complex      |          |'
write(io,'(a)')'   |  complex    |  c_long_double_complex  |  long double _Complex |          |'
write(io,'(a)')'   |  logical    |  c_bool                 |  _Bool                |          |'
write(io,'(a)')'   |  character  |  c_char                 |  char                 |          |'
write(io,'(a)')'   #-------------#-------------------------#-----------------------#----------#'
write(io,'(a)')''
write(io,'(a)')'   -1 if the companion processor defines the corresponding C type'
write(io,'(a)')'   and there is no interoperating Fortran processor kind or -2 if the'
write(io,'(a)')'   C processor does not define the corresponding C type.'
write(io,'(a)')''
write(io,'(a)')'Additionally, the following parameters of type `character(kind=c_char)`'
write(io,'(a)')'are defined.'
write(io,'(a)')''
write(io,'(a)')'   #---------------------#-----------------#--------#'
write(io,'(a)')'   | Name                | C definition    | Value  |'
write(io,'(a)')'   |---------------------|-----------------|--------|'
write(io,'(a)')'   | `c_null_char`       | null character  | `''\0''` |'
write(io,'(a)')'   | `c_alert`           | alert           | `''\a''` |'
write(io,'(a)')'   | `c_backspace`       | backspace       | `''\b''` |'
write(io,'(a)')'   | `c_form_feed`       | form feed       | `''\f''` |'
write(io,'(a)')'   | `c_new_line`        | new line        | `''\n''` |'
write(io,'(a)')'   | `c_carriage_return` | carriage return | `''\r''` |'
write(io,'(a)')'   | `c_horizontal_tab`  | horizontal tab  | `''\t''` |'
write(io,'(a)')'   | `c_vertical_tab`    | vertical tab    | `''\v''` |'
write(io,'(a)')'   #---------------------#-----------------#--------#'
write(io,'(a)')''
write(io,'(a)')'Moreover, the following two named constants are defined:'
write(io,'(a)')''
write(io,'(a)')'   #---------------#----------#'
write(io,'(a)')'   | Name          | Type     |'
write(io,'(a)')'   |---------------|----------|'
write(io,'(a)')'   | c_null_ptr    | c_ptr    |'
write(io,'(a)')'   | c_null_funptr | c_funptr |'
write(io,'(a)')'   #---------------#----------#'
write(io,'(a)')''
write(io,'(a)')'Both are equivalent to the value `NULL` in C.'
write(io,'(a)')''
write(io,'(a)')'INTEROPERABILITY WITH C'
write(io,'(a)')''
write(io,'(a)')'GENERAL'
write(io,'(a)')' 15.1'
write(io,'(a)')''
write(io,'(a)')'  Fortran provides a means of referencing procedures that are defined by'
write(io,'(a)')'  means of the C programming language or procedures that can be described'
write(io,'(a)')'  by C prototypes as defined in 6.7.5.3 of the C International Standard,'
write(io,'(a)')'  even if they are not actually defined by means of C. Conversely,'
write(io,'(a)')'  there is a means of specifying that a procedure defined by a Fortran'
write(io,'(a)')'  subprogram can be referenced from a function defined by means of'
write(io,'(a)')'  C. In addition, there is a means of declaring global variables that'
write(io,'(a)')'  are associated with C variables whose names have external linkage as'
write(io,'(a)')'  defined in 6.2.2 of the C International Standard.'
write(io,'(a)')''
write(io,'(a)')'  The ISO C BINDING module provides access to named constants that'
write(io,'(a)')'  represent kind type parameters of data representations compatible with'
write(io,'(a)')'  C types. Fortran also provides facilities for defining derived types'
write(io,'(a)')'  (4.5) and enumerations (4.6) that correspond to C types.'
write(io,'(a)')''
write(io,'(a)')'  To avoid potential name conflicts with program entities, it'
write(io,'(a)')'  is recommended that a program use the ONLY option in any USE'
write(io,'(a)')'  statement that references the ISO C BINDING intrinsic module.'
write(io,'(a)')''
write(io,'(a)')'THE ISO_C_BINDING INTRINSIC MODULE'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')' NAMED CONSTANTS AND DERIVED TYPES IN THE MODULE'
write(io,'(a)')'  15.2.2'
write(io,'(a)')''
write(io,'(a)')'     The values of C_FLOAT, C_DOUBLE, and C_LONG_DOUBLE shall each be a'
write(io,'(a)')'     valid value for a real kind type parameter on the processor or shall'
write(io,'(a)')'     be -1 if the companion processor''s type does not have a precision'
write(io,'(a)')'     equal to the precision of any of the Fortran processor''s real'
write(io,'(a)')'     kinds, -2 if the companion processor''s type does not have a range'
write(io,'(a)')'     equal to the range of any of the Fortran processor''s real kinds,'
write(io,'(a)')'     -3 if the companion processor''s type has neither the precision'
write(io,'(a)')'     nor range of any of the Fortran processor''s real kinds, and equal'
write(io,'(a)')'     to -4 if there is no interoperating Fortran processor kind for'
write(io,'(a)')'     other reasons.'
write(io,'(a)')''
write(io,'(a)')'     The values of C_FLOAT_COMPLEX, C_DOUBLE_COMPLEX,'
write(io,'(a)')'     and C_LONG_DOUBLE_COMPLEX shall be the same as those of C_FLOAT,'
write(io,'(a)')'     C_DOUBLE, and C_LONG_DOUBLE, respectively.'
write(io,'(a)')''
write(io,'(a)')'     The value of C_BOOL shall be a valid value for a logical kind'
write(io,'(a)')'     parameter on the processor or shall be -1.'
write(io,'(a)')''
write(io,'(a)')'     The value of C_CHAR shall be a valid value for a character kind type'
write(io,'(a)')'     parameter on the processor or shall be -1. The value of C_CHAR is'
write(io,'(a)')'     known as the C character kind.'
write(io,'(a)')''
write(io,'(a)')'     The entity C_NULL_PTR shall be a named constant of type C_PTR. The'
write(io,'(a)')'     value of C_NULL_PTR shall be the same as the value NULL in C. The'
write(io,'(a)')'     entity C_NULL_FUNPTR shall be a named constant of type C_FUNPTR.'
write(io,'(a)')'     The value of C_NULL_FUNPTR shall be that of a null pointer to a'
write(io,'(a)')'     function in C.'
write(io,'(a)')''
write(io,'(a)')'           NOTE 15.2'
write(io,'(a)')'           The value of NEW_LINE(C_NEW_LINE) is C_NEW_LINE (13.7.120).'
write(io,'(a)')''
write(io,'(a)')'PROCEDURES IN THE MODULE'
write(io,'(a)')' 15.2.3'
write(io,'(a)')''
write(io,'(a)')'    In the detailed descriptions below, procedure names are generic and'
write(io,'(a)')'    not specific.'
write(io,'(a)')''
write(io,'(a)')'  C_ASSOCIATED (C_PTR_1 [, C_PTR_2])'
write(io,'(a)')'  15.2.3.2'
write(io,'(a)')''
write(io,'(a)')'   Description. True if and only if C_PTR_1 is associated with an entity and C_PTR_2 is absent, or if C_PTR_1'
write(io,'(a)')'   and C_PTR_2 are associated with the same entity.'
write(io,'(a)')''
write(io,'(a)')'   Class. Inquiry function.'
write(io,'(a)')''
write(io,'(a)')'   Arguments.'
write(io,'(a)')''
write(io,'(a)')'   C_PTR_1    shall be a scalar of type C_PTR or C_FUNPTR.'
write(io,'(a)')'   C_PTR_2 (optional) shall be a scalar of the same type as C_PTR_1.'
write(io,'(a)')''
write(io,'(a)')'  Result Characteristics. Default logical scalar.'
write(io,'(a)')''
write(io,'(a)')'  Result Value.'
write(io,'(a)')''
write(io,'(a)')'  Case (i):      If C_PTR_2 is absent, the result is false if C_PTR_1 is a C null pointer and true otherwise.'
write(io,'(a)')'  Case (ii):     If C_PTR_2 is present, the result is false if C_PTR_1 is a C null pointer. If C_PTR_1 is not a C n'
write(io,'(a)')'                 pointer, the result is true if C_PTR_1 compares equal to C_PTR_2 in the sense of 6.3.2.3 and 6.5.9'
write(io,'(a)')'                 of the C International Standard, and false otherwise.'
write(io,'(a)')''
write(io,'(a)')'  NOTE 15.3'
write(io,'(a)')''
write(io,'(a)')'   The following example illustrates the use of C LOC and C ASSOCIATED.'
write(io,'(a)')''
write(io,'(a)')'       USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_PTR, C_FLOAT, C_ASSOCIATED, C_LOC'
write(io,'(a)')'       INTERFACE'
write(io,'(a)')'         SUBROUTINE FOO(GAMMA) BIND(C)'
write(io,'(a)')'           IMPORT C_PTR'
write(io,'(a)')'           TYPE(C_PTR), VALUE :: GAMMA'
write(io,'(a)')'         END SUBROUTINE FOO'
write(io,'(a)')'       END INTERFACE'
write(io,'(a)')'       REAL(C_FLOAT), TARGET, DIMENSION(100) :: ALPHA'
write(io,'(a)')'       TYPE(C_PTR) :: BETA'
write(io,'(a)')'       ...'
write(io,'(a)')'       IF (.NOT. C_ASSOCIATED(BETA)) THEN'
write(io,'(a)')'         BETA = C_LOC(ALPHA)'
write(io,'(a)')'       ENDIF'
write(io,'(a)')'       CALL FOO(BETA)'
write(io,'(a)')''
write(io,'(a)')'  C_F_POINTER (CPTR, FPTR [, SHAPE])'
write(io,'(a)')'   15.2.3.3'
write(io,'(a)')''
write(io,'(a)')'    Description. Associate a data pointer with the target of a C pointer and specify its shape.'
write(io,'(a)')''
write(io,'(a)')'    Class. Subroutine.'
write(io,'(a)')''
write(io,'(a)')'  Arguments.'
write(io,'(a)')'  CPTR    shall be a scalar of type C_PTR. It is an INTENT(IN) argument. Its value shall be'
write(io,'(a)')'          the C address of an interoperable data entity, or'
write(io,'(a)')'          the result of a reference to C_LOC with a noninteroperable argument.'
write(io,'(a)')'          The value of CPTR shall not be the C address of a Fortran variable that does not have the TARGET'
write(io,'(a)')'          attribute.'
write(io,'(a)')'  FPTR    shall be a pointer, and shall not be a coindexed object. It is an INTENT (OUT) argument.'
write(io,'(a)')'          If the value of CPTR is the C address of an interoperable data entity, FPTR shall be a data pointer'
write(io,'(a)')'          with type and type parameters interoperable with the type of the entity. In this case, FPTR becomes'
write(io,'(a)')'          pointer associated with the target of CPTR. If FPTR is an array, its shape is specified by SHAPE'
write(io,'(a)')'          and each lower bound is 1.'
write(io,'(a)')'          If the value of CPTR is the result of a reference to C LOC with a noninteroperable argument X,'
write(io,'(a)')'          FPTR shall be a nonpolymorphic scalar pointer with the same type and type parameters as X. In'
write(io,'(a)')'          this case, X or its target if it is a pointer shall not have been deallocated or have become undefined'
write(io,'(a)')'          due to execution of a RETURN or END statement since the reference. FPTR becomes pointer'
write(io,'(a)')'          associated with X or its target.'
write(io,'(a)')'  SHAPE   (optional) shall be of type integer and rank one. It is an INTENT (IN) argument. SHAPE shall be'
write(io,'(a)')'          present if and only if FPTR is an array; its size shall be equal to the rank of FPTR.'
write(io,'(a)')''
write(io,'(a)')'C_F_PROCPOINTER (CPTR, FPTR)'
write(io,'(a)')' 15.2.3.4'
write(io,'(a)')''
write(io,'(a)')'  Description. Associate a procedure pointer with the target of a C function pointer.'
write(io,'(a)')''
write(io,'(a)')'  Class. Subroutine.'
write(io,'(a)')''
write(io,'(a)')'  Arguments.'
write(io,'(a)')''
write(io,'(a)')'  CPTR          shall be a scalar of type C_FUNPTR. It is an INTENT (IN) argument. Its value shall be the C'
write(io,'(a)')'                address of a procedure that is interoperable.'
write(io,'(a)')'  FPTR          shall be a procedure pointer, and shall not be a component of a coindexed object. It is an INTENT'
write(io,'(a)')'                (OUT) argument. The interface for FPTR shall be interoperable with the prototype that describes'
write(io,'(a)')'                the target of CPTR. FPTR becomes pointer associated with the target of CPTR.'
write(io,'(a)')''
write(io,'(a)')'    NOTE 15.4'
write(io,'(a)')''
write(io,'(a)')'        The term "target" in the descriptions of C F POINTER and C F PROCPOINTER denotes the entity'
write(io,'(a)')'        referenced by a C pointer, as described in 6.2.5 of the C International Standard.'
write(io,'(a)')''
write(io,'(a)')' C_FUNLOC (X)'
write(io,'(a)')' 15.2.3.5'
write(io,'(a)')''
write(io,'(a)')'  Description. C address of the argument.'
write(io,'(a)')''
write(io,'(a)')'  Class. Inquiry function.'
write(io,'(a)')''
write(io,'(a)')'  Argument. X shall either be a procedure that is interoperable, or a procedure pointer associated with an'
write(io,'(a)')'  interoperable procedure. It shall not be a coindexed object.'
write(io,'(a)')''
write(io,'(a)')'  Result Characteristics. Scalar of type C FUNPTR.'
write(io,'(a)')''
write(io,'(a)')'  Result Value. The result value is described using the result name FPTR. The result is determined as if C -'
write(io,'(a)')'  FUNPTR were a derived type containing an implicit-interface procedure pointer component PX and the pointer'
write(io,'(a)')'  assignment FPTR%PX => X were executed.'
write(io,'(a)')''
write(io,'(a)')'  The result is a value that can be used as an actual FPTR argument in a call to C F PROCPOINTER where'
write(io,'(a)')'  FPTR has attributes that would allow the pointer assignment FPTR => X. Such a call to C F PROCPOINTER'
write(io,'(a)')'  shall have the effect of the pointer assignment FPTR => X.'
write(io,'(a)')''
write(io,'(a)')'  15.2.3.6   C LOC (X)'
write(io,'(a)')''
write(io,'(a)')'  Description. C address of the argument.'
write(io,'(a)')''
write(io,'(a)')'  Class. Inquiry function.'
write(io,'(a)')''
write(io,'(a)')'  Argument. X shall have either the POINTER or TARGET attribute. It shall not be a coindexed object. It'
write(io,'(a)')'  shall either be a contiguous variable with interoperable type and type parameters, or be a scalar, nonpolymorphic'
write(io,'(a)')'  variable with no length type parameters. If it is allocatable, it shall be allocated. If it is a pointer, it shal'
write(io,'(a)')'  associated. If it is an array, it shall have nonzero size.'
write(io,'(a)')''
write(io,'(a)')'  Result Characteristics. Scalar of type C PTR.'
write(io,'(a)')''
write(io,'(a)')'  Result Value. The result value is described using the result name CPTR.'
write(io,'(a)')''
write(io,'(a)')'  If X is a scalar data entity, the result is determined as if C PTR were a derived type containing a scalar pointe'
write(io,'(a)')'  component PX of the type and type parameters of X and the pointer assignment CPTR%PX => X were executed.'
write(io,'(a)')''
write(io,'(a)')'  If X is an array data entity, the result is determined as if C PTR were a derived type containing a scalar pointe'
write(io,'(a)')'  component PX of the type and type parameters of X and the pointer assignment of CPTR%PX to the first'
write(io,'(a)')'  element of X were executed.'
write(io,'(a)')''
write(io,'(a)')'  If X is a data entity that is interoperable or has interoperable type and type parameters, the result is the valu'
write(io,'(a)')'  that the C processor returns as the result of applying the unary "&" operator (as defined in the C International'
write(io,'(a)')'  Standard, 6.5.3.2) to the target of CPTR%PX.'
write(io,'(a)')''
write(io,'(a)')'  The result is a value that can be used as an actual CPTR argument in a call to C F POINTER where FPTR'
write(io,'(a)')'  has attributes that would allow the pointer assignment FPTR => X. Such a call to C F POINTER shall have'
write(io,'(a)')'  the effect of the pointer assignment FPTR => X.'
write(io,'(a)')''
write(io,'(a)')'       NOTE 15.5'
write(io,'(a)')'       Where the actual argument is of noninteroperable type or type parameters, the result of C LOC provides an'
write(io,'(a)')'       opaque "handle" for it. In an actual implementation, this handle might be the C address of the argument;'
write(io,'(a)')'       however, portable C functions should treat it as a void (generic) C pointer that cannot be dereferenced'
write(io,'(a)')'       (6.5.3.2 in the C International Standard).'
write(io,'(a)')''
write(io,'(a)')'  15.2.3.7   C SIZEOF (X)'
write(io,'(a)')''
write(io,'(a)')'  Description. Size of X in bytes.'
write(io,'(a)')''
write(io,'(a)')'  Class. Inquiry function.'
write(io,'(a)')''
write(io,'(a)')'  Argument. X shall be an interoperable data entity that is not an assumed-size array.'
write(io,'(a)')''
write(io,'(a)')'  Result Characteristics. Scalar integer of kind C SIZE T (15.3.2).'
write(io,'(a)')''
write(io,'(a)')'  Result Value. If X is scalar, the result value is the value that the companion processor returns as the result of'
write(io,'(a)')'  applying the sizeof operator (C International Standard, subclause 6.5.3.4) to an object of a type that interopera'
write(io,'(a)')'  with the type and type parameters of X.'
write(io,'(a)')''
write(io,'(a)')'  If X is an array, the result value is the value that the companion processor returns as the result of applying th'
write(io,'(a)')'  sizeof operator to an object of a type that interoperates with the type and type parameters of X, multiplied by'
write(io,'(a)')'  the number of elements in X.'
write(io,'(a)')''
write(io,'(a)')'  15.3       Interoperability between Fortran and C entities'
write(io,'(a)')''
write(io,'(a)')'  15.3.1     General'
write(io,'(a)')'  Subclause 15.3 defines the conditions under which a Fortran entity is interoperable. If a Fortran entity is inter'
write(io,'(a)')'  operable, an equivalent entity may be defined by means of C and the Fortran entity interoperates with the C'
write(io,'(a)')'  entity. There does not have to be such an interoperating C entity.'
write(io,'(a)')''
write(io,'(a)')'       NOTE 15.6'
write(io,'(a)')'       A Fortran entity can be interoperable with more than one C entity.'
write(io,'(a)')''
write(io,'(a)')'  15.3.2     Interoperability of intrinsic types'
write(io,'(a)')'  Table 15.2 shows the interoperability between Fortran intrinsic types and C types. A Fortran intrinsic type'
write(io,'(a)')'  with particular type parameter values is interoperable with a C type if the type and kind type parameter value'
write(io,'(a)')'  are listed in the table on the same row as that C type; if the type is character, interoperability also requires'
write(io,'(a)')'  that the length type parameter be omitted or be specified by an initialization expression whose value is one. A'
write(io,'(a)')'  combination of Fortran type and type parameters that is interoperable with a C type listed in the table is also'
write(io,'(a)')'  interoperable with any unqualified C type that is compatible with the listed C type.'
write(io,'(a)')''
write(io,'(a)')'  The second column of the table refers to the named constants made accessible by the ISO C BINDING intrinsic'
write(io,'(a)')'  module. If the value of any of these named constants is negative, there is no combination of Fortran type and'
write(io,'(a)')'  type parameters interoperable with the C type shown in that row.'
write(io,'(a)')''
write(io,'(a)')'  A combination of intrinsic type and type parameters is interoperable if it is interoperable with a C type. The'
write(io,'(a)')'  C types mentioned in table 15.2 are defined in subclauses 6.2.5, 7.17, and 7.18.1 of the C International Standard'
write(io,'(a)')''
write(io,'(a)')'                         Table 15.2: Interoperability between Fortran and C types'
write(io,'(a)')'                           Named constant from the ISO C BINDING module'
write(io,'(a)')'       Fortran type                                                        C type'
write(io,'(a)')'                           (kind type parameter if value is positive)'
write(io,'(a)')'                            C_INT                                          int'
write(io,'(a)')'                            C_SHORT                                        short int'
write(io,'(a)')'                            C_LONG                                         long int'
write(io,'(a)')'                            C_LONG_LONG                                    long long int'
write(io,'(a)')'                            C_SIGNED_CHAR                                  signed char'
write(io,'(a)')'                                                                           unsigned char'
write(io,'(a)')'                            C_SIZE_T                                       size t'
write(io,'(a)')'                            C_INT8_T                                       int8 t'
write(io,'(a)')'                            C_INT16_T                                      int16 t'
write(io,'(a)')'                            C_INT32_T                                      int32 t'
write(io,'(a)')'                            C_INT64_T                                      int64 t'
write(io,'(a)')'                            C_INT_LEAST8_T                                 int least8 t'
write(io,'(a)')'                            C_INT_LEAST16_T                                int least16 t'
write(io,'(a)')'                            C_INT_LEAST32_T                                int least32 t'
write(io,'(a)')'       INTEGER              C_INT_LEAST64_T                                int least64 t'
write(io,'(a)')'                            C_INT_FAST8_T                                  int fast8 t'
write(io,'(a)')'                            C_INT_FAST16_T                                 int fast16 t'
write(io,'(a)')'                            C_INT_FAST32_T                                 int fast32 t'
write(io,'(a)')'                            C_INT_FAST64_T                                 int fast64 t'
write(io,'(a)')'                            C_INTMAX_T                                     intmax t'
write(io,'(a)')'                            C_INTPTR_T                                     intptr t'
write(io,'(a)')'                            C_FLOAT                                        float'
write(io,'(a)')'       REAL                 C_DOUBLE                                       double'
write(io,'(a)')'                            C_LONG_DOUBLE                                  long double'
write(io,'(a)')'                            C_FLOAT_COMPLEX                                float Complex'
write(io,'(a)')'       COMPLEX              C_DOUBLE_COMPLEX                               double Complex'
write(io,'(a)')'                            C_LONG_DOUBLE_COMPLEX                          long double Complex'
write(io,'(a)')'       LOGICAL              C_BOOL                                         Bool'
write(io,'(a)')'       CHARACTER            C_CHAR                                         char'
write(io,'(a)')''
write(io,'(a)')'      NOTE 15.7'
write(io,'(a)')'      For example, the type integer with a kind type parameter of C_SHORT is interoperable with the C type'
write(io,'(a)')'      short or any C type derived (via typedef) from short.'
write(io,'(a)')''
write(io,'(a)')'      NOTE 15.8'
write(io,'(a)')'      The C International Standard specifies that the representations for nonnegative signed integers are the'
write(io,'(a)')'      same as the corresponding values of unsigned integers. Because Fortran does not provide direct support for'
write(io,'(a)')'      unsigned kinds of integers, the ISO C BINDING module does not make accessible named constants for their'
write(io,'(a)')'      kind type parameter values. A user can use the signed kinds of integers to interoperate with the unsigned'
write(io,'(a)')'      types and all their qualified versions as well. This has the potentially surprising side effect that the C ty'
write(io,'(a)')'      unsigned char is interoperable with the type integer with a kind type parameter of C SIGNED CHAR.'
write(io,'(a)')''
write(io,'(a)')'  15.3.3     Interoperability with C pointer types'
write(io,'(a)')'  C PTR and C FUNPTR shall be derived types with only private components. No direct component of either of'
write(io,'(a)')'  these types is allocatable or a pointer. C PTR is interoperable with any C object pointer type. C FUNPTR is'
write(io,'(a)')'  interoperable with any C function pointer type.'
write(io,'(a)')''
write(io,'(a)')'       NOTE 15.9'
write(io,'(a)')'       This implies that a C processor is required to have the same representation method for all C object pointer'
write(io,'(a)')'       types and the same representation method for all C function pointer types if the C processor is to be'
write(io,'(a)')'       the target of interoperability of a Fortran processor. The C International Standard does not impose this'
write(io,'(a)')'       requirement.'
write(io,'(a)')''
write(io,'(a)')'       NOTE 15.10'
write(io,'(a)')'       The function C LOC can be used to return a value of type C PTR that is the C address of an allocated'
write(io,'(a)')'       allocatable variable. The function C FUNLOC can be used to return a value of type C FUNPTR that is'
write(io,'(a)')'       the C address of a procedure. For C LOC and C FUNLOC the returned value is of an interoperable type'
write(io,'(a)')'       and thus may be used in contexts where the procedure or allocatable variable is not directly allowed. For'
write(io,'(a)')'       example, it could be passed as an actual argument to a C function.'
write(io,'(a)')''
write(io,'(a)')'       Similarly, type C FUNPTR or C PTR can be used in a dummy argument or structure component and can'
write(io,'(a)')'       have a value that is the C address of a procedure or allocatable variable, even in contexts where a procedur'
write(io,'(a)')'       or allocatable variable is not directly allowed.'
write(io,'(a)')''
write(io,'(a)')'  15.3.4     Interoperability of derived types and C struct types'
write(io,'(a)')'  A Fortran derived type is interoperable if it has the BIND attribute.'
write(io,'(a)')''
write(io,'(a)')'  C1501 (R425) A derived type with the BIND attribute shall not have the SEQUENCE attribute.'
write(io,'(a)')''
write(io,'(a)')'  C1502 (R425) A derived type with the BIND attribute shall not have type parameters.'
write(io,'(a)')''
write(io,'(a)')'  C1503 (R425) A derived type with the BIND attribute shall not have the EXTENDS attribute.'
write(io,'(a)')''
write(io,'(a)')'  C1504 (R425) A derived type with the BIND attribute shall not have a type-bound-procedure-part.'
write(io,'(a)')''
write(io,'(a)')'  C1505 (R425) Each component of a derived type with the BIND attribute shall be a nonpointer, nonallocatable'
write(io,'(a)')'        data component with interoperable type and type parameters.'
write(io,'(a)')''
write(io,'(a)')'       NOTE 15.11'
write(io,'(a)')'       The syntax rules and their constraints require that a derived type that is interoperable have components'
write(io,'(a)')'       that are all data entities that are interoperable. No component is permitted to be allocatable or a pointer,'
write(io,'(a)')'       but the value of a component of type C FUNPTR or C PTR may be the C address of such an entity.'
write(io,'(a)')''
write(io,'(a)')'  A Fortran derived type is interoperable with a C struct type if the derived-type definition of the Fortran type'
write(io,'(a)')'  specifies BIND(C) (4.5.2), the Fortran derived type and the C struct type have the same number of components,'
write(io,'(a)')'  and the components of the Fortran derived type have types and type parameters that are interoperable with'
write(io,'(a)')'  the types of the corresponding components of the C struct type. A component of a Fortran derived type and'
write(io,'(a)')'  a component of a C struct type correspond if they are declared in the same relative position in their respective'
write(io,'(a)')'  type definitions.'
write(io,'(a)')''
write(io,'(a)')'       NOTE 15.12'
write(io,'(a)')'       The names of the corresponding components of the derived type and the C struct type need not be the'
write(io,'(a)')'       same.'
write(io,'(a)')''
write(io,'(a)')'  There is no Fortran type that is interoperable with a C struct type that contains a bit field or that contains a'
write(io,'(a)')'  flexible array member. There is no Fortran type that is interoperable with a C union type.'
write(io,'(a)')''
write(io,'(a)')'        NOTE 15.13'
write(io,'(a)')'        For example, the C type myctype, declared below, is interoperable with the Fortran type myftype, declared'
write(io,'(a)')'        below.'
write(io,'(a)')''
write(io,'(a)')'        typedef struct'
write(io,'(a)')'          int m, n;'
write(io,'(a)')'          float r;'
write(io,'(a)')'         myctype'
write(io,'(a)')''
write(io,'(a)')'        USE, INTRINSIC :: ISO_C_BINDING'
write(io,'(a)')'        TYPE, BIND(C) :: MYFTYPE'
write(io,'(a)')'          INTEGER(C_INT) :: I, J'
write(io,'(a)')'          REAL(C_FLOAT) :: S'
write(io,'(a)')'        END TYPE MYFTYPE'
write(io,'(a)')''
write(io,'(a)')'        The names of the types and the names of the components are not significant for the purposes of determining'
write(io,'(a)')'        whether a Fortran derived type is interoperable with a C struct type.'
write(io,'(a)')''
write(io,'(a)')'        NOTE 15.14'
write(io,'(a)')'        The C International Standard requires the names and component names to be the same in order for the types'
write(io,'(a)')'        to be compatible (C International Standard, subclause 6.2.7). This is similar to Fortran''s rule describing'
write(io,'(a)')'        when different derived type definitions describe the same sequence type. This rule was not extended to'
write(io,'(a)')'        determine whether a Fortran derived type is interoperable with a C struct type because the case of identifi'
write(io,'(a)')'        is significant in C but not in Fortran.'
write(io,'(a)')''
write(io,'(a)')'  15.3.5       Interoperability of scalar variables'
write(io,'(a)')'  A scalar Fortran variable is interoperable if its type and type parameters are interoperable, it is not a coarray'
write(io,'(a)')'  and it has neither the ALLOCATABLE nor the POINTER attribute.'
write(io,'(a)')''
write(io,'(a)')'  An interoperable scalar Fortran variable is interoperable with a scalar C entity if their types and type paramete'
write(io,'(a)')'  are interoperable.'
write(io,'(a)')''
write(io,'(a)')'  15.3.6       Interoperability of array variables'
write(io,'(a)')'  An array Fortran variable is interoperable if its type and type parameters are interoperable, it is not a coarray'
write(io,'(a)')'  and it is of explicit shape or assumed size.'
write(io,'(a)')''
write(io,'(a)')'  An explicit-shape or assumed-size array of rank r, with a shape of      e1   ...   er   is interoperable with a C'
write(io,'(a)')'  if its size is nonzero and'
write(io,'(a)')'         (1)    either'
write(io,'(a)')'                (a)      the array is assumed-size, and the C array does not specify a size, or'
write(io,'(a)')'                (b)      the array is an explicit-shape array, and the extent of the last dimension (er ) is the sa'
write(io,'(a)')'                         the size of the C array, and'
write(io,'(a)')'         (2)    either'
write(io,'(a)')'                (a)      r is equal to one, and an element of the array is interoperable with an element of the C a'
write(io,'(a)')''
write(io,'(a)')'                         or'
write(io,'(a)')''
write(io,'(a)')'               (b)   r is greater than one, and an explicit-shape array with shape of e1 . . . er-1 , with the'
write(io,'(a)')'                     same type and type parameters as the original array, is interoperable with a C array of a type'
write(io,'(a)')'                     equal to the element type of the original C array.'
write(io,'(a)')''
write(io,'(a)')'       NOTE 15.15'
write(io,'(a)')'       An element of a multi-dimensional C array is an array type, so a Fortran array of rank one is not interop-'
write(io,'(a)')'       erable with a multidimensional C array.'
write(io,'(a)')''
write(io,'(a)')'       NOTE 15.16'
write(io,'(a)')'       An allocatable array or array pointer is never interoperable. Such an array does not meet the requirement'
write(io,'(a)')'       of being an explicit-shape or assumed-size array.'
write(io,'(a)')''
write(io,'(a)')'       NOTE 15.17'
write(io,'(a)')'       For example, a Fortran array declared as'
write(io,'(a)')''
write(io,'(a)')'       INTEGER :: A(18, 3:7, *)'
write(io,'(a)')''
write(io,'(a)')'       is interoperable with a C array declared as'
write(io,'(a)')''
write(io,'(a)')'       int b[][5][18]'
write(io,'(a)')''
write(io,'(a)')'       NOTE 15.18'
write(io,'(a)')'       The C programming language defines null-terminated strings, which are actually arrays of the C type char'
write(io,'(a)')'       that have a C null character in them to indicate the last valid element. A Fortran array of type character'
write(io,'(a)')'       with a kind type parameter equal to C CHAR is interoperable with a C string.'
write(io,'(a)')''
write(io,'(a)')'       Fortran''s rules of sequence association (12.5.2.11) permit a character scalar actual argument to correspond'
write(io,'(a)')'       to a dummy argument array. This makes it possible to argument associate a Fortran character string with'
write(io,'(a)')'       a C string.'
write(io,'(a)')''
write(io,'(a)')'       Note 15.22 has an example of interoperation between Fortran and C strings.'
write(io,'(a)')''
write(io,'(a)')'  15.3.7      Interoperability of procedures and procedure interfaces'
write(io,'(a)')'  A Fortran procedure is interoperable if it has the BIND attribute, that is, if its interface is specified with a'
write(io,'(a)')'  proc-language-binding-spec.'
write(io,'(a)')''
write(io,'(a)')'  A Fortran procedure interface is interoperable with a C function prototype if'
write(io,'(a)')''
write(io,'(a)')'        (1)    the interface has the BIND attribute,'
write(io,'(a)')'        (2)    either'
write(io,'(a)')'               (a)   the interface describes a function whose result variable is a scalar that is interoperable wit'
write(io,'(a)')'                     the result of the prototype or'
write(io,'(a)')'               (b)   the interface describes a subroutine and the prototype has a result type of void,'
write(io,'(a)')'        (3)    the number of dummy arguments of the interface is equal to the number of formal parameters of the'
write(io,'(a)')'               prototype,'
write(io,'(a)')'        (4)    any dummy argument with the VALUE attribute is interoperable with the corresponding formal'
write(io,'(a)')'               parameter of the prototype,'
write(io,'(a)')'        (5)    any dummy argument without the VALUE attribute corresponds to a formal parameter of the pro-'
write(io,'(a)')'               totype that is of a pointer type, and the dummy argument is interoperable with an entity of the'
write(io,'(a)')'               referenced type (C International Standard, 6.2.5, 7.17, and 7.18.1) of the formal parameter, and'
write(io,'(a)')'        (6)    the prototype does not have variable arguments as denoted by the ellipsis (...).'
write(io,'(a)')''
write(io,'(a)')'        NOTE 15.19'
write(io,'(a)')'        The referenced type of a C pointer type is the C type of the object that the C pointer type points to.'
write(io,'(a)')'        For example, the referenced type of the pointer type int * is int.'
write(io,'(a)')''
write(io,'(a)')'        NOTE 15.20'
write(io,'(a)')'        The C language allows specification of a C function that can take a variable number of arguments (C'
write(io,'(a)')'        International Standard, 7.15). This part of ISO/IEC 1539 does not provide a mechanism for Fortran'
write(io,'(a)')'        procedures to interoperate with such C functions.'
write(io,'(a)')''
write(io,'(a)')'  A formal parameter of a C function prototype corresponds to a dummy argument of a Fortran interface if they'
write(io,'(a)')'  are in the same relative positions in the C parameter list and the dummy argument list, respectively.'
write(io,'(a)')''
write(io,'(a)')'        NOTE 15.21'
write(io,'(a)')'        For example, a Fortran procedure interface described by'
write(io,'(a)')''
write(io,'(a)')'        INTERFACE'
write(io,'(a)')'          FUNCTION FUNC(I, J, K, L, M) BIND(C)'
write(io,'(a)')'            USE, INTRINSIC :: ISO_C_BINDING'
write(io,'(a)')'            INTEGER(C_SHORT) :: FUNC'
write(io,'(a)')'            INTEGER(C_INT), VALUE :: I'
write(io,'(a)')'            REAL(C_DOUBLE) :: J'
write(io,'(a)')'            INTEGER(C_INT) :: K, L(10)'
write(io,'(a)')'            TYPE(C_PTR), VALUE :: M'
write(io,'(a)')'          END FUNCTION FUNC'
write(io,'(a)')'        END INTERFACE'
write(io,'(a)')''
write(io,'(a)')'        is interoperable with the C function prototype'
write(io,'(a)')''
write(io,'(a)')'        short func(int i, double *j, int *k, int l[10], void *m)'
write(io,'(a)')''
write(io,'(a)')'        A C pointer may correspond to a Fortran dummy argument of type C PTR with the VALUE attribute or'
write(io,'(a)')'        to a Fortran scalar that does not have the VALUE attribute. In the above example, the C pointers j and'
write(io,'(a)')'        k correspond to the Fortran scalars J and K, respectively, and the C pointer m corresponds to the Fortran'
write(io,'(a)')'        dummy argument M of type C PTR.'
write(io,'(a)')''
write(io,'(a)')'        NOTE 15.22'
write(io,'(a)')'        The interoperability of Fortran procedure interfaces with C function prototypes is only one part of invocat'
write(io,'(a)')'        of a C function from Fortran. There are four pieces to consider in such an invocation: the procedure'
write(io,'(a)')'        reference, the Fortran procedure interface, the C function prototype, and the C function. Conversely,'
write(io,'(a)')'        the invocation of a Fortran procedure from C involves the function reference, the C function prototype,'
write(io,'(a)')'        the Fortran procedure interface, and the Fortran procedure. In order to determine whether a reference is'
write(io,'(a)')'        allowed, it is necessary to consider all four pieces.'
write(io,'(a)')''
write(io,'(a)')'        For example, consider a C function that can be described by the C function prototype'
write(io,'(a)')''
write(io,'(a)')'        void copy(char in[], char out[]);'
write(io,'(a)')''
write(io,'(a)')'        Such a function may be invoked from Fortran as follows:'
write(io,'(a)')''
write(io,'(a)')'          USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_CHAR, C_NULL_CHAR'
write(io,'(a)')'          INTERFACE'
write(io,'(a)')'            SUBROUTINE COPY(IN, OUT) BIND(C)'
write(io,'(a)')'              IMPORT C_CHAR'
write(io,'(a)')'              CHARACTER(KIND=C_CHAR), DIMENSION(*) :: IN, OUT'
write(io,'(a)')'            END SUBROUTINE COPY'
write(io,'(a)')'          END INTERFACE'
write(io,'(a)')''
write(io,'(a)')'           CHARACTER(LEN=10, KIND=C_CHAR) :: &'
write(io,'(a)')'         &      DIGIT_STRING = C_CHAR_''123456789'' // C_NULL_CHAR'
write(io,'(a)')'           CHARACTER(KIND=C_CHAR) :: DIGIT_ARR(10)'
write(io,'(a)')''
write(io,'(a)')'          CALL COPY(DIGIT_STRING, DIGIT_ARR)'
write(io,'(a)')'          PRINT ''(1X, A1)'', DIGIT_ARR(1:9)'
write(io,'(a)')'          END'
write(io,'(a)')''
write(io,'(a)')'       The procedure reference has character string actual arguments. These correspond to character array dummy'
write(io,'(a)')'       arguments in the procedure interface body as allowed by Fortran''s rules of sequence association (12.5.2.11)'
write(io,'(a)')'       Those array dummy arguments in the procedure interface are interoperable with the formal parameters of'
write(io,'(a)')'       the C function prototype. The C function is not shown here, but is assumed to be compatible with the C'
write(io,'(a)')'       function prototype.'
write(io,'(a)')''
write(io,'(a)')'  15.4      Interoperation with C global variables'
write(io,'(a)')''
write(io,'(a)')'  15.4.1     General'
write(io,'(a)')'  A C variable whose name has external linkage may interoperate with a common block or with a variable declared'
write(io,'(a)')'  in the scope of a module. The common block or variable shall be specified to have the BIND attribute.'
write(io,'(a)')''
write(io,'(a)')'  At most one variable that is associated with a particular C variable whose name has external linkage is permitted'
write(io,'(a)')'  to be declared within all the Fortran program units of a program. A variable shall not be initially defined by'
write(io,'(a)')'  more than one processor.'
write(io,'(a)')''
write(io,'(a)')'  If a common block is specified in a BIND statement, it shall be specified in a BIND statement with the same bind-'
write(io,'(a)')'  ing label in each scoping unit in which it is declared. A C variable whose name has external linkage interoperate'
write(io,'(a)')'  with a common block that has been specified in a BIND statement'
write(io,'(a)')'        if the C variable is of a struct type and the variables that are members of the common block are interopera'
write(io,'(a)')'        with corresponding components of the struct type, or'
write(io,'(a)')'        if the common block contains a single variable, and the variable is interoperable with the C variable.'
write(io,'(a)')''
write(io,'(a)')'  There does not have to be an associated C entity for a Fortran entity with the BIND attribute.'
write(io,'(a)')''
write(io,'(a)')'       NOTE 15.23'
write(io,'(a)')'       The following are examples of the usage of the BIND attribute for variables and for a common block.'
write(io,'(a)')'       The Fortran variables, C EXTERN and C2, interoperate with the C variables, c extern and myVariable,'
write(io,'(a)')'       respectively. The Fortran common blocks, COM and SINGLE, interoperate with the C variables, com and'
write(io,'(a)')'       single, respectively.'
write(io,'(a)')''
write(io,'(a)')'       MODULE LINK_TO_C_VARS'
write(io,'(a)')'         USE, INTRINSIC :: ISO_C_BINDING'
write(io,'(a)')'         INTEGER(C_INT), BIND(C) :: C_EXTERN'
write(io,'(a)')'          INTEGER(C_LONG) :: C2'
write(io,'(a)')'          BIND(C, NAME=''myVariable'') :: C2'
write(io,'(a)')''
write(io,'(a)')'          COMMON /COM/ R, S'
write(io,'(a)')'          REAL(C_FLOAT) :: R, S, T'
write(io,'(a)')'          BIND(C) :: /COM/, /SINGLE/'
write(io,'(a)')'          COMMON /SINGLE/ T'
write(io,'(a)')'        END MODULE LINK_TO_C_VARS'
write(io,'(a)')'        int c_extern;'
write(io,'(a)')'        long myVariable;'
write(io,'(a)')'        struct float r, s; com;'
write(io,'(a)')'        float single;'
write(io,'(a)')''
write(io,'(a)')'  15.4.2     Binding labels for common blocks and variables'
write(io,'(a)')'  The binding label of a variable or common block is a default character value that specifies the name by which'
write(io,'(a)')'  the variable or common block is known to the companion processor.'
write(io,'(a)')''
write(io,'(a)')'  If a variable or common block has the BIND attribute with the NAME= specifier and the value of its expression,'
write(io,'(a)')'  after discarding leading and trailing blanks, has nonzero length, the variable or common block has this as its'
write(io,'(a)')'  binding label. The case of letters in the binding label is significant. If a variable or common block has the BIN'
write(io,'(a)')'  attribute specified without a NAME= specifier, the binding label is the same as the name of the entity using'
write(io,'(a)')'  lower case letters. Otherwise, the variable or common block has no binding label.'
write(io,'(a)')''
write(io,'(a)')'  The binding label of a C variable whose name has external linkage is the same as the name of the C variable.'
write(io,'(a)')'  A Fortran variable or common block with the BIND attribute that has the same binding label as a C variable'
write(io,'(a)')'  whose name has external linkage is linkage associated (16.5.1.5) with that variable.'
write(io,'(a)')''
write(io,'(a)')'  15.5      Interoperation with C functions'
write(io,'(a)')''
write(io,'(a)')'  15.5.1     Definition and reference of interoperable procedures'
write(io,'(a)')'  A procedure that is interoperable may be defined either by means other than Fortran or by means of a Fortran'
write(io,'(a)')'  subprogram, but not both.'
write(io,'(a)')''
write(io,'(a)')'  If the procedure is defined by means other than Fortran, it shall'
write(io,'(a)')''
write(io,'(a)')'        be describable by a C prototype that is interoperable with the interface,'
write(io,'(a)')'        have a name that has external linkage as defined by 6.2.2 of the C International Standard, and'
write(io,'(a)')'        have the same binding label as the interface.'
write(io,'(a)')''
write(io,'(a)')'  A reference to such a procedure causes the function described by the C prototype to be called as specified in the'
write(io,'(a)')'  C International Standard.'
write(io,'(a)')''
write(io,'(a)')'  A reference in C to a procedure that has the BIND attribute, has the same binding label, and is defined by means'
write(io,'(a)')'  of Fortran, causes the Fortran procedure to be invoked.'
write(io,'(a)')''
write(io,'(a)')'  A procedure defined by means of Fortran shall not invoke setjmp or longjmp (C International Standard, 7.13).'
write(io,'(a)')'  If a procedure defined by means other than Fortran invokes setjmp or longjmp, that procedure shall not cause'
write(io,'(a)')'  any procedure defined by means of Fortran to be invoked. A procedure defined by means of Fortran shall not be'
write(io,'(a)')'  invoked as a signal handler (C International Standard, 7.14.1).'
write(io,'(a)')''
write(io,'(a)')'  If a procedure defined by means of Fortran and a procedure defined by means other than Fortran perform'
write(io,'(a)')'  input/output operations on the same external file, the results are processor dependent (9.5.4).'
write(io,'(a)')''
write(io,'(a)')'  15.5.2     Binding labels for procedures'
write(io,'(a)')'  The binding label of a procedure is a default character value that specifies the name by which a procedure with'
write(io,'(a)')'  the BIND attribute is known to the companion processor.'
write(io,'(a)')''
write(io,'(a)')'  If a procedure has the BIND attribute with the NAME= specifier and the value of its expression, after discarding'
write(io,'(a)')'  leading and trailing blanks, has nonzero length, the procedure has this as its binding label. The case of letters'
write(io,'(a)')'  in the binding label is significant. If a procedure has the BIND attribute with no NAME= specifier, and the'
write(io,'(a)')'  procedure is not a dummy procedure, internal procedure, or procedure pointer, then the binding label of the'
write(io,'(a)')'  procedure is the same as the name of the procedure using lower case letters. Otherwise, the procedure has no'
write(io,'(a)')'  binding label.'
write(io,'(a)')''
write(io,'(a)')'  C1506 A procedure defined in a submodule shall not have a binding label unless its interface is declared in the'
write(io,'(a)')'        ancestor module.'
write(io,'(a)')''
write(io,'(a)')'  The binding label for a C function whose name has external linkage is the same as the C function name.'
write(io,'(a)')''
write(io,'(a)')'       NOTE 15.24'
write(io,'(a)')'       In the following sample, the binding label of C SUB is "c_sub", and the binding label of C FUNC is'
write(io,'(a)')'       "C_funC".'
write(io,'(a)')''
write(io,'(a)')'       SUBROUTINE C_SUB() BIND(C)'
write(io,'(a)')'         ...'
write(io,'(a)')'       END SUBROUTINE C_SUB'
write(io,'(a)')''
write(io,'(a)')'       INTEGER(C_INT) FUNCTION C_FUNC() BIND(C, NAME="C_funC")'
write(io,'(a)')'         USE, INTRINSIC :: ISO_C_BINDING'
write(io,'(a)')'         ...'
write(io,'(a)')'       END FUNCTION C_FUNC'
write(io,'(a)')''
write(io,'(a)')'       The C International Standard permits functions to have names that are not permitted as Fortran names;'
write(io,'(a)')'       it also distinguishes between names that would be considered as the same name in Fortran. For example,'
write(io,'(a)')'       a C name may begin with an underscore, and C names that differ in case are distinct names.'
write(io,'(a)')''
write(io,'(a)')'       The specification of a binding label allows a program to use a Fortran name to refer to a procedure defined'
write(io,'(a)')'       by a companion processor.'
write(io,'(a)')''
write(io,'(a)')'  15.5.3     Exceptions and IEEE arithmetic procedures'
write(io,'(a)')'  A procedure defined by means other than Fortran shall not use signal (C International Standard, 7.14.1) to change'
write(io,'(a)')'  the handling of any exception that is being handled by the Fortran processor.'
write(io,'(a)')''
write(io,'(a)')'  A procedure defined by means other than Fortran shall not alter the floating-point status (14.7) other than by'
write(io,'(a)')'  setting an exception flag to signaling.'
write(io,'(a)')''
write(io,'(a)')'  The values of the floating-point exception flags on entry to a procedure defined by means other than Fortran are'
write(io,'(a)')'  processor-dependent.'
write(io,'(a)')'NAME'
write(io,'(a)')'   fortran_continuation_line(7f) - [FORTRAN] Fortran Continuation Lines'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'If a statement is too long to fit on a line, it can be continued with'
write(io,'(a)')'the following methods: If a line is ended with an ampersand, &, it will'
write(io,'(a)')'be continued on the next line. Continuation is normally to the first'
write(io,'(a)')'character of the next non-comment line.'
write(io,'(a)')''
write(io,'(a)')'   A = 174.5 * Year   &'
write(io,'(a)')'       + Count / 100'
write(io,'(a)')'The above is equivalent to the following'
write(io,'(a)')''
write(io,'(a)')'   A = 174.5 * Year  + Count / 100'
write(io,'(a)')''
write(io,'(a)')'Note that & is not part of the statement.'
write(io,'(a)')''
write(io,'(a)')'   A = 174.5 * Year   &'
write(io,'(a)')'   !  this is a comment line'
write(io,'(a)')'       + Count / 100'
write(io,'(a)')''
write(io,'(a)')'The above is equivalent to the following, since the comment is ignored'
write(io,'(a)')'by the compiler:'
write(io,'(a)')''
write(io,'(a)')'   A = 174.5 * Year  + Count / 100'
write(io,'(a)')''
write(io,'(a)')'If the first non-blank character of the continuation line is &,'
write(io,'(a)')'continuation is to the first character after the &:'
write(io,'(a)')''
write(io,'(a)')'   A = 174.5 + ThisIsALong&'
write(io,'(a)')'        &VariableName * 123.45'
write(io,'(a)')''
write(io,'(a)')'is equivalent to'
write(io,'(a)')''
write(io,'(a)')'   A = 174.5 + ThisIsALongVariableName * 123.45'
write(io,'(a)')''
write(io,'(a)')'In this case, there should be no spaces between the last character and'
write(io,'(a)')'the & on the first line. For example,'
write(io,'(a)')''
write(io,'(a)')'   A = 174.5 + ThisIsALong   &'
write(io,'(a)')'        &VariableName * 123.45'
write(io,'(a)')''
write(io,'(a)')'is equivalent to'
write(io,'(a)')''
write(io,'(a)')'   A = 174.5 + ThisIsALong   VariableName * 123.45'
write(io,'(a)')''
write(io,'(a)')'Note that there are spaces between ThisIsALong and VariableName. In this'
write(io,'(a)')'way, a token (name and number) can be split over two lines. However,'
write(io,'(a)')'this is not recommended'
write(io,'(a)')''
write(io,'(a)')'SPECIFICALLY'
write(io,'(a)')'3.3.2.4     Free form statement continuation'
write(io,'(a)')''
write(io,'(a)')'1. The character "&" is used to indicate that the current statement is'
write(io,'(a)')'   continued on the next line that is not a'
write(io,'(a)')'   comment line. Comment lines cannot be continued; an "&" in a comment'
write(io,'(a)')'   has no effect. Comments may occur within a continued statement. When'
write(io,'(a)')'   used for continuation, the "&" is not part of the statement. No line'
write(io,'(a)')'   shall contain a single "&" as the only nonblank character or as the'
write(io,'(a)')'   only nonblank character before an "!" that initiates a comment.'
write(io,'(a)')''
write(io,'(a)')'2. If a noncharacter context is to be continued, an "&" shall be the last'
write(io,'(a)')'   nonblank character on the line, or the last'
write(io,'(a)')'   nonblank character before an "!". There shall be a later line that is'
write(io,'(a)')'   not a comment; the statement is continued on the next such line. If'
write(io,'(a)')'   the first nonblank character on that line is an "&", the statement'
write(io,'(a)')'   continues at the next character position following that "&"; otherwise,'
write(io,'(a)')'   it continues with the first character position of that line.'
write(io,'(a)')''
write(io,'(a)')'3. If a lexical token is split across the end of a line, the first nonblank'
write(io,'(a)')'   character on the first following noncomment'
write(io,'(a)')'   line shall be an "&" immediately followed by the successive characters'
write(io,'(a)')'   of the split token.'
write(io,'(a)')''
write(io,'(a)')'4. If a character context is to be continued, an "&" shall be the last'
write(io,'(a)')'   nonblank character on the line and shall not be'
write(io,'(a)')'   followed by commentary. There shall be a later line that is not a'
write(io,'(a)')'   comment; an "&" shall be the first nonblank character on the next such'
write(io,'(a)')'   line and the statement continues with the next character following that'
write(io,'(a)')'  "&".'
write(io,'(a)')''
write(io,'(a)')'So this is OK:'
write(io,'(a)')''
write(io,'(a)')'   POINT=[&   ! define a Point <X,Y,Z>'
write(io,'(a)')'   & 10, &    ! the X component'
write(io,'(a)')'   & 20, &    ! the Y component'
write(io,'(a)')'   & 30  ]    ! the Z component'
write(io,'(a)')''
write(io,'(a)')'because you can have comments after the ampersand when it is not a string.'
write(io,'(a)')'But this is not OK:'
write(io,'(a)')''
write(io,'(a)')'   STRING=[''&   ! create a sentence'
write(io,'(a)')'   & This&      ! first word'
write(io,'(a)')'   & is&        ! second word'
write(io,'(a)')'   & sentence&  ! third word'
write(io,'(a)')'   & a'']        ! forth word (a comment here is OK)'
write(io,'(a)')''
write(io,'(a)')'Because when continuing a string you cannot have a comment after the ampersand.'
write(io,'(a)')'This is OK:'
write(io,'(a)')''
write(io,'(a)')'   STRING=[''&'
write(io,'(a)')'   ! create a sentence'
write(io,'(a)')'   & This&'
write(io,'(a)')'   ! first word'
write(io,'(a)')'   & is&'
write(io,'(a)')'   ! second word'
write(io,'(a)')'   & sentence&'
write(io,'(a)')'   ! third word'
write(io,'(a)')'   & a'']        ! forth word (a comment here is OK)'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'Long strings:'
write(io,'(a)')''
write(io,'(a)')'   Subroutine LongString()'
write(io,'(a)')''
write(io,'(a)')'   Character (len=200) :: string1, String2'
write(io,'(a)')'   string1 = "A very long string that won''t fit on a single &'
write(io,'(a)')'              &line can be made through proper continuation."'
write(io,'(a)')''
write(io,'(a)')'   string2 = "A very long string that won''t fit on a single " // &'
write(io,'(a)')'             "line can be made through proper continuation."'
write(io,'(a)')'   if (string1 == string2) then'
write(io,'(a)')'     print *, "string1 and 2 are identical!"'
write(io,'(a)')'     print *, "string1 & 2=",string1'
write(io,'(a)')'   else'
write(io,'(a)')'     print *, "string1 and 2 don''t match!"'
write(io,'(a)')'   endif'
write(io,'(a)')''
write(io,'(a)')'   End Subroutine LongString'
write(io,'(a)')''
write(io,'(a)')'.so select.7'
write(io,'(a)')'.so select.7'
write(io,'(a)')'NAME'
write(io,'(a)')'   select(7f) - [FORTRAN:EXECUTION CONTROL] select a block based on the value of an expression (a case)'
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'1 The CASE construct selects for execution at most one of its constituent blocks. The selection is based on the'
write(io,'(a)')'  value of an expression.'
write(io,'(a)')''
write(io,'(a)')'  R810      case-construct               is   select-case-stmt'
write(io,'(a)')'                                                   [ case-stmt'
write(io,'(a)')'                                                        block ] ...'
write(io,'(a)')'                                                   end-select-stmt'
write(io,'(a)')''
write(io,'(a)')'  R811      select-case-stmt             is   [ case-construct-name : ] SELECT CASE  case-expr)'
write(io,'(a)')''
write(io,'(a)')'  R812      case-stmt                    is   CASE case-selector [case-construct-name]'
write(io,'(a)')''
write(io,'(a)')'  R813      end-select-stmt              is   END SELECT [ case-construct-name ]'
write(io,'(a)')''
write(io,'(a)')'  C809      (R810) If the select-case-stmt of a case-construct specifies'
write(io,'(a)')'            a case-construct-name, the corresponding end-select-stmt'
write(io,'(a)')'            shall specify the same case-construct-name. If'
write(io,'(a)')'            the select-case-stmt of a case-construct does not specify a'
write(io,'(a)')'            case-construct-name, the corresponding end-select-stmt shall'
write(io,'(a)')'            not specify a case-construct- name. If a case-stmt specifies'
write(io,'(a)')'            a case-construct-name, the corresponding select-case-stmt'
write(io,'(a)')'            shall specify the same case-construct-name.'
write(io,'(a)')''
write(io,'(a)')'  R814      case-expr                    is scalar-int-expr'
write(io,'(a)')'                                         or scalar-char-expr'
write(io,'(a)')'                                         or scalar-logical-expr'
write(io,'(a)')''
write(io,'(a)')'  R815      case-selector                is (case-value-range-list)'
write(io,'(a)')'                                         or DEFAULT'
write(io,'(a)')''
write(io,'(a)')'  C810      (R810) No more than one of the selectors of one of the CASE statements shall be DEFAULT.'
write(io,'(a)')''
write(io,'(a)')'  R816      case-value-range             is   case-value'
write(io,'(a)')'                                         or   case-value :'
write(io,'(a)')'                                         or   : case-value'
write(io,'(a)')'                                         or   case-value : case-value'
write(io,'(a)')''
write(io,'(a)')'  R817      case-value                   is scalar-int-initialization-expr'
write(io,'(a)')'                                         or scalar-char-initialization-expr'
write(io,'(a)')'                                         or scalar-logical-initialization-expr'
write(io,'(a)')''
write(io,'(a)')'  C811      (R810) For a given case-construct, each case-value shall be'
write(io,'(a)')'            of the same type as case-expr . For character'
write(io,'(a)')'            type, the kind type parameters shall be the same; character'
write(io,'(a)')'            length differences are allowed.'
write(io,'(a)')''
write(io,'(a)')'  C812      (R810) A case-value-range using a colon shall not be used'
write(io,'(a)')'            if case-expr is of type logical.'
write(io,'(a)')''
write(io,'(a)')'  C813      (R810) For a given case-construct, there shall be no possible'
write(io,'(a)')'            value of the case-expr that matches more'
write(io,'(a)')'            than one case-value-range.'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'  8.1.5      CASE construct'
write(io,'(a)')'  8.1.5.1    Purpose and form of the CASE construct'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'  8.1.5.2     Execution of a CASE construct'
write(io,'(a)')''
write(io,'(a)')'   The execution of the SELECT CASE statement causes the case expression'
write(io,'(a)')'   to be evaluated. The resulting value is called the case index. For a'
write(io,'(a)')'   case value range list, a match occurs if the case index matches any'
write(io,'(a)')'   of the case value ranges in the list. For a case index with a value'
write(io,'(a)')'   of c, a match is determined as follows.'
write(io,'(a)')''
write(io,'(a)')'        1. If the case value range contains a single value v without a colon, a match occurs for type logical if'
write(io,'(a)')'           the expression c .EQV. v is true, and a match occurs for type integer or character if the expression'
write(io,'(a)')'           c == v is true.'
write(io,'(a)')'        2. If the case value range is of the form low : high, a match occurs if the expression low <= c .AND.'
write(io,'(a)')'           c <= high is true.'
write(io,'(a)')'        3. If the case value range is of the form low :, a match occurs if the expression low <= c is true.'
write(io,'(a)')'        4. If the case value range is of the form : high, a match occurs if the expression c <= high is true.'
write(io,'(a)')'        5. If no other selector matches and a DEFAULT selector appears, it matches the case index.'
write(io,'(a)')'        6. If no other selector matches and the DEFAULT selector does not appear, there is no match.'
write(io,'(a)')''
write(io,'(a)')'   The block following the CASE statement containing the matching'
write(io,'(a)')'   selector, if any, is executed. This completes execution of the'
write(io,'(a)')'   construct.'
write(io,'(a)')''
write(io,'(a)')'   It is permissible to branch to an end-select-stmt only from within'
write(io,'(a)')'   its CASE construct.'
write(io,'(a)')''
write(io,'(a)')'  8.1.5.3     Examples of CASE constructs'
write(io,'(a)')''
write(io,'(a)')'       An integer signum function:'
write(io,'(a)')''
write(io,'(a)')'       integer function signum (n)'
write(io,'(a)')'       select case (n)'
write(io,'(a)')'       case (:-1)'
write(io,'(a)')'          signum = -1'
write(io,'(a)')'       case (0)'
write(io,'(a)')'          signum = 0'
write(io,'(a)')'       case (1:)'
write(io,'(a)')'          signum = 1'
write(io,'(a)')'       end select'
write(io,'(a)')'       end'
write(io,'(a)')''
write(io,'(a)')'       A code fragment to check for balanced parentheses:'
write(io,'(a)')''
write(io,'(a)')'       character (80) :: line'
write(io,'(a)')'          ...'
write(io,'(a)')'       level = 0'
write(io,'(a)')'       scan_line: do i = 1, 80'
write(io,'(a)')'          check_parens: select case (line (i:i))'
write(io,'(a)')'          case (''('')'
write(io,'(a)')'             level = level + 1'
write(io,'(a)')'          case ('')'')'
write(io,'(a)')'             level = level - 1'
write(io,'(a)')'             if (level < 0) then'
write(io,'(a)')'                print *, ''unexpected right parenthesis'''
write(io,'(a)')'                exit scan_line'
write(io,'(a)')'             end if'
write(io,'(a)')'          case default'
write(io,'(a)')'             ! ignore all other characters'
write(io,'(a)')'           end select check_parens'
write(io,'(a)')'        end do scan_line'
write(io,'(a)')'        if (level > 0) then'
write(io,'(a)')'           print *, ''missing right parenthesis'''
write(io,'(a)')'        end if'
write(io,'(a)')''
write(io,'(a)')'        the following three fragments are equivalent:'
write(io,'(a)')''
write(io,'(a)')'        if (silly == 1) then'
write(io,'(a)')'           call this'
write(io,'(a)')'        else'
write(io,'(a)')'           call that'
write(io,'(a)')'        end if'
write(io,'(a)')'        select case (silly == 1)'
write(io,'(a)')'        case (.true.)'
write(io,'(a)')'           call this'
write(io,'(a)')'        case (.false.)'
write(io,'(a)')'           call that'
write(io,'(a)')'        end select'
write(io,'(a)')'        select case (silly)'
write(io,'(a)')'        case default'
write(io,'(a)')'           call that'
write(io,'(a)')'        case (1)'
write(io,'(a)')'           call this'
write(io,'(a)')'        end select'
write(io,'(a)')''
write(io,'(a)')'        A code fragment showing several selections of one block:'
write(io,'(a)')''
write(io,'(a)')'        select case (n)'
write(io,'(a)')'        case (1, 3:5, 8)        ! selects 1, 3, 4, 5, 8'
write(io,'(a)')'           call sub'
write(io,'(a)')'        case default'
write(io,'(a)')'           call other'
write(io,'(a)')'        end select'
write(io,'(a)')'NAME'
write(io,'(a)')'   where(7f) - [FORTRAN:ASSIGNMENT] masked array assignment'
write(io,'(a)')'SYNTAX'
write(io,'(a)')''
write(io,'(a)')'  WHERE statement:'
write(io,'(a)')''
write(io,'(a)')'   WHERE ( mask-expr ) where-assignment-stmt'
write(io,'(a)')''
write(io,'(a)')'  WHERE construct without ELSEWHERE:'
write(io,'(a)')''
write(io,'(a)')'     [where-construct-name:] WHERE ( mask-expr )'
write(io,'(a)')'     ELSEWHERE (mask-expr ) [where-construct-name]'
write(io,'(a)')''
write(io,'(a)')'  WHERE construct with ELSEWHEREs:'
write(io,'(a)')''
write(io,'(a)')'     [where-construct-name:] WHERE ( mask-expr )'
write(io,'(a)')'     [ELSEWHERE (mask-expr )'
write(io,'(a)')'        elemental-statements]'
write(io,'(a)')'     [ELSEWHERE (mask-expr )'
write(io,'(a)')'        elemental-statements]'
write(io,'(a)')'           :'
write(io,'(a)')'     [ELSEWHERE'
write(io,'(a)')'        elemental-statements'
write(io,'(a)')'     ]'
write(io,'(a)')'     END WHERE [where-construct-name]'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   A masked array assignment is either a WHERE statement or a WHERE'
write(io,'(a)')'   construct. It is used to mask the evaluation of expressions and'
write(io,'(a)')'   assignment of values in array assignment statements, according to the'
write(io,'(a)')'   value of a logical array expression.'
write(io,'(a)')''
write(io,'(a)')'   where-assignment-stmt that is a defined assignment shall be elemental.'
write(io,'(a)')''
write(io,'(a)')'   A statement that is part of a where-body-construct shall not be a'
write(io,'(a)')'   branch target statement.'
write(io,'(a)')''
write(io,'(a)')'   If a where-construct contains a where-stmt, a masked-elsewhere-stmt, or'
write(io,'(a)')'   another where-construct then each mask-expr within the where-construct'
write(io,'(a)')'   shall have the same shape. In each where-assignment-stmt, the mask-expr'
write(io,'(a)')'   and the variable being defined shall be arrays of the same shape.'
write(io,'(a)')''
write(io,'(a)')'   Examples of a masked array assignment are:'
write(io,'(a)')''
write(io,'(a)')'            WHERE (TEMP > 100.0) TEMP = TEMP - REDUCE_TEMP'
write(io,'(a)')''
write(io,'(a)')'            where (PRESSURE <= 1.0)'
write(io,'(a)')'               PRESSURE = PRESSURE + INC_PRESSURE'
write(io,'(a)')'               TEMP = TEMP - 5.0'
write(io,'(a)')'            elsewhere'
write(io,'(a)')'               RAINING = .TRUE.'
write(io,'(a)')'            endwhere'
write(io,'(a)')''
write(io,'(a)')'   Interpretation of masked array assignments'
write(io,'(a)')''
write(io,'(a)')'   When a WHERE statement or a where-construct-stmt is executed, a control'
write(io,'(a)')'   mask is established. In addition,'
write(io,'(a)')'   when a WHERE construct statement is executed, a pending control'
write(io,'(a)')'   mask is established. If the statement does not appear as part of a'
write(io,'(a)')'   where-body-construct, the mask-expr of the statement is evaluated,'
write(io,'(a)')'   and the control mask is established to be the value of mask-expr . The'
write(io,'(a)')'   pending control mask is established to have the value .NOT. mask- expr'
write(io,'(a)')'   upon execution of a WHERE construct statement that does not appear as'
write(io,'(a)')'   part of a where-body-construct. The mask-expr is evaluated only once.'
write(io,'(a)')''
write(io,'(a)')'   Each statement in a WHERE construct is executed in sequence.'
write(io,'(a)')''
write(io,'(a)')'   Upon execution of a masked-elsewhere-stmt, the following actions take place in sequence.'
write(io,'(a)')''
write(io,'(a)')'   1. The control mask mc is established to have the value of the pending control mask.'
write(io,'(a)')'   2. The pending control mask is established to have the value mc .AND. (.NOT. mask-expr ).'
write(io,'(a)')'   3. The control mask mc is established to have the value mc .AND. mask-expr .'
write(io,'(a)')''
write(io,'(a)')'   The mask-expr is evaluated at most once.'
write(io,'(a)')''
write(io,'(a)')'   Upon execution of an ELSEWHERE statement, the control mask is'
write(io,'(a)')'   established to have the value of the pending'
write(io,'(a)')'   control mask. No new pending control mask value is established.'
write(io,'(a)')''
write(io,'(a)')'   Upon execution of an ENDWHERE statement, the control mask and pending'
write(io,'(a)')'   control mask are established to have the values they had prior to the'
write(io,'(a)')'   execution of the corresponding WHERE construct statement. Following the'
write(io,'(a)')'   execution of a WHERE statement that appears as a where-body-construct,'
write(io,'(a)')'   the control mask is established to have the value it had prior to the'
write(io,'(a)')'   execution of the WHERE statement.'
write(io,'(a)')''
write(io,'(a)')'   The establishment of control masks and the pending control mask'
write(io,'(a)')'   is illustrated with the following example:'
write(io,'(a)')''
write(io,'(a)')'            where(cond1)             ! Statement 1'
write(io,'(a)')'            . . .'
write(io,'(a)')'            elsewhere(cond2)         ! Statement 2'
write(io,'(a)')'            . . .'
write(io,'(a)')'            elsewhere                ! Statement 3'
write(io,'(a)')'            . . .'
write(io,'(a)')'            end where'
write(io,'(a)')''
write(io,'(a)')'   Following execution of statement 1, the control mask has the value'
write(io,'(a)')'   cond1 and the pending control mask has the value .NOT. cond1.'
write(io,'(a)')'   Following execution of statement 2, the control mask has the value'
write(io,'(a)')'   (.NOT. cond1) .AND. cond2 and the pending control mask has the'
write(io,'(a)')'   value (.NOT. cond1) .AND. (.NOT. cond2). Following execution'
write(io,'(a)')'   of statement 3, the control mask has the value (.NOT. cond1)'
write(io,'(a)')'   .AND. (.NOT. cond2). The false condition values are propagated'
write(io,'(a)')'   through the execution of the masked ELSEWHERE statement.'
write(io,'(a)')''
write(io,'(a)')'   Upon execution of a WHERE construct statement that is part of a'
write(io,'(a)')'   where-body-construct, the pending control mask is established to'
write(io,'(a)')'   have the value mc .AND. (.NOT. mask-expr ). The control mask is then'
write(io,'(a)')'   established to have the value mc .AND. mask-expr. The mask-expr is'
write(io,'(a)')'   evaluated at most once.'
write(io,'(a)')''
write(io,'(a)')'   Upon execution of a WHERE statement that is part of a'
write(io,'(a)')'   where-body-construct, the control mask is established to have the'
write(io,'(a)')'   value mc .AND. mask-expr. The pending control mask is not altered.'
write(io,'(a)')''
write(io,'(a)')'   If a nonelemental function reference occurs in the expr or variable'
write(io,'(a)')'   of a where-assignment-stmt or in a mask-expr ,'
write(io,'(a)')'   the function is evaluated without any masked control; that is, all of'
write(io,'(a)')'   its argument expressions are fully evaluated and the function is fully'
write(io,'(a)')'   evaluated. If the result is an array and the reference is not within'
write(io,'(a)')'   the argument list of a nonelemental function, elements corresponding'
write(io,'(a)')'   to true values in the control mask are selected for use in evaluating'
write(io,'(a)')'   the expr, variable or mask-expr.'
write(io,'(a)')''
write(io,'(a)')'   If an elemental operation or function reference occurs in the expr'
write(io,'(a)')'   or variable of a where-assignment-stmt or in a'
write(io,'(a)')'   mask-expr , and is not within the argument list of a nonelemental'
write(io,'(a)')'   function reference, the operation is performed or the function is'
write(io,'(a)')'   evaluated only for the elements corresponding to true values of the'
write(io,'(a)')'   control mask.'
write(io,'(a)')''
write(io,'(a)')'   If an array constructor appears in a where-assignment-stmt or in a'
write(io,'(a)')'   mask-expr , the array constructor is evaluated'
write(io,'(a)')'   without any masked control and then the where-assignment-stmt is'
write(io,'(a)')'   executed or the mask-expr is evaluated.'
write(io,'(a)')''
write(io,'(a)')'   When a where-assignment-stmt is executed, the values of expr that'
write(io,'(a)')'   correspond to true values of the control mask'
write(io,'(a)')'   are assigned to the corresponding elements of the variable.'
write(io,'(a)')''
write(io,'(a)')'   The value of the control mask is established by the execution of a'
write(io,'(a)')'   WHERE statement, a WHERE construct'
write(io,'(a)')'   statement, an ELSEWHERE statement, a masked ELSEWHERE statement, or'
write(io,'(a)')'   an ENDWHERE statement. Subsequent changes to the value of entities'
write(io,'(a)')'   in a mask-expr have no effect on the value of the control mask. The'
write(io,'(a)')'   execution of a function reference in the mask expression of a WHERE'
write(io,'(a)')'   statement is permitted to affect entities in the assignment statement.'
write(io,'(a)')''
write(io,'(a)')'   Examples of function references in masked array assignments are:'
write(io,'(a)')''
write(io,'(a)')'      where (A > 0.0)'
write(io,'(a)')'         A = LOG (A)           ! LOG is invoked only for positive elements.'
write(io,'(a)')'         A = A / SUM (LOG (A)) ! LOG is invoked for all elements'
write(io,'(a)')'                               ! because SUM is transformational.'
write(io,'(a)')'      end where'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  Sample'
write(io,'(a)')''
write(io,'(a)')'   program demo_where'
write(io,'(a)')'   !  Example of WHERE, ELSE WHERE, END WHERE'
write(io,'(a)')'   parameter (nd=10, ndh=nd/2, nduh=nd-ndh-1)'
write(io,'(a)')'   real, dimension(nd):: a=[ (2*j,j=1,nd) ]'
write(io,'(a)')'   real, dimension(nd):: b ! =[ ndh*1.0, 0.0, nduh*2.0 ]'
write(io,'(a)')'   real, dimension(nd):: c ! =[ nd*-77.77 ]'
write(io,'(a)')'   integer iflag(nd)'
write(io,'(a)')'   data b/ndh*1,0.0,nduh*2./,c/nd*-77.77/'
write(io,'(a)')''
write(io,'(a)')'   where (b.ne.0) c=a/b'
write(io,'(a)')'   write (*,2000) c(1:nd)'
write(io,'(a)')'   !'
write(io,'(a)')'   !  The above protects against divide by zero, but doesn''t actually assign'
write(io,'(a)')'   !  values to elements in c when the corresponding element in b is zero'
write(io,'(a)')'   !  The following covers that, and sets a flag when a divide by zero is'
write(io,'(a)')'   !  present'
write(io,'(a)')'   !'
write(io,'(a)')'   where (b(1:nd).ne.0.0)'
write(io,'(a)')'      c=a/b'
write(io,'(a)')'      iflag=0'
write(io,'(a)')'   else where'
write(io,'(a)')'      c=0.0'
write(io,'(a)')'      iflag=1'
write(io,'(a)')'   end where'
write(io,'(a)')''
write(io,'(a)')'   write (*,2000) c(1:nd)'
write(io,'(a)')'   write (*,1000) iflag(1:nd)'
write(io,'(a)')'   1000 format (''iflag= '',/,(10i7))'
write(io,'(a)')'   2000 format (''a/b = '',/,(10f7.2))'
write(io,'(a)')'   end program demo_where'
write(io,'(a)')''
write(io,'(a)')'.so do.7'
write(io,'(a)')'NAME'
write(io,'(a)')'   sign(7f) - [FORTRAN:IO] option to force optional plus sign on output values'
write(io,'(a)')''
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'   Program showing control of plus sign on positive numeric output'
write(io,'(a)')''
write(io,'(a)')'      implicit none'
write(io,'(a)')'      complex :: x=(123.456,987.654)'
write(io,'(a)')'      integer :: i=789'
write(io,'(a)')'      real    :: a=12.3456'
write(io,'(a)')'      integer :: j'
write(io,'(a)')'      namelist /nlist/ i,a,x'
write(io,'(a)')'      open(unit=6,sign=''plus'')'
write(io,'(a)')'      write(*,*)''PASS WHERE FILE HAS SIGN="PLUS"'''
write(io,'(a)')'      do j=1,2'
write(io,'(a)')'         write(*,*) ''LIST DIRECTED '',a,i,x'
write(io,'(a)')'         write(*,''(*(g0:,1x))'') ''GENERAL FORMATTED'',a,i,x'
write(io,'(a)')'         write(*,''(*(ss,g0:,1x))'') ''GENERAL FORMATTED EXPLICIT SUPPRESS'',a,i,x'
write(io,'(a)')'         write(*,''(*(sp,g0:,1x))'') ''GENERAL FORMATTED EXPLICIT PLUS'',a,i,x'
write(io,'(a)')'         write(*,''(a,1x,f8.4,1x,i4,1x,f9.4,1x,f9.4)'') ''FORMATTED'',a,i,x'
write(io,'(a)')'         write(*,''(a,1x,f8.4,1x,i4,1x,f9.4,1x,f9.4)'') ''FORMATTED'',a,i,x'
write(io,'(a)')'         write(*,nlist)'
write(io,'(a)')'         if(j.eq.2)exit'
write(io,'(a)')'         write(*,*)'
write(io,'(a)')'         open(unit=6,sign=''suppress'')'
write(io,'(a)')'         write(*,*)''PASS WHERE FILE HAS SIGN="SUPPRESS"'''
write(io,'(a)')'      enddo'
write(io,'(a)')'      end'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'    REWIND(7f) - [FORTRAN:FILE_POSITIONING] rewind specified sequential access I/O unit'
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'   REWIND file-unit-number'
write(io,'(a)')'   REWIND( [UNIT=]file-unit-number][,IOMSG=iomsg-variable][,IOSTAT=scalar-int-variable][,ERR=label] )'
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   Execution of a REWIND statement causes the file connected to the'
write(io,'(a)')'   specified unit to be positioned at the beginning of the file.'
write(io,'(a)')''
write(io,'(a)')'OPTIONS'
write(io,'(a)')'   UNIT     unit number of file to rewound.'
write(io,'(a)')'            A unit open for direct access or unformatted access cannot'
write(io,'(a)')'            be referenced by a REWIND.'
write(io,'(a)')'   IOSTAT   a compiler-specific number that indicates an error occurred'
write(io,'(a)')'            if non-zero.'
write(io,'(a)')'   IOMSG    a message describing error IOSTAT if IOSTAT is not zero.'
write(io,'(a)')'   ERR      a label number to jump to if an error occurs'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'  An example of a REWIND statement is:'
write(io,'(a)')''
write(io,'(a)')'   program demo_rewind'
write(io,'(a)')'   implicit none'
write(io,'(a)')'   character(len=256) :: line'
write(io,'(a)')'   character(len=256) :: mssge'
write(io,'(a)')'   integer            :: i'
write(io,'(a)')'   integer            :: ios'
write(io,'(a)')'      open(10,name=''demo_rewind.txt'') ! open a file'
write(io,'(a)')'      do i=1,100                         ! write lines to it'
write(io,'(a)')'         write(10,''(a,i0)'') ''line '',i'
write(io,'(a)')'      enddo'
write(io,'(a)')'      rewind(10, iostat=ios,iomsg=mssge)'
write(io,'(a)')'      if(ios.ne.0)then'
write(io,'(a)')'         write(*,*)''*error* '',trim(mssge)'
write(io,'(a)')'      endif'
write(io,'(a)')'      write(*,*)''wrote 100 lines, but now at line ...'''
write(io,'(a)')'      read(10,''(a)'')line'
write(io,'(a)')'      write(*,''(a)''line'
write(io,'(a)')'      read(10)'
write(io,'(a)')'      read(10)'
write(io,'(a)')'      read(10)'
write(io,'(a)')'      write(*,*)''skipped a few lines, now at ...'''
write(io,'(a)')'      read(10,''(a)'')line'
write(io,'(a)')'      write(*,''(a)''line'
write(io,'(a)')'      close(10,=''delete'')'
write(io,'(a)')'   end program demo_backspace'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'   BACKSPACE(7f) - [FORTRAN:FILE_POSITIONING] - backspace one record on specified I/O unit'
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'   BACKSPACE file-unit-number'
write(io,'(a)')'   BACKSPACE ([UNIT=]file-unit-number][,IOMSG=iomsg-variable][,IOSTAT=scalar-int-variable][,ERR=label])'
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   Execution of a BACKSPACE statement causes the file connected to the'
write(io,'(a)')'   specified unit to be positioned before the current record if there is a'
write(io,'(a)')'   current record, or before the preceding record if there is no current'
write(io,'(a)')'   record. If the file is at its initial point, the position of the file is'
write(io,'(a)')'   not changed.'
write(io,'(a)')''
write(io,'(a)')'   It is usually used when a program has partially read a line and then wants'
write(io,'(a)')'   to go back and reread the line using the information from the first read.'
write(io,'(a)')'   Backspacing can be very inefficient (Note that positioning to specific'
write(io,'(a)')'   records in direct access files is typically much faster). It is usually'
write(io,'(a)')'   better to read the line into a CHARACTER variable and then read from the'
write(io,'(a)')'   variable multiple times using an internal READ, or parsing the string.'
write(io,'(a)')''
write(io,'(a)')'   Backspacing over records written using list-directed or namelist formatting'
write(io,'(a)')'   is prohibited. It will usually work, but since the compiler is free to'
write(io,'(a)')'   write list-directed or namelist output on a varying number of lines it is'
write(io,'(a)')'   not supported, as it is not certain what data is on which line.'
write(io,'(a)')''
write(io,'(a)')'   Backspacing a file that is connected but does not exist is prohibited.'
write(io,'(a)')''
write(io,'(a)')'   If a BACKSPACE statement causes the implicit writing of an endfile record,'
write(io,'(a)')'   the file is positioned before the record that precedes the endfile record.'
write(io,'(a)')''
write(io,'(a)')'   If the preceding record is an endfile record, the file is positioned before'
write(io,'(a)')'   the endfile record.'
write(io,'(a)')''
write(io,'(a)')'OPTIONS'
write(io,'(a)')'   UNIT     unit number of file to backspace one line on.'
write(io,'(a)')'            A unit open for direct access or unformatted access cannot'
write(io,'(a)')'            be referenced by a BACKSPACE.'
write(io,'(a)')'   IOSTAT   a compiler-specific number that indicates an error occurred'
write(io,'(a)')'            if non-zero.'
write(io,'(a)')'   IOMSG    a message describing error IOSTAT if IOSTAT is not zero.'
write(io,'(a)')'   ERR      a label number to jump to if an error occurs'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'  An example of a BACKSPACE statement is:'
write(io,'(a)')''
write(io,'(a)')'   program demo_backspace'
write(io,'(a)')'   implicit none'
write(io,'(a)')'   character(len=256) :: line'
write(io,'(a)')'   character(len=256) :: mssge'
write(io,'(a)')'   integer            :: i'
write(io,'(a)')'   integer            :: ios'
write(io,'(a)')'      open(10,file=''demo_backspace.txt'') ! open a file'
write(io,'(a)')'      do i=1,100                         ! write lines to it'
write(io,'(a)')'         write(10,''(a,i0)'') ''line '',i'
write(io,'(a)')'      enddo'
write(io,'(a)')'      do i=1,10                          ! back up several lines'
write(io,'(a)')'         backspace(10, iostat=ios,iomsg=mssge)'
write(io,'(a)')'         if(ios.ne.0)then'
write(io,'(a)')'                 write(*,''(*(a))'') ''*demo_backspace* ERROR:'',mssge'
write(io,'(a)')'         endif'
write(io,'(a)')'      enddo'
write(io,'(a)')'      read(10,''(a)'')line'
write(io,'(a)')'      write(*,*)''back at a previous record !'''
write(io,'(a)')'      write(*,''(1x,a)'')line'
write(io,'(a)')'      !! writing new line will truncate file to current record position'
write(io,'(a)')'      close(10,status=''delete'')'
write(io,'(a)')'   end program demo_backspace'
write(io,'(a)')''
write(io,'(a)')'  Expected Results:'
write(io,'(a)')''
write(io,'(a)')'    back at a previous record !'
write(io,'(a)')'    line 91'
write(io,'(a)')'.\" Specification of Fortran'
write(io,'(a)')'.TH DO "7" "January 2017" "Fortran" "Language Specification"'
write(io,'(a)')'.SH NAME'
write(io,'(a)')'   DO(7f) - [FORTRAN:EXECUTION CONTROL] construct'
write(io,'(a)')'.SH SYNOPSIS'
write(io,'(a)')'.nf'
write(io,'(a)')'!-----------------------------------------------------------------------'
write(io,'(a)')'   MYLOOP: do I_MYLOOP=1,10  ! DO loop'
write(io,'(a)')'      cycle MYLOOP           ! start next pass of loop'
write(io,'(a)')'      exit  MYLOOP           ! go to next statement after corresponding ENDDO'
write(io,'(a)')'   enddo MYLOOP'
write(io,'(a)')'!-----------------------------------------------------------------------'
write(io,'(a)')'   READ (IUN, ''(1X, G14.7)'', IOSTAT = IOS) X'
write(io,'(a)')'   DO WHILE (IOS == 0)'
write(io,'(a)')'      IF (X >= 0.) THEN'
write(io,'(a)')'         CALL SUBA (X)'
write(io,'(a)')'         CALL SUBB (X)'
write(io,'(a)')'              ...'
write(io,'(a)')'         CALL SUBZ (X)'
write(io,'(a)')'      ENDIF'
write(io,'(a)')'      READ (IUN, ''(1X, G14.7)'', IOSTAT = IOS) X'
write(io,'(a)')'   END DO'
write(io,'(a)')'!-----------------------------------------------------------------------'
write(io,'(a)')'.fi'
write(io,'(a)')''
write(io,'(a)')'.SH DESCRIPTION'
write(io,'(a)')'.nf'
write(io,'(a)')'  8.1.7     DO construct'
write(io,'(a)')'  8.1.7.1    Purpose and form of the DO construct'
write(io,'(a)')''
write(io,'(a)')'1 The DO construct specifies the repeated execution of a sequence of'
write(io,'(a)')'  executable constructs. Such a repeated sequence is called a loop.'
write(io,'(a)')''
write(io,'(a)')'2 The number of iterations of a loop may be determined at the beginning'
write(io,'(a)')'  of execution of the DO construct, or'
write(io,'(a)')'  may be left indefinite ("DO forever" or DO WHILE). Except in the case'
write(io,'(a)')'  of a DO CONCURRENT construct, the loop can be terminated immediately'
write(io,'(a)')'  (8.1.7.6.4). The current iteration of the loop may be curtailed by'
write(io,'(a)')'  executing a CYCLE statement (8.1.7.6.3).'
write(io,'(a)')''
write(io,'(a)')'3 There are three phases in the execution of a DO construct: initiation'
write(io,'(a)')'  of the loop, execution of the loop range,'
write(io,'(a)')'  and termination of the loop.'
write(io,'(a)')''
write(io,'(a)')'4 The DO CONCURRENT construct is a DO construct whose DO statement'
write(io,'(a)')'  contains the CONCURRENT keyword.'
write(io,'(a)')''
write(io,'(a)')'5 The DO construct may be written in either a block form or a nonblock form.'
write(io,'(a)')''
write(io,'(a)')'  R821      do-construct                     is block-do-construct'
write(io,'(a)')'                                             or nonblock-do-construct'
write(io,'(a)')''
write(io,'(a)')'  8.1.7.2    Form of the block DO construct'
write(io,'(a)')''
write(io,'(a)')'  R822      block-do-construct               is   do-stmt'
write(io,'(a)')'                                                      do-block'
write(io,'(a)')'                                                      end-do'
write(io,'(a)')''
write(io,'(a)')'  R823      do-stmt                          is label-do-stmt'
write(io,'(a)')'                                             or nonlabel-do-stmt'
write(io,'(a)')''
write(io,'(a)')'  R824      label-do-stmt                    is   [ do-construct-name : ] DO label [ loop-control ]'
write(io,'(a)')''
write(io,'(a)')'  R825      nonlabel-do-stmt                 is   [ do-construct-name : ] DO [ loop-control ]'
write(io,'(a)')''
write(io,'(a)')'  R826      loop-control                     is [ , ] do-variable = scalar-int-expr , scalar-int-expr'
write(io,'(a)')'                                                   [ , scalar-int-expr ]'
write(io,'(a)')'                                             or [ , ] WHILE ( scalar-logical-expr )'
write(io,'(a)')'                                             or [ , ] CONCURRENT forall-header'
write(io,'(a)')''
write(io,'(a)')'  R827      do-variable                      is   scalar-int-variable-name'
write(io,'(a)')''
write(io,'(a)')'  C816      (R827) The do-variable shall be a variable of type integer.'
write(io,'(a)')''
write(io,'(a)')'  R828      do-block                         is   block'
write(io,'(a)')''
write(io,'(a)')'  R829      end-do                           is end-do-stmt'
write(io,'(a)')'                                             or continue-stmt'
write(io,'(a)')''
write(io,'(a)')'  R830      end-do-stmt                      is   END DO [ do-construct-name ]'
write(io,'(a)')''
write(io,'(a)')'  C817      (R822) If the do-stmt of a block-do-construct specifies a'
write(io,'(a)')'            do-construct-name, the corresponding end-do'
write(io,'(a)')'            shall be an end-do-stmt specifying the same'
write(io,'(a)')'            do-construct-name. If the do-stmt of a block-do-construct'
write(io,'(a)')'            does not specify a do-construct-name, the corresponding'
write(io,'(a)')'            end-do shall not specify a do-construct-name.'
write(io,'(a)')''
write(io,'(a)')'  C818      (R822) If the do-stmt is a nonlabel-do-stmt, the corresponding'
write(io,'(a)')'            end-do shall be an end-do-stmt.'
write(io,'(a)')''
write(io,'(a)')'  C819      (R822) If the do-stmt is a label-do-stmt, the corresponding'
write(io,'(a)')'             end-do shall be identified with the same label .'
write(io,'(a)')''
write(io,'(a)')'  8.1.7.3    Form of the nonblock DO construct'
write(io,'(a)')'  R831      nonblock-do-construct            is   action-term-do-construct'
write(io,'(a)')'                                             or   outer-shared-do-construct'
write(io,'(a)')''
write(io,'(a)')'  R832      action-term-do-construct         is   label-do-stmt'
write(io,'(a)')'                                                        do-body'
write(io,'(a)')'                                                        do-term-action-stmt'
write(io,'(a)')''
write(io,'(a)')'  R833      do-body                          is   [ execution-part-construct ] ...'
write(io,'(a)')''
write(io,'(a)')'  R834      do-term-action-stmt              is   action-stmt'
write(io,'(a)')''
write(io,'(a)')'  C820      (R834) A do-term-action-stmt shall not be an allstop-stmt,'
write(io,'(a)')'             arithmetic-if-stmt,'
write(io,'(a)')'             continue-stmt, cycle-stmt, end-function-stmt,'
write(io,'(a)')'             end-mp-subprogram-stmt, end-program-stmt,'
write(io,'(a)')'             end-subroutine-stmt, exit-stmt, goto-stmt, return-stmt,'
write(io,'(a)')'             or stop-stmt.'
write(io,'(a)')''
write(io,'(a)')'    C821      (R831) The do-term-action-stmt shall be identified with'
write(io,'(a)')'              a label and the corresponding'
write(io,'(a)')'              label-do-stmt shall refer to the same label.'
write(io,'(a)')''
write(io,'(a)')'    R835      outer-shared-do-construct          is   label-do-stmt'
write(io,'(a)')'                                                            do-body'
write(io,'(a)')'                                                            shared-term-do-construct'
write(io,'(a)')''
write(io,'(a)')'    R836      shared-term-do-construct           is   outer-shared-do-construct'
write(io,'(a)')'                                                 or   inner-shared-do-construct'
write(io,'(a)')''
write(io,'(a)')'    R837      inner-shared-do-construct          is   label-do-stmt'
write(io,'(a)')'                                                            do-body'
write(io,'(a)')'                                                            do-term-shared-stmt'
write(io,'(a)')''
write(io,'(a)')'    R838      do-term-shared-stmt                is   action-stmt'
write(io,'(a)')''
write(io,'(a)')'    C822      (R838) A do-term-shared-stmt shall not be an allstop-stmt,'
write(io,'(a)')'              arithmetic-if-stmt,'
write(io,'(a)')'              cycle-stmt, end-function-stmt, end-program-stmt,'
write(io,'(a)')'              end-mp-subprogram-stmt, end-subroutine-stmt, exit-stmt,'
write(io,'(a)')'              goto-stmt, return-stmt, or stop-stmt.'
write(io,'(a)')''
write(io,'(a)')'    C823      (R836) The do-term-shared-stmt shall be identified with'
write(io,'(a)')'              a label and all of the label-do-stmts'
write(io,'(a)')'              of the inner-shared-do-construct and'
write(io,'(a)')'              outer-shared-do-construct shall refer to the same label.'
write(io,'(a)')''
write(io,'(a)')'1 The do-term-action-stmt, do-term-shared-stmt, or'
write(io,'(a)')'  shared-term-do-construct following the do-body of a nonblock DO'
write(io,'(a)')'  construct is called the DO termination of that construct.'
write(io,'(a)')''
write(io,'(a)')'2 Within a scoping unit, all DO constructs whose DO statements refer to'
write(io,'(a)')'  the same label are nonblock DO constructs, and share the'
write(io,'(a)')'  statement identified by that label.'
write(io,'(a)')''
write(io,'(a)')'    8.1.7.4      Range of the DO construct'
write(io,'(a)')''
write(io,'(a)')'1 The range of a block DO construct is the do-block , which shall satisfy'
write(io,'(a)')'  the rules for blocks (8.1.2). In particular,'
write(io,'(a)')'  transfer of control to the interior of such a block from outside the'
write(io,'(a)')'  block is prohibited. It is permitted to branch to the end-do of a'
write(io,'(a)')'  block DO construct only from within the range of that DO construct.'
write(io,'(a)')''
write(io,'(a)')'2 The range of a nonblock DO construct consists of the do-body and the'
write(io,'(a)')'  following DO termination. The end of such a range is not'
write(io,'(a)')'  bounded by a particular statement as for the other executable'
write(io,'(a)')'  constructs (e.g., END IF); nevertheless, the range satisfies the rules'
write(io,'(a)')'  for blocks (8.1.2). Transfer of control into the do-body or to the'
write(io,'(a)')'  DO termination from outside the range is prohibited; in particular,'
write(io,'(a)')'  it is permitted to branch to a do-term-shared-stmt only from within'
write(io,'(a)')'  the range of the corresponding inner-shared-do-construct.'
write(io,'(a)')''
write(io,'(a)')'    8.1.7.5      Active and inactive DO constructs'
write(io,'(a)')''
write(io,'(a)')'1 A DO construct is either active or inactive. Initially inactive,'
write(io,'(a)')'  a DO construct becomes active only when its'
write(io,'(a)')'  DO statement is executed.'
write(io,'(a)')''
write(io,'(a)')'2 Once active, the DO construct becomes inactive only when it terminates'
write(io,'(a)')'  (8.1.7.6.4).'
write(io,'(a)')''
write(io,'(a)')'    8.1.7.6      Execution of a DO construct'
write(io,'(a)')''
write(io,'(a)')'    8.1.7.6.1     Loop initiation'
write(io,'(a)')''
write(io,'(a)')'1 When the DO statement is executed, the DO construct becomes active. If loop-control is'
write(io,'(a)')''
write(io,'(a)')'2       [ , ] do-variable = scalar-int-expr 1 , scalar-int-expr 2 [ , scalar-int-expr 3 ]'
write(io,'(a)')''
write(io,'(a)')'3 the following steps are performed in sequence.'
write(io,'(a)')'          1.    The initial parameter m1 , the terminal parameter m2 ,'
write(io,'(a)')'                and the incrementation parameter m3 are'
write(io,'(a)')'                of type integer with the same kind type parameter'
write(io,'(a)')'                as the do-variable. Their values are established by'
write(io,'(a)')'                evaluating scalar-int-expr 1 , scalar-int-expr 2 , and'
write(io,'(a)')'                scalar-int-expr 3 , respectively, including, if necessary,'
write(io,'(a)')'                conversion to the kind type parameter of the'
write(io,'(a)')'                do-variable according to the rules for numeric conversion'
write(io,'(a)')'                (Table 7.11). If scalar-int-expr 3 does not appear,'
write(io,'(a)')'                m3 has the value 1. The value of m3'
write(io,'(a)')'                shall not be zero.'
write(io,'(a)')'          2.    The DO variable becomes defined with the value of the initial parameter m1 .'
write(io,'(a)')'          3.    The iteration count is established and is the value of'
write(io,'(a)')'                the expression (m2 - m1 + m3 )/m3 , unless that value is negative,'
write(io,'(a)')'                in which case the iteration count is 0.'
write(io,'(a)')''
write(io,'(a)')'        NOTE 8.11'
write(io,'(a)')'        The iteration count is zero whenever:'
write(io,'(a)')''
write(io,'(a)')'              m1 > m2 and m3 > 0, or'
write(io,'(a)')'              m1 < m2 and m3 < 0.'
write(io,'(a)')''
write(io,'(a)')'4 If loop-control is omitted, no iteration count is calculated. The'
write(io,'(a)')'  effect is as if a large positive iteration count,'
write(io,'(a)')'  impossible to decrement to zero, were established. If loop-control is'
write(io,'(a)')'  [ , ] WHILE (scalar-logical-expr ), the effect is as if loop-control'
write(io,'(a)')'  were omitted and the following statement inserted as the first statement'
write(io,'(a)')'  of the do-block :'
write(io,'(a)')''
write(io,'(a)')'5 IF (.NOT. (scalar- logical-expr )) EXIT'
write(io,'(a)')''
write(io,'(a)')'6 For a DO CONCURRENT construct, the values of the index variables for'
write(io,'(a)')'  the iterations of the construct are'
write(io,'(a)')'  determined by the rules for the index variables of the FORALL construct'
write(io,'(a)')'  (7.2.4.2.2 and 7.2.4.2.3).'
write(io,'(a)')''
write(io,'(a)')'7 An index-name in a DO CONCURRENT construct has a scope of the construct'
write(io,'(a)')'  (16.4). It is a scalar variable'
write(io,'(a)')'  that has the type and type parameters that it would have if it were'
write(io,'(a)')'  the name of a variable in the scoping unit that includes the construct,'
write(io,'(a)')'  and this type shall be integer type; it has no other attributes.'
write(io,'(a)')''
write(io,'(a)')'8 At the completion of the execution of the DO statement, the execution'
write(io,'(a)')'  cycle begins.'
write(io,'(a)')''
write(io,'(a)')'  8.1.7.6.2     The execution cycle'
write(io,'(a)')''
write(io,'(a)')'1 The execution cycle of a DO construct that is not a DO CONCURRENT'
write(io,'(a)')'  construct consists of the following steps performed in sequence'
write(io,'(a)')'  repeatedly until termination.'
write(io,'(a)')''
write(io,'(a)')'          1.    The iteration count, if any, is tested. If it is zero,'
write(io,'(a)')'                the loop terminates and the DO construct becomes'
write(io,'(a)')'                inactive. If loop-control is [ , ] WHILE'
write(io,'(a)')'                (scalar-logical-expr ), the scalar-logical-expr is'
write(io,'(a)')'                evaluated; if the value of this expression is false, the'
write(io,'(a)')'                loop terminates and the DO construct becomes inactive. If,'
write(io,'(a)')'                as a result, all of the DO constructs sharing the'
write(io,'(a)')'                do-term-shared-stmt are inactive, the execution of all'
write(io,'(a)')'                of these constructs is complete. However, if some of the'
write(io,'(a)')'                DO constructs sharing the do-term-shared-stmt are active,'
write(io,'(a)')'                execution continues with step (3) of the execution cycle'
write(io,'(a)')'                of the active DO construct whose DO statement was most'
write(io,'(a)')'                recently executed.'
write(io,'(a)')'          2.    The range of the loop is executed.'
write(io,'(a)')'          3.    The iteration count, if any, is decremented by one. The'
write(io,'(a)')'                DO variable, if any, is incremented by the'
write(io,'(a)')'                value of the incrementation parameter m3 .'
write(io,'(a)')''
write(io,'(a)')'  Except for the incrementation of the DO variable that occurs in step'
write(io,'(a)')'  (3), the DO variable shall neither be redefined'
write(io,'(a)')'  nor become undefined while the DO construct is active.'
write(io,'(a)')''
write(io,'(a)')'  The range of a DO CONCURRENT construct is executed for all of the'
write(io,'(a)')'  active combinations of the index-name'
write(io,'(a)')'  values. Each execution of the range is an iteration. The executions'
write(io,'(a)')'  may occur in any order.'
write(io,'(a)')''
write(io,'(a)')'  8.1.7.6.3     CYCLE statement'
write(io,'(a)')''
write(io,'(a)')'  Execution of the range of the loop may be curtailed by executing a'
write(io,'(a)')'  CYCLE statement from within the range of the loop.'
write(io,'(a)')''
write(io,'(a)')'  R839     cycle-stmt                         is   CYCLE [ do-construct-name ]'
write(io,'(a)')''
write(io,'(a)')'  C824     (R839) If a do-construct-name appears, the CYCLE statement'
write(io,'(a)')'           shall be within the range of that do-construct;'
write(io,'(a)')'           otherwise, it shall be within the range of at'
write(io,'(a)')'           least one do-construct.'
write(io,'(a)')''
write(io,'(a)')'  C825     (R839) A cycle-stmt shall not appear within the range of a'
write(io,'(a)')'           DO CONCURRENT construct if it belongs to an outer construct.'
write(io,'(a)')''
write(io,'(a)')'2 A CYCLE statement belongs to a particular DO construct. If the CYCLE'
write(io,'(a)')'  statement contains a DO construct name, it belongs to that DO construct;'
write(io,'(a)')'  otherwise, it belongs to the innermost DO construct in which it appears.'
write(io,'(a)')''
write(io,'(a)')'3 Execution of a CYCLE statement that belongs to a DO construct that is'
write(io,'(a)')'  not a DO CONCURRENT construct'
write(io,'(a)')'  causes immediate progression to step (3) of the current execution'
write(io,'(a)')'  cycle of the DO construct to which it belongs. If this construct is a'
write(io,'(a)')'  nonblock DO construct, the do-term-action-stmt or do-term-shared-stmt'
write(io,'(a)')'  is not executed.'
write(io,'(a)')''
write(io,'(a)')'4 Execution of a CYCLE statement that belongs to a DO CONCURRENT construct'
write(io,'(a)')'  completes execution of that iteration of the construct.'
write(io,'(a)')''
write(io,'(a)')'5 In a block DO construct, a transfer of control to the end-do has the'
write(io,'(a)')'  same effect as execution of a CYCLE statement'
write(io,'(a)')'  belonging to that construct. In a nonblock DO construct, transfer'
write(io,'(a)')'  of control to the do-term-action-stmt or do-term-shared-stmt causes'
write(io,'(a)')'  that statement to be executed. Unless a further transfer of control'
write(io,'(a)')'  results, step (3) of the current execution cycle of the DO construct'
write(io,'(a)')'  is then executed.'
write(io,'(a)')''
write(io,'(a)')'  8.1.7.6.4    Loop termination'
write(io,'(a)')''
write(io,'(a)')'1 For a DO construct that is not a DO CONCURRENT construct, the loop'
write(io,'(a)')'  terminates, and the DO construct becomes inactive, when any of the'
write(io,'(a)')'  following occurs.'
write(io,'(a)')''
write(io,'(a)')'        The iteration count is determined to be zero or the'
write(io,'(a)')'      scalar-logical-expr is false, when tested during step (1)'
write(io,'(a)')'        of the above execution cycle.'
write(io,'(a)')''
write(io,'(a)')'        An EXIT statement that belongs to the DO construct is executed.'
write(io,'(a)')''
write(io,'(a)')'        An EXIT or CYCLE statement that belongs to an outer construct'
write(io,'(a)')'      and is within the range of the DO'
write(io,'(a)')'        construct is executed.'
write(io,'(a)')''
write(io,'(a)')'        Control is transferred from a statement within the range of a'
write(io,'(a)')'        DO construct to a statement that is neither'
write(io,'(a)')'        the end-do nor within the range of the same DO construct.'
write(io,'(a)')''
write(io,'(a)')'        A RETURN statement within the range of the DO construct is executed.'
write(io,'(a)')''
write(io,'(a)')'2 For a DO CONCURRENT construct, the loop terminates, and the DO construct'
write(io,'(a)')'  becomes inactive when all of the iterations have completed execution.'
write(io,'(a)')''
write(io,'(a)')'3 When a DO construct becomes inactive, the DO variable, if any, of the'
write(io,'(a)')'  DO construct retains its last defined value.'
write(io,'(a)')''
write(io,'(a)')'  8.1.7.7     Restrictions on DO CONCURRENT constructs'
write(io,'(a)')''
write(io,'(a)')'  C826      A RETURN statement shall not appear within a DO CONCURRENT construct.'
write(io,'(a)')''
write(io,'(a)')'  C827      A branch (8.2) within a DO CONCURRENT construct shall not have a branch target that is outside'
write(io,'(a)')'            the construct.'
write(io,'(a)')''
write(io,'(a)')'  C828      A reference to a nonpure procedure shall not appear within a DO CONCURRENT construct.'
write(io,'(a)')''
write(io,'(a)')'  C829      A reference to the procedure IEEE GET FLAG, IEEE SET HALTING MODE, or IEEE GET HALT'
write(io,'(a)')'            ING MODE from the intrinsic module IEEE EXCEPTIONS, shall not appear within a DO CONCURRENT construct.'
write(io,'(a)')''
write(io,'(a)')'1 The following additional restrictions apply to DO CONCURRENT constructs.'
write(io,'(a)')''
write(io,'(a)')'      A variable that is referenced in an iteration shall either be'
write(io,'(a)')'      previously defined during that iteration, or shall not be defined'
write(io,'(a)')'      or become undefined during any other iteration of the current'
write(io,'(a)')'      execution of the construct. A variable that is defined or becomes'
write(io,'(a)')'      undefined by more than one iteration of the current execution of'
write(io,'(a)')'      the construct becomes undefined when the current execution of'
write(io,'(a)')'      the construct terminates. A pointer that is referenced in an'
write(io,'(a)')'      iteration either shall be previously pointer associated during'
write(io,'(a)')'      that iteration, or shall not have its pointer association changed'
write(io,'(a)')'      during any iteration. A pointer that has its pointer association'
write(io,'(a)')'      changed in more than one iteration has an association status of'
write(io,'(a)')'      undefined when the construct terminates.'
write(io,'(a)')''
write(io,'(a)')'     An allocatable object that is allocated in more than one iteration'
write(io,'(a)')'     shall be subsequently deallocated during the same iteration in which'
write(io,'(a)')'     it was allocated. An object that is allocated or deallocated in'
write(io,'(a)')'     only one iteration shall not be deallocated, allocated, referenced,'
write(io,'(a)')'     defined, or become undefined in a different iteration.'
write(io,'(a)')'     An input/output statement shall not write data to a file record or'
write(io,'(a)')'     position in one iteration and read from the same record or position'
write(io,'(a)')'     in a different iteration of the same execution of the construct.'
write(io,'(a)')'     Records written by output statements in the loop range to a'
write(io,'(a)')'     sequential access file appear in the file in an indeterminate order.'
write(io,'(a)')''
write(io,'(a)')'      NOTE 8.12'
write(io,'(a)')'      The restrictions on referencing variables defined in an iteration'
write(io,'(a)')'      of a DO CONCURRENT construct apply to any procedure invoked within'
write(io,'(a)')'      the loop.'
write(io,'(a)')''
write(io,'(a)')'      NOTE 8.13'
write(io,'(a)')'      The restrictions on the statements in the loop range of a DO'
write(io,'(a)')'      CONCURRENT construct are designed to ensure there are no data'
write(io,'(a)')'      dependencies between iterations of the loop. This permits code'
write(io,'(a)')'      optimizations that might otherwise be difficult or impossible'
write(io,'(a)')'      because they would depend on properties of the program not visible'
write(io,'(a)')'      to the compiler.'
write(io,'(a)')'.fi'
write(io,'(a)')'.SH EXAMPLES'
write(io,'(a)')'.nf'
write(io,'(a)')'8.1.7.8    Examples of DO constructs'
write(io,'(a)')''
write(io,'(a)')'      NOTE 8.14'
write(io,'(a)')'      The following program fragment computes a tensor product of two arrays:'
write(io,'(a)')''
write(io,'(a)')'      DO I = 1, M'
write(io,'(a)')'         DO J = 1, N'
write(io,'(a)')'            C (I, J) = DOT_PRODUCT (A (I, J, :), B(:, I, J))'
write(io,'(a)')'         END DO'
write(io,'(a)')'      END DO'
write(io,'(a)')''
write(io,'(a)')'      NOTE 8.15'
write(io,'(a)')'      The following program fragment contains a DO construct that uses the'
write(io,'(a)')'      WHILE form of loop-control . The loop will continue to execute until'
write(io,'(a)')'      an end-of-file or input/output error is encountered, at which point'
write(io,'(a)')'      the DO statement terminates the loop. When a negative value of X'
write(io,'(a)')'      is read, the program skips immediately to the next READ statement,'
write(io,'(a)')'      bypassing most of the range of the loop.'
write(io,'(a)')''
write(io,'(a)')'      READ (IUN, ''(1X, G14.7)'', IOSTAT = IOS) X'
write(io,'(a)')'      DO WHILE (IOS == 0)'
write(io,'(a)')'         IF (X >= 0.) THEN'
write(io,'(a)')'            CALL SUBA (X)'
write(io,'(a)')'            CALL SUBB (X)'
write(io,'(a)')'                 ...'
write(io,'(a)')'            CALL SUBZ (X)'
write(io,'(a)')'         ENDIF'
write(io,'(a)')'         READ (IUN, ''(1X, G14.7)'', IOSTAT = IOS) X'
write(io,'(a)')'      END DO'
write(io,'(a)')''
write(io,'(a)')'      NOTE 8.16'
write(io,'(a)')'      The following example behaves exactly the same as the one in Note'
write(io,'(a)')'      8.15. However, the READ statement has been moved to the interior'
write(io,'(a)')'      of the range, so that only one READ statement is needed. Also, a'
write(io,'(a)')'      CYCLE statement has been used to avoid an extra level of IF nesting.'
write(io,'(a)')''
write(io,'(a)')'      DO      ! A "DO WHILE + 1/2" loop'
write(io,'(a)')'          READ (IUN, ''(1X, G14.7)'', IOSTAT = IOS) X'
write(io,'(a)')'          IF (IOS /= 0) EXIT'
write(io,'(a)')'          IF (X < 0.) CYCLE'
write(io,'(a)')'          CALL SUBA (X)'
write(io,'(a)')'          CALL SUBB (X)'
write(io,'(a)')'             . . .'
write(io,'(a)')'          CALL SUBZ (X)'
write(io,'(a)')'       END DO'
write(io,'(a)')''
write(io,'(a)')'       NOTE 8.17'
write(io,'(a)')'       The following example represents a case in which the user knows'
write(io,'(a)')'       that there are no repeated values in the index array IND. The DO'
write(io,'(a)')'       CONCURRENT construct makes it easier for the processor to generate'
write(io,'(a)')'       vector gather/scatter code, unroll the loop, or parallelize the'
write(io,'(a)')'       code for this loop, potentially improving performance.'
write(io,'(a)')''
write(io,'(a)')'       INTEGER :: A(N),IND(N)'
write(io,'(a)')''
write(io,'(a)')'       DO CONCURRENT (I=1:M)'
write(io,'(a)')'          A(IND(I)) = I'
write(io,'(a)')'       END DO'
write(io,'(a)')''
write(io,'(a)')'       NOTE 8.18'
write(io,'(a)')'       Additional examples of DO constructs are in C.5.3.'
write(io,'(a)')'.fi'
write(io,'(a)')'.\" Specification of Fortran'
write(io,'(a)')'.TH EXIT "7" "January 2017" "Fortran" "Language Specification"'
write(io,'(a)')'.SH NAME'
write(io,'(a)')'   EXIT(7f) - [FORTRAN:EXECUTION CONTROL] statement'
write(io,'(a)')'.SH SYNOPSIS'
write(io,'(a)')'   EXIT [construct-name]'
write(io,'(a)')''
write(io,'(a)')'.SH DESCRIPTION'
write(io,'(a)')'.nf'
write(io,'(a)')'  The EXIT statement provides one way of terminating a loop, or completing'
write(io,'(a)')'  execution of another construct.'
write(io,'(a)')''
write(io,'(a)')'  If a construct-name appears, the EXIT statement shall be within that'
write(io,'(a)')'  construct; otherwise, it shall be within the range of at least one'
write(io,'(a)')'  do-construct.'
write(io,'(a)')''
write(io,'(a)')'  An EXIT statement belongs to a particular construct. If a construct'
write(io,'(a)')'  name appears, the EXIT statement belongs'
write(io,'(a)')'  to that construct; otherwise, it belongs to the innermost DO construct'
write(io,'(a)')'  in which it appears.'
write(io,'(a)')''
write(io,'(a)')'  An exit-stmt shall not belong to a DO CONCURRENT construct,'
write(io,'(a)')'  nor shall it appear within the range'
write(io,'(a)')'  of a DO CONCURRENT construct if it belongs to a construct'
write(io,'(a)')'  that contains that DO CONCURRENT construct.'
write(io,'(a)')''
write(io,'(a)')'  When an EXIT statement that belongs to a DO construct is executed,'
write(io,'(a)')'  it terminates the loop and'
write(io,'(a)')'  any active loops contained within the terminated loop. When an'
write(io,'(a)')'  EXIT statement that belongs to a non-DO construct is executed, it'
write(io,'(a)')'  terminates any active loops contained within that construct, and'
write(io,'(a)')'  completes execution of that construct.'
write(io,'(a)')'.fi'
write(io,'(a)')''
write(io,'(a)')'.SH EXAMPLES'
write(io,'(a)')''
write(io,'(a)')'.nf'
write(io,'(a)')'  Samples:'
write(io,'(a)')''
write(io,'(a)')'   do i=1,10'
write(io,'(a)')'      if(i.eq.4)exit ! exit loop'
write(io,'(a)')'   enddo'
write(io,'(a)')''
write(io,'(a)')'   do i=1,10'
write(io,'(a)')'      do j=100,200'
write(io,'(a)')'         if(j.eq.150)exit ! exit inner loop "j"'
write(io,'(a)')'      enddo'
write(io,'(a)')'   enddo'
write(io,'(a)')''
write(io,'(a)')'   OUTER: do i=1,10'
write(io,'(a)')'      INNER: do j=100,200'
write(io,'(a)')'         if(j.eq.150)exit OUTER ! exit named loop'
write(io,'(a)')'      enddo INNER'
write(io,'(a)')'   enddo OUTER'
write(io,'(a)')''
write(io,'(a)')'   MYBLOCK: block'
write(io,'(a)')'      big=.false.'
write(io,'(a)')'      do i=1,100'
write(io,'(a)')'        if(i=40)then'
write(io,'(a)')'          exit MYBLOCK'
write(io,'(a)')'        endif'
write(io,'(a)')'      enddo'
write(io,'(a)')'      big=.true.'
write(io,'(a)')'   endblock MYBLOCK'
write(io,'(a)')'.fi'
write(io,'(a)')''
write(io,'(a)')'.\" Specification of Fortran'
write(io,'(a)')'.TH BLOCK "7" "January 2017" "Fortran" "Language Specification"'
write(io,'(a)')'.SH NAME'
write(io,'(a)')'   BLOCK(7f) - [FORTRAN:EXECUTION CONTROL] construct'
write(io,'(a)')'.SH SYNOPSIS'
write(io,'(a)')'.nf'
write(io,'(a)')'  [ block-construct-name : ] BLOCK'
write(io,'(a)')'  [ specification-part ]'
write(io,'(a)')'  END[ ]BLOCK [ block-construct-name ]'
write(io,'(a)')'.fi'
write(io,'(a)')''
write(io,'(a)')'.SH DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'  The BLOCK construct is an executable construct which may contain'
write(io,'(a)')'  declarations, and may be exited using the EXIT statement.'
write(io,'(a)')''
write(io,'(a)')'  The specification-part of a BLOCK construct shall not contain a COMMON,'
write(io,'(a)')'  EQUIVALENCE, IMPLICIT, INTENT, NAMELIST, or OPTIONAL statement.'
write(io,'(a)')''
write(io,'(a)')'  A SAVE statement in a BLOCK construct shall not contain a'
write(io,'(a)')'  common-block-name.'
write(io,'(a)')''
write(io,'(a)')'  Except for the ASYNCHRONOUS and VOLATILE statements, specifications'
write(io,'(a)')'  in a BLOCK construct declare construct entities whose scope is that'
write(io,'(a)')'  of the BLOCK construct.'
write(io,'(a)')''
write(io,'(a)')'.SH EXAMPLES'
write(io,'(a)')''
write(io,'(a)')'  Sample programs:'
write(io,'(a)')''
write(io,'(a)')'.nf'
write(io,'(a)')'   program demo_block'
write(io,'(a)')'   implicit none'
write(io,'(a)')'   integer,parameter :: arr1(*)=[1,2,3,4,5,6,7]'
write(io,'(a)')'   integer,parameter :: arr2(*)=[0,1,2,3,4,5,6,7]'
write(io,'(a)')''
write(io,'(a)')'   call showme(arr1)'
write(io,'(a)')'   call showme(arr2)'
write(io,'(a)')''
write(io,'(a)')'   contains'
write(io,'(a)')''
write(io,'(a)')'   subroutine showme(a)'
write(io,'(a)')'   integer,intent(in) :: a(:)'
write(io,'(a)')'   integer :: i=-100'
write(io,'(a)')''
write(io,'(a)')'   TESTFORZERO: block'
write(io,'(a)')'      integer :: I  ! local block variable'
write(io,'(a)')'      do i=1,size(a)'
write(io,'(a)')'         if(a(i).eq.0) EXIT TESTFORZERO'
write(io,'(a)')'      enddo'
write(io,'(a)')'      write(*,*)''Never found a zero, tried '',i-1,'' times'''
write(io,'(a)')'      return'
write(io,'(a)')'   endblock TESTFORZERO'
write(io,'(a)')''
write(io,'(a)')'   ! note the variable I in the block is local to the block'
write(io,'(a)')'   write(*,*)''found a zero'', '' I='',i'
write(io,'(a)')'   end subroutine showme'
write(io,'(a)')''
write(io,'(a)')'   end program demo_block'
write(io,'(a)')''
write(io,'(a)')'  Results:'
write(io,'(a)')''
write(io,'(a)')'    Never found a zero, tried 7 times'
write(io,'(a)')'    found a zero I= -100'
write(io,'(a)')''
write(io,'(a)')'.fi'
write(io,'(a)')'NAME'
write(io,'(a)')'   flush(7f) - [FORTRAN:IO] flush I/O buffers of specified files'
write(io,'(a)')''
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'   flush file-unit-number'
write(io,'(a)')''
write(io,'(a)')'    or'
write(io,'(a)')''
write(io,'(a)')'   flush([UNIT=]file_unit_number,[iostat=i],[iomsg=string],[err=label_number])'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'  Because the Fortran standard does not specify the mechanism of file'
write(io,'(a)')'  storage, the exact meaning of the flush operation is not precisely'
write(io,'(a)')'  defined. The intention is that the flush operation should make all data'
write(io,'(a)')'  written to an external file available to other processes or devices,'
write(io,'(a)')'  or causes data placed in an external file by means other than the'
write(io,'(a)')'  current Fortran process to be available to a subsequent READ statement.'
write(io,'(a)')'  This is commonly called "flushing I/O buffers".'
write(io,'(a)')'  These actions are processor dependent.'
write(io,'(a)')''
write(io,'(a)')'  Execution of a FLUSH statement performs a wait operation for all'
write(io,'(a)')'  pending asynchronous data transfer operations for the specified unit.'
write(io,'(a)')''
write(io,'(a)')'  Execution of a FLUSH statement for a file that is connected but does'
write(io,'(a)')'  not exist is permitted and has no effect on any file. A FLUSH statement'
write(io,'(a)')'  has no effect on file position.'
write(io,'(a)')''
write(io,'(a)')'  No specifier shall appear more than once in a given flush-spec-list.'
write(io,'(a)')''
write(io,'(a)')'OPTIONS'
write(io,'(a)')''
write(io,'(a)')''
write(io,'(a)')'   [UNIT=]file-unit-number  Required. If the optional characters'
write(io,'(a)')'                            UNIT= are omitted from the unit specifier,'
write(io,'(a)')'                            the file-unit-number must be the first item.'
write(io,'(a)')''
write(io,'(a)')'   ERR=label                The label must branch to a target statement'
write(io,'(a)')'                            in the same scoping unit as the FLUSH'
write(io,'(a)')'                            statement.'
write(io,'(a)')'RETURNS'
write(io,'(a)')''
write(io,'(a)')'   IOSTAT=scalar-int-variable  variable is set to a processor-dependent'
write(io,'(a)')'                               positive value if an error occurs, to zero'
write(io,'(a)')'                               if the flush operation was successful, or'
write(io,'(a)')'                               to a processor-dependent negative value'
write(io,'(a)')'                               if the flush operation is not supported'
write(io,'(a)')'                               for the unit specified.'
write(io,'(a)')'   IOMSG=iomsg-variable    message describing any error that occurred'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'        flush (10, iostat = n)'
write(io,'(a)')'NAME'
write(io,'(a)')'   ASSOCIATE(7f) - [FORTRAN:EXECUTION CONTROL] associate construct'
write(io,'(a)')''
write(io,'(a)')'SYNTAX'
write(io,'(a)')'  [ associate-construct-name : ] ASSOCIATE ( associate-name => expr|variable, ...)'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'  Basically, ASSOCIATE allows you to'
write(io,'(a)')''
write(io,'(a)')'  1. create an alias for a variable'
write(io,'(a)')'  2. evaluate an expression at the top of the block and use a variable name'
write(io,'(a)')'     as a substitute for the constant, much like a parameter declaration.'
write(io,'(a)')''
write(io,'(a)')'  It is _NOT_ equivalent to a function macro.'
write(io,'(a)')''
write(io,'(a)')'  The ASSOCIATE construct associates named entities with expressions or'
write(io,'(a)')'  variables during the execution of its block. These "named construct'
write(io,'(a)')'  entities" (16.4) are "associating entities" (16.5.1.6). The names are'
write(io,'(a)')'  "associate names".'
write(io,'(a)')''
write(io,'(a)')'  o If selector is not a variable or is a variable that'
write(io,'(a)')'    has a vector subscript, associate-name shall not appear in'
write(io,'(a)')'    a variable definition context(16.6.7).'
write(io,'(a)')''
write(io,'(a)')'  o An associate-name shall not be the same as another'
write(io,'(a)')'    associate-name in the same associate-stmt.'
write(io,'(a)')''
write(io,'(a)')'  o variable shall not be a coindexed object.'
write(io,'(a)')''
write(io,'(a)')'  o expr shall not be a variable.'
write(io,'(a)')''
write(io,'(a)')'  o end-associate-stmt is END ASSOCIATE [ associate-construct-name ]'
write(io,'(a)')''
write(io,'(a)')'  o (R806) If the associate-stmt of an associate-construct'
write(io,'(a)')'    specifies an associate-construct-name, the'
write(io,'(a)')'    corresponding end-associate-stmt shall specify the'
write(io,'(a)')'    same associate-construct-name. If the associate-stmt'
write(io,'(a)')'    of an associate-construct does not specify an'
write(io,'(a)')'    associate-construct-name, the corresponding end-associate-stmt'
write(io,'(a)')'    shall not specify an associate-construct-name.'
write(io,'(a)')''
write(io,'(a)')'  EXECUTION OF THE ASSOCIATE CONSTRUCT'
write(io,'(a)')''
write(io,'(a)')'  Execution of an ASSOCIATE construct causes evaluation of every'
write(io,'(a)')'  expression within every selector that is a variable designator and'
write(io,'(a)')'  evaluation of every other selector , followed by execution of its'
write(io,'(a)')'  block. During execution of that block each associate name identifies an'
write(io,'(a)')'  entity which is associated (16.5.1.6) with the corresponding selector.'
write(io,'(a)')'  The associating entity assumes the declared type and type parameters'
write(io,'(a)')'  of the selector. If and only if the selector is polymorphic, the'
write(io,'(a)')'  associating entity is polymorphic.'
write(io,'(a)')''
write(io,'(a)')'  It is permissible to branch to an end-associate-stmt only from within'
write(io,'(a)')'  its ASSOCIATE construct.'
write(io,'(a)')''
write(io,'(a)')'  ATTRIBUTES OF ASSOCIATE NAMES'
write(io,'(a)')''
write(io,'(a)')'  Within an ASSOCIATE or SELECT TYPE construct, each associating entity'
write(io,'(a)')'  has the same rank and corank as its associated selector. The lower'
write(io,'(a)')'  bound of each dimension is the result of the intrinsic function LBOUND'
write(io,'(a)')'  (13.7.90) applied to the corresponding dimension of selector . The upper'
write(io,'(a)')'  bound of each dimension is one less than the sum of the lower bound'
write(io,'(a)')'  and the extent. The cobounds of each codimension of the associating'
write(io,'(a)')'  entity are the same as those of the selector. The associating entity'
write(io,'(a)')'  has the ASYNCHRONOUS or VOLATILE attribute if and only if the selector'
write(io,'(a)')'  is a variable and has the attribute. The associating entity has the'
write(io,'(a)')'  TARGET attribute if and only if the selector is a variable and has'
write(io,'(a)')'  either the TARGET or POINTER attribute. If the associating entity is'
write(io,'(a)')'  polymorphic, it assumes the dynamic type and type parameter values of'
write(io,'(a)')'  the selector. If the selector has the OPTIONAL attribute, it shall'
write(io,'(a)')'  be present. The associating entity is contiguous if and only if the'
write(io,'(a)')'  selector is contiguous.'
write(io,'(a)')''
write(io,'(a)')'  If the selector is not permitted to appear in a variable definition'
write(io,'(a)')'  context (16.6.7), the associate name shall not appear in a variable'
write(io,'(a)')'  definition context.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLES'
write(io,'(a)')''
write(io,'(a)')'  The following example illustrates an association with an expression.'
write(io,'(a)')''
write(io,'(a)')'       associate ( z => exp(-(x**2+y**2)) * cos(theta) )'
write(io,'(a)')'         print *, a+z, a-z'
write(io,'(a)')'       end associate'
write(io,'(a)')''
write(io,'(a)')'  The following example illustrates an association with a'
write(io,'(a)')'  derived-type variable.'
write(io,'(a)')''
write(io,'(a)')'       associate ( xc => ax%b(i,j)%c )'
write(io,'(a)')'         xc%dv = xc%dv + product(xc%ev(1:n))'
write(io,'(a)')'       end associate'
write(io,'(a)')''
write(io,'(a)')'  The following example illustrates association with an array section.'
write(io,'(a)')''
write(io,'(a)')'       associate ( array => ax%b(i,:)%c )'
write(io,'(a)')'         array(n)%ev = array(n-1)%ev'
write(io,'(a)')'       end associate'
write(io,'(a)')''
write(io,'(a)')'  The following example illustrates multiple associations.'
write(io,'(a)')''
write(io,'(a)')'       associate ( w => result(i,j)%w, zx => ax%b(i,j)%d, zy => ay%b(i,j)%d )'
write(io,'(a)')'         w = zx*x + zy*y'
write(io,'(a)')'       end associate'
write(io,'(a)')''
write(io,'(a)')'   The following example uses the ASSOCIATE construct as a shorthand for a'
write(io,'(a)')'   complex expression and renames an existing variable, MYREAL. After the'
write(io,'(a)')'   end of the ASSOCIATE construct, any change within the construct to the'
write(io,'(a)')'   value of the associating entity that associates with MYREAL is reflected.'
write(io,'(a)')''
write(io,'(a)')'      program demo_associate'
write(io,'(a)')'      real :: myreal, x, y, theta, a'
write(io,'(a)')'      x = 0.42'
write(io,'(a)')'      y = 0.35'
write(io,'(a)')'      myreal = 9.1'
write(io,'(a)')'      theta = 1.5'
write(io,'(a)')'      a = 0.4'
write(io,'(a)')'      associate ( z => exp(-(x**2+y**2)) * cos(theta), v => myreal)'
write(io,'(a)')'         print *, a+z, a-z, v'
write(io,'(a)')'         v = v * 4.6'
write(io,'(a)')'      end associate'
write(io,'(a)')'      print *, myreal'
write(io,'(a)')'      end program demo_associate'
write(io,'(a)')''
write(io,'(a)')'  See if you know what the following produces ...'
write(io,'(a)')''
write(io,'(a)')'      program dustycorner'
write(io,'(a)')'      implicit none'
write(io,'(a)')'      real :: a = 42'
write(io,'(a)')'      associate (a => a, b => 2 * a)'
write(io,'(a)')'         print *, a, b'
write(io,'(a)')'         a = 0'
write(io,'(a)')'         print *, a, b'
write(io,'(a)')'      end associate'
write(io,'(a)')'      print *, a'
write(io,'(a)')''
write(io,'(a)')'      a=42'
write(io,'(a)')'      associate (aa => a, b => 2 * a)'
write(io,'(a)')'         print *, a, aa, b'
write(io,'(a)')'         aa = 0'
write(io,'(a)')'         print *, a, aa, b'
write(io,'(a)')'         a=-1'
write(io,'(a)')'         print *, a, aa, b'
write(io,'(a)')'      end associate'
write(io,'(a)')'      print *, a'
write(io,'(a)')'      end program dustycorner'
write(io,'(a)')''
write(io,'(a)')'  Did you expect the following?'
write(io,'(a)')''
write(io,'(a)')'      42.0000000       84.0000000'
write(io,'(a)')'      0.00000000       84.0000000'
write(io,'(a)')'      0.00000000'
write(io,'(a)')'      42.0000000       42.0000000       84.0000000'
write(io,'(a)')'      0.00000000       0.00000000       84.0000000'
write(io,'(a)')'     -1.00000000      -1.00000000       84.0000000'
write(io,'(a)')'     -1.00000000'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'   protected(3f) - [FORTRAN:SPECIFICATION ATTRIBUTE] protect use associated module objects from change outside of t'
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'   module ANY_MODULE'
write(io,'(a)')'   specification, PROTECTED :: variable_declaration'
write(io,'(a)')'   end module ANY_MODULE'
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')'   The PROTECTED attribute imposes limitations on the usage of module'
write(io,'(a)')'   entities.'
write(io,'(a)')''
write(io,'(a)')'   The PROTECTED attribute shall be specified only in the specification'
write(io,'(a)')'   part of a module.'
write(io,'(a)')''
write(io,'(a)')'   An entity with the PROTECTED attribute shall be a procedure pointer'
write(io,'(a)')'   or variable.'
write(io,'(a)')''
write(io,'(a)')'   An entity with the PROTECTED attribute shall not be in a common block.'
write(io,'(a)')''
write(io,'(a)')'   A nonpointer object that has the PROTECTED attribute and is accessed'
write(io,'(a)')'   by use association shall not appear in a variable definition context'
write(io,'(a)')'   or as the data-target or proc-target in a pointer-assignment-'
write(io,'(a)')'   stmt.'
write(io,'(a)')''
write(io,'(a)')'   A pointer that has the PROTECTED attribute and is accessed by use'
write(io,'(a)')'   association shall not appear in a pointer association context'
write(io,'(a)')''
write(io,'(a)')'   Other than within the module in which an entity is given the PROTECTED'
write(io,'(a)')'   attribute, or within any of its descendants,'
write(io,'(a)')''
write(io,'(a)')'   * if it is a nonpointer object, it is not definable, and'
write(io,'(a)')'   *  if it is a pointer, its association status shall not be changed'
write(io,'(a)')'     except that it may become undefined if its target'
write(io,'(a)')'     is deallocated other than through the pointer or if its'
write(io,'(a)')'     target becomes undefined by execution of a RETURN or END statement.'
write(io,'(a)')''
write(io,'(a)')'   If an object has the PROTECTED attribute, all of its subobjects have'
write(io,'(a)')'   the PROTECTED attribute.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'  An example of the PROTECTED attribute:'
write(io,'(a)')''
write(io,'(a)')'   module temperature'
write(io,'(a)')'      real, protected :: temp_c, temp_f'
write(io,'(a)')'   contains'
write(io,'(a)')'      subroutine set_temperature_c(c)'
write(io,'(a)')'      real, intent(in) :: c'
write(io,'(a)')'         temp_c = c'
write(io,'(a)')'         temp_f = temp_c*(9.0/5.0) + 32'
write(io,'(a)')'      end subroutine'
write(io,'(a)')'   end module'
write(io,'(a)')''
write(io,'(a)')'   The PROTECTED attribute ensures that the variables temp_c and temp_f'
write(io,'(a)')'   cannot be modified other than via the set_temperature_c procedure,'
write(io,'(a)')'   thus keeping them consistent with each other.'
write(io,'(a)')'NAME'
write(io,'(a)')'     if(7f) - [FORTRAN:EXECUTION CONTROL] selects a block based on a sequence of logical expressions.'
write(io,'(a)')''
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')''
write(io,'(a)')'     [if_construct_name:] IF (scalar-logical-expr) THEN'
write(io,'(a)')'        block'
write(io,'(a)')'     ELSEIF (scalar-logical-expr) THEN [if_construct_name]'
write(io,'(a)')'        block'
write(io,'(a)')'     ELSE [if_construct_name]'
write(io,'(a)')'        block'
write(io,'(a)')'     ENDIF [if_construct_name]'
write(io,'(a)')''
write(io,'(a)')'        or'
write(io,'(a)')''
write(io,'(a)')'     IF (scalar-logical-expression) action-statement'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   The IF construct selects for execution at most one of its constituent'
write(io,'(a)')'   blocks. The selection is based on a sequence of logical expressions.'
write(io,'(a)')''
write(io,'(a)')'   If an if-construct-name is specified, both the IF and ENDIF must use'
write(io,'(a)')'   that same name. If an ELSE or ELSEIF uses an if-construct-name it must'
write(io,'(a)')'   be the same as the one specified on the corresponding IF/ENDIF.'
write(io,'(a)')''
write(io,'(a)')'   Execution of an IF construct'
write(io,'(a)')''
write(io,'(a)')'   At most one of the blocks in the IF construct is executed. If there'
write(io,'(a)')'   is an ELSE statement in the construct, exactly one of the blocks'
write(io,'(a)')'   in the construct is executed. The scalar logical expressions are'
write(io,'(a)')'   evaluated in the order of their appearance in the construct until'
write(io,'(a)')'   a true value is found or an ELSE statement or ENDIF statement is'
write(io,'(a)')'   encountered. If a true value or an ELSE statement is found, the block'
write(io,'(a)')'   immediately following is executed and this completes the execution'
write(io,'(a)')'   of the construct. The scalar logical expressions in any remaining'
write(io,'(a)')'   ELSEIF statements of the IF construct are not evaluated. If none'
write(io,'(a)')'   of the evaluated expressions is true and there is no ELSE statement,'
write(io,'(a)')'   the execution of the construct is completed without the execution of'
write(io,'(a)')'   any block within the construct.'
write(io,'(a)')''
write(io,'(a)')'   It is permissible to branch to an ENDIF statement only from within'
write(io,'(a)')'   its IF construct. Execution of an ENDIF statement has no effect.'
write(io,'(a)')''
write(io,'(a)')'   Execution of an IF statement'
write(io,'(a)')''
write(io,'(a)')'   The IF statement controls the execution of a single action statement'
write(io,'(a)')'   based on a single logical expression.'
write(io,'(a)')''
write(io,'(a)')'   The action-stmt in the if-stmt shall not be an end-function-stmt,'
write(io,'(a)')'   end-mp-subprogram-stmt, end-program-stmt, end-subroutine-stmt,'
write(io,'(a)')'   or if-stmt.'
write(io,'(a)')''
write(io,'(a)')'   Execution of an IF statement causes evaluation of the scalar logical'
write(io,'(a)')'   expression. If the value of the expression is true, the action statement'
write(io,'(a)')'   is executed. If the value is false, the action statement is not executed'
write(io,'(a)')'   and execution continues.'
write(io,'(a)')''
write(io,'(a)')'   The execution of a function reference in the scalar logical expression'
write(io,'(a)')'   may affect entities in the action statement.'
write(io,'(a)')''
write(io,'(a)')'   An example of an IF statement is:'
write(io,'(a)')''
write(io,'(a)')'       IF (A > 0.0) A = LOG (A)'
write(io,'(a)')''
write(io,'(a)')'EXAMPLES'
write(io,'(a)')''
write(io,'(a)')'  Sample IF constructs:'
write(io,'(a)')''
write(io,'(a)')'     if (cvar == ''RESET'') then'
write(io,'(a)')'        i = 0; j = 0; k = 0'
write(io,'(a)')''
write(io,'(a)')'endif'
write(io,'(a)')''
write(io,'(a)')'     OUTER: if (case.eq.0)then'
write(io,'(a)')'        PROOF_DONE: if (PROP) then'
write(io,'(a)')'           write (3, ''(''''QED'''')'')'
write(io,'(a)')'           exit OUTER'
write(io,'(a)')'        else'
write(io,'(a)')'           PROP = nextprop'
write(io,'(a)')'        endif PROOF_DONE'
write(io,'(a)')'        write(*,*)''END OF PROOF_DONE'''
write(io,'(a)')'     else OUTER'
write(io,'(a)')'             write(*,*)''else outer'''
write(io,'(a)')'     endif OUTER'
write(io,'(a)')''
write(io,'(a)')'     if (a > 0) then'
write(io,'(a)')'        b = c/a'
write(io,'(a)')'        if (b > 0) then'
write(io,'(a)')'           d = 1.0'
write(io,'(a)')'        end if'
write(io,'(a)')'     elseif (c > 0) then'
write(io,'(a)')'        b = a/c'
write(io,'(a)')'        d = -1.0'
write(io,'(a)')'     else'
write(io,'(a)')'        b = abs (max (a, c))'
write(io,'(a)')'        d = 0'
write(io,'(a)')'     endif'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'   SAVE(7f) - [FORTRAN:STATEMENT:ATTRIBUTE] specifies that a local variable retains its status and value after a RE'
write(io,'(a)')''
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'   SAVE [ [ :: ] saved-entity-list ]'
write(io,'(a)')''
write(io,'(a)')'      saved-entity                 is object-name'
write(io,'(a)')'                                   or proc-pointer-name'
write(io,'(a)')'                                   or / common-block-name /'
write(io,'(a)')''
write(io,'(a)')'      proc-pointer-name            is   name'
write(io,'(a)')''
write(io,'(a)')'   or as an attribute of a data entity declaration. For example,'
write(io,'(a)')''
write(io,'(a)')'      INTEGER,SAVE :: II'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'1 The SAVE attribute specifies that a local variable of a program unit or subprogram retains its association status'
write(io,'(a)')'  allocation status, definition status, and value after execution of a RETURN or END statement unless it is a'
write(io,'(a)')'  pointer and its target becomes undefined. If it is a local variable of a subprogram it is shared by all'
write(io,'(a)')'  instances of the subprogram.'
write(io,'(a)')''
write(io,'(a)')'  An entity with the SAVE attribute shall be a common block, variable, or procedure pointer.'
write(io,'(a)')''
write(io,'(a)')'  The SAVE attribute shall not be specified for a dummy argument, a function result, an automatic data'
write(io,'(a)')'  object, or an object that is in a common block.'
write(io,'(a)')''
write(io,'(a)')'  If a SAVE statement with an omitted saved entity list appears in a scoping unit, no other'
write(io,'(a)')'  appearance of the SAVE attr-spec or SAVE statement is permitted in that scoping unit.'
write(io,'(a)')''
write(io,'(a)')'  A local variable of a pure subprogram, or of a BLOCK construct within'
write(io,'(a)')'  a pure subprogram, shall not have the SAVE attribute. Variable'
write(io,'(a)')'  initialization in a type-declaration-stmt or a data-stmt implies the'
write(io,'(a)')'  SAVE attribute; therefore, such initialization is also disallowed in'
write(io,'(a)')'  a pure subprogram.'
write(io,'(a)')''
write(io,'(a)')'2 The SAVE attribute specifies that a local variable of a BLOCK construct retains its association status, allocatio'
write(io,'(a)')'  status, definition status, and value after termination of the construct unless it is a pointer and its target bec'
write(io,'(a)')'  undefined (16.5.2.5(6)). If the BLOCK construct is within a subprogram the variable is shared by all instances'
write(io,'(a)')'  (12.6.2.4) of the subprogram.'
write(io,'(a)')''
write(io,'(a)')'3 Giving a common block the SAVE attribute confers the attribute on all entities in the common block.'
write(io,'(a)')''
write(io,'(a)')'4 A variable, common block, or procedure pointer declared in the scoping unit of a main program, module, or'
write(io,'(a)')'  submodule implicitly has the SAVE attribute, which may be confirmed by explicit specification. If a common'
write(io,'(a)')'  block has the SAVE attribute in any other kind of scoping unit, it shall have the SAVE attribute in every scoping'
write(io,'(a)')'  unit that is not a main program, module, or submodule.'
write(io,'(a)')''
write(io,'(a)')'SAVE ATTRIBUTE'
write(io,'(a)')''
write(io,'(a)')'1 A blank common block has the same properties as a named common block, except for the following.'
write(io,'(a)')''
write(io,'(a)')'      Execution of a RETURN or END statement might cause data objects'
write(io,'(a)')'      in a named common block to become'
write(io,'(a)')'      undefined unless the common block has the SAVE attribute, but'
write(io,'(a)')'      never causes data objects in blank common to become undefined.'
write(io,'(a)')''
write(io,'(a)')' 2 When the execution of a procedure is terminated by execution of a RETURN or END statement, an unsaved'
write(io,'(a)')'   allocatable local variable of the procedure retains its allocation and definition status if it is a function res'
write(io,'(a)')'   variable or a subobject thereof; otherwise, it is deallocated.'
write(io,'(a)')''
write(io,'(a)')' 3 When a BLOCK construct terminates, an unsaved allocatable local variable of the construct is deallocated.'
write(io,'(a)')''
write(io,'(a)')'1 A SAVE statement with a saved entity list specifies the SAVE attribute (5.3.16) for a list of entities. A SAVE'
write(io,'(a)')'  statement without a saved entity list is treated as though it contained the names of all allowed items in the sam'
write(io,'(a)')'  scoping unit.'
write(io,'(a)')''
write(io,'(a)')'3 Explicit initialization of a variable that is not in a common block implies the SAVE attribute, which may be'
write(io,'(a)')'   confirmed by explicit specification.'
write(io,'(a)')'3 The BIND attribute for a variable or common block implies the SAVE attribute, which may be confirmed by'
write(io,'(a)')'  explicit specification.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'   To assign the SAVE attribute to all local variables in a subprogram'
write(io,'(a)')''
write(io,'(a)')'    SAVE'
write(io,'(a)')''
write(io,'(a)')'   An example of a typical SAVE statement is:'
write(io,'(a)')''
write(io,'(a)')'    SAVE A, B, C, / BLOCKA /, D'
write(io,'(a)')''
write(io,'(a)')'   Example with an allocatable variable'
write(io,'(a)')''
write(io,'(a)')'    subroutine process'
write(io,'(a)')'      real, allocatable :: temp(:)'
write(io,'(a)')'      real, allocatable, save :: x(:)'
write(io,'(a)')'      ...'
write(io,'(a)')'    end subroutine process'
write(io,'(a)')''
write(io,'(a)')'   on return from subroutine PROCESS, the allocation status of X is'
write(io,'(a)')'   preserved because X has the SAVE attribute. TEMP does not have the'
write(io,'(a)')'   SAVE attribute, so it will be deallocated if it was allocated. On'
write(io,'(a)')'   the next invocation of PROCESS, TEMP will have an allocation status'
write(io,'(a)')'   of unallocated.'
write(io,'(a)')''
write(io,'(a)')'NAME'
write(io,'(a)')'   NULLIFY(7f) - [FORTRAN:STATEMENT] causes pointers to be disassociated'
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'  NULLIFY ( pointer-object-list )'
write(io,'(a)')''
write(io,'(a)')'   pointer-object               is variable-name'
write(io,'(a)')'                                or structure-component'
write(io,'(a)')'                                or proc-pointer-name'
write(io,'(a)')''
write(io,'(a)')'   Each pointer-object shall have the POINTER attribute.'
write(io,'(a)')''
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'  A pointer-object shall not depend on the value, bounds, or association status of another pointer-object in the'
write(io,'(a)')'  same NULLIFY statement.'
write(io,'(a)')''
write(io,'(a)')'  When a NULLIFY statement is applied to a polymorphic pointer, its dynamic type becomes the declared type.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')'NAME'
write(io,'(a)')'   IMPLICIT(7f) - [FORTRAN:STATEMENT]  specify default type (if any) associated to a starting letter'
write(io,'(a)')'SYNOPSIS'
write(io,'(a)')'    IMPLICIT [NONE]|[declaration-type-spec (letter-spec-list)]'
write(io,'(a)')'    determine default mapping between between the first letter of a data entity and a type.'
write(io,'(a)')'DESCRIPTION'
write(io,'(a)')''
write(io,'(a)')'   Every data entity has a type. If a type is not explicitly assigned to'
write(io,'(a)')'   a variable or function it will (by default) be assigned one according'
write(io,'(a)')'   to the following rule -- the type is INTEGER if the name starts with'
write(io,'(a)')'   the letters from I to N (the first two letters of the word "integer");'
write(io,'(a)')'   otherwise it defaults to REAL.'
write(io,'(a)')''
write(io,'(a)')'   The IMPLICIT statement allows the default rule to be changed or set'
write(io,'(a)')'   to null. To turn off implicit typing enter one and only one IMPLICIT'
write(io,'(a)')'   statement in the scoping unit'
write(io,'(a)')''
write(io,'(a)')'      implicit none ! Disable all implicit typing'
write(io,'(a)')''
write(io,'(a)')'   Each data entity will now require explicitly having a type declared'
write(io,'(a)')'   (INTEGER, REAL, DOUBLE, COMPLEX, ...).'
write(io,'(a)')''
write(io,'(a)')'   This must appear after any USE statements and before any type'
write(io,'(a)')'   declarations, including PARAMETER statements (which must know the'
write(io,'(a)')'   rules to determine what type names are that have not been explicitly'
write(io,'(a)')'   declared).'
write(io,'(a)')''
write(io,'(a)')'   In most new code implicit typing is turned off either with an "IMPLICIT'
write(io,'(a)')'   NONE" or sometimes by a compiler switch. On the other hand, the majority'
write(io,'(a)')'   of pre-fortran90 code depends on implicit defaults.'
write(io,'(a)')''
write(io,'(a)')'   Each prefix letter may have the type assigned to it declared only'
write(io,'(a)')'   once in a unit.'
write(io,'(a)')''
write(io,'(a)')'   The default rule, expressed as an IMPLICIT statement is'
write(io,'(a)')''
write(io,'(a)')'      implicit real(a-h,o-z),integer(i-k)'
write(io,'(a)')''
write(io,'(a)')'   To make the default for all names be a DOUBLEPRECISION type one could enter'
write(io,'(a)')''
write(io,'(a)')'      implicit doubleprecision (a-h,o-z)'
write(io,'(a)')''
write(io,'(a)')'   In another unit one might specify (multiple statements and compound'
write(io,'(a)')'   statements are allowed, as illustrated):'
write(io,'(a)')''
write(io,'(a)')'      implicit complex (c), doubleprecision (d)'
write(io,'(a)')'      implicit integer (i)'
write(io,'(a)')'      implicit logical (l)'
write(io,'(a)')'      implicit real (r)'
write(io,'(a)')'      implicit character(len=8) (a,b,e-h,j,k,m-q,s-z)'
write(io,'(a)')''
write(io,'(a)')'   There is no way to make some letters default to no type and others'
write(io,'(a)')'   have a default. Either nothing has a default type or everything does:'
write(io,'(a)')''
write(io,'(a)')'      implicit (a-h)  ! NOT ALLOWED. A TYPE MUST BE SPECIFIED'
write(io,'(a)')''
write(io,'(a)')'  The default for an internal or module procedure is the mapping in the'
write(io,'(a)')'  host scoping unit.'
write(io,'(a)')''
write(io,'(a)')'  Any data entity that is not explicitly declared by a type declaration'
write(io,'(a)')'  statement, is not an intrinsic function, and is not accessed by use or'
write(io,'(a)')'  host association is declared implicitly to be of the type (and type'
write(io,'(a)')'  parameters) mapped from the first letter of its name, provided the'
write(io,'(a)')'  mapping is not null.'
write(io,'(a)')''
write(io,'(a)')'  The mapping may be to a derived type that is inaccessible in the local'
write(io,'(a)')'  scope if the derived type is accessible in the host scoping unit. The'
write(io,'(a)')'  data entity is treated as if it were declared in an explicit type'
write(io,'(a)')'  declaration in the outermost scoping unit in which it appears. An'
write(io,'(a)')'  explicit type specification in a FUNCTION statement overrides'
write(io,'(a)')'  an IMPLICIT statement for the name of the result variable of that'
write(io,'(a)')'  function subprogram.'
write(io,'(a)')''
write(io,'(a)')'OPTIONS'
write(io,'(a)')'    NONE            If IMPLICIT NONE is specified in a scoping unit, it shall precede any PARAMETER statements'
write(io,'(a)')'                    that appear in the scoping unit and there shall be no other IMPLICIT statements in the scoping'
write(io,'(a)')'      or'
write(io,'(a)')'    declaration-type-spec'
write(io,'(a)')''
write(io,'(a)')'    letter-spec      is (letter-or-range[,letter-or-range] [,letter-or-range] )'
write(io,'(a)')'                     If the minus and second letter appear, the second'
write(io,'(a)')'                     letter shall follow the first letter alphabetically.'
write(io,'(a)')'                     A letter-spec consisting of two letter s separated by'
write(io,'(a)')'                     a minus is equivalent to writing a list containing'
write(io,'(a)')'                     all of the letters in alphabetical order in the'
write(io,'(a)')'                     alphabetic sequence from the first letter through'
write(io,'(a)')'                     the second letter. For example, A-C is equivalent'
write(io,'(a)')'                     to A, B, C. The same letter shall not appear as a'
write(io,'(a)')'                     single letter, or be included in a range of letters,'
write(io,'(a)')'                     more than once in all of the IMPLICIT statements'
write(io,'(a)')'                     in a scoping unit.'
write(io,'(a)')''
write(io,'(a)')'EXAMPLE'
write(io,'(a)')''
write(io,'(a)')'  The following are examples of the use of IMPLICIT statements:'
write(io,'(a)')''
write(io,'(a)')'        module example_module'
write(io,'(a)')'           implicit none'
write(io,'(a)')'           ...'
write(io,'(a)')'           interface'
write(io,'(a)')'              function fun (i)    ! not all data entities need to'
write(io,'(a)')'                 integer fun      ! be declared explicitly'
write(io,'(a)')'              end function fun'
write(io,'(a)')'           end interface'
write(io,'(a)')'        contains'
write(io,'(a)')'           function jfun (j)      ! all data entities need to'
write(io,'(a)')'              integer jfun, j     ! be declared explicitly.'
write(io,'(a)')'              ...'
write(io,'(a)')'           end function jfun'
write(io,'(a)')'        end module example_module'
write(io,'(a)')''
write(io,'(a)')'        subroutine sub'
write(io,'(a)')'           implicit complex (c)'
write(io,'(a)')'           CM = (3.0, 2.0)      ! CM is implicitly declared COMPLEX'
write(io,'(a)')'           ...'
write(io,'(a)')'        contains'
write(io,'(a)')'           subroutine sub1'
write(io,'(a)')'              IMPLICIT INTEGER (A, C)'
write(io,'(a)')'              C = (0.0, 0.0) ! C is host associated and of'
write(io,'(a)')'                             ! type complex'
write(io,'(a)')'              Z = 1.0        ! Z is implicitly declared REAL'
write(io,'(a)')'              A = 2          ! A is implicitly declared INTEGER'
write(io,'(a)')'              CC = 1         ! CC is implicitly declared INTEGER'
write(io,'(a)')'              ...'
write(io,'(a)')'           end subroutine sub1'
write(io,'(a)')'           subroutine sub2'
write(io,'(a)')'              Z = 2.0         ! Z is implicitly declared REAL and'
write(io,'(a)')'                              ! is different from the variable of'
write(io,'(a)')'                              ! the same name in SUB1'
write(io,'(a)')'              ...'
write(io,'(a)')'           end subroutine sub2'
write(io,'(a)')'           subroutine sub3'
write(io,'(a)')'              USE EXAMPLE_MODULE ! Accesses integer function FUN'
write(io,'(a)')'                                  ! by use association'
write(io,'(a)')'              Q = FUN (K)         ! Q is implicitly declared REAL and'
write(io,'(a)')'              ...                 ! K is implicitly declared INTEGER'
write(io,'(a)')'           end subroutine sub3'
write(io,'(a)')'        end subroutine sub'
write(io,'(a)')''
write(io,'(a)')'        The following is an example of a mapping to a derived type that is inaccessible in the local scope:'
write(io,'(a)')''
write(io,'(a)')'              program main'
write(io,'(a)')'                implicit type(blob) (a)'
write(io,'(a)')'                type blob'
write(io,'(a)')'                  integer :: i'
write(io,'(a)')'                end type blob'
write(io,'(a)')'                type(blob) :: b'
write(io,'(a)')'                call steve'
write(io,'(a)')'              contains'
write(io,'(a)')'                subroutine steve'
write(io,'(a)')'                  integer :: blob'
write(io,'(a)')'                  ..'
write(io,'(a)')'                  aa = b'
write(io,'(a)')'                  ..'
write(io,'(a)')'                end subroutine steve'
write(io,'(a)')'              end program main'
write(io,'(a)')''
write(io,'(a)')'        In the subroutine STEVE, it is not possible to explicitly declare a variable to be of type BLOB because'
write(io,'(a)')'        BLOB has been given a different meaning, but implicit mapping for the letter A still maps to type BLOB,'
write(io,'(a)')'        so AA is of type BLOB.'
write(io,'(a)')'.\" Specification of Fortran'
write(io,'(a)')'.TH CONTINUE "7" "January 2017" "Fortran" "Language Specification"'
write(io,'(a)')'.SH NAME'
write(io,'(a)')'   CONTINUE(7f) - [FORTRAN:EXECUTION CONTROL] construct'
write(io,'(a)')'.SH SYNOPSIS'
write(io,'(a)')'   continue'
write(io,'(a)')'.SH DESCRIPTION'
write(io,'(a)')'.nf'
write(io,'(a)')'  Execution of a CONTINUE statement has no effect. A CONTINUE statement'
write(io,'(a)')'  is most often used as a labeled line that is used in transfer control'
write(io,'(a)')'  statements to numerically labeled lines such as GOTO. It is often'
write(io,'(a)')'  very confusing to have executable statements on labeled lines; a'
write(io,'(a)')'  CONTINUE statement eliminates the ambiguities that arise in jumping'
write(io,'(a)')'  to an executable line. Preferably no target of a transfer should be an'
write(io,'(a)')'  executable statement, but should be a statement like ENDDO or CONTINUE.'
write(io,'(a)')''
write(io,'(a)')'  CONTINUE was very frequently used as the end of a DO loop; ENDDO'
write(io,'(a)')'  is now the proper way to end a DO loop.'
write(io,'(a)')'.fi'
write(io,'(a)')'.SH EXAMPLE'
write(io,'(a)')'.nf'
write(io,'(a)')'   program demo_continue'
write(io,'(a)')'         I=10'
write(io,'(a)')'         J=5'
write(io,'(a)')'         if(I.lt.5)goto 100'
write(io,'(a)')'         J=3'
write(io,'(a)')'   100   continue'
write(io,'(a)')'         write(*,*)''J='',J'
write(io,'(a)')''
write(io,'(a)')'   end program demo_continue'
write(io,'(a)')'.fi'
end program intrinsics_man_pages
