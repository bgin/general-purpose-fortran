<html> 
<head> 
<title> </title>
<style> 
p {font-family: "Lucida Console", Monaco, monospace}
body {xfont-style: italic}
body {
color:#333; font-family:Verdana, Arial, Helvetica, sans-serif; font-size:1em; line-height:1.3em; }
a:visited { color:#666; }
h1,h2,h3,h4,h5,h6 { color:#333; font-family:georgia, verdana, sans-serif; }
h1 { font-size:150%; page-break-before:auto;background-color: #aaaaff}
h2 { font-size:143%;color:teal; }
h3 { font-size:134%;color:blue; }
h4 { font-size:120%;color:gray; }
p{ padding: 0;margin:0; }
p{ padding-right:1.4em; }
p{ padding-bottom:1em; }
p{ padding-top:1em; }
p{ whitespace: pre-wrap; }
h5,h6 { font-size:100% }
a.nav,a:link.nav, a:visited.nav { background-color:#FFF; color:#000; }
XXtable { border:double #000; border-collapse:collapse; }
XXtable { border-collapse:collapse; }
XXtd { border:thin solid #888; }
XXtd { border:none; }
li { margin-bottom:0.5em; }
blockquote { display:block; font-size:90%; font-style:italic; line-height:1.1em; margin:0 0 1.5em; padding:0 2.5em; }
pre { background-color:#DDD; font-size:99%; overflow:auto; padding:1em; }
a,li span { color:#000; }
a:hover, a.nav:hover, a:hover math { background-color:#000; color:#FFF; }
#Container { margin:0 10px; text-align:center; background-color: #BBB}
#Content { border-top:none; margin:auto; padding:0.3em; text-align:left; width:100%; max-width:55em; background:#FFF}
span.webName { font-size:.5em; }
textarea#content { font-size: 1em; line-height: 1.125; }
h1#pageName { line-height:1em; margin:0.2em 0 0.2em 0; padding:0; }
.property { color:#666; font-size:80%; }
a.existingWikiWord[title]{ //border: 1px dashed #BBB; }
.byline { color:#666; font-size:.8em; font-style:italic; margin-bottom:1em; padding-top:1px; } 
</style> 
</head>
<BODY bgcolor=#F0F0F0 text=#000000 link=#0000ff vlink=#C000C0 alink=#ff0000><A NAME=top></A>
<h5><a href="download.html">[UP]</a></h5> 
<div id="Container">
<div id="Content">
<CENTER>
<H1><HR><I>Manual Reference Pages &nbsp;-&nbsp;</I><NOBR>namelist (7)</NOBR><HR></H1>
</CENTER>
<P>
<A name=0>

     <H3>NAME</H3>

</A>
<BLOCKQUOTE>
<B>NAMELIST(7f) </B>- [FORTRAN:STATEMENT] specify a group of data to be referred to by a single name in data input/output
</BLOCKQUOTE>
<A name=contents></A><H3>CONTENTS</H3></A>
<BLOCKQUOTE>
<A HREF=#1>Synopsis</A><BR>
<A HREF=#2>Description</A><BR>
<A HREF=#3>Options</A><BR>
<A HREF=#4>Results</A><BR>
<A HREF=#5>Example</A><BR>
<A HREF=#6>Other</A><BR>
</BLOCKQUOTE>
<A name=7>

     <H3>SYNOPSIS</H3>

</A>
<BLOCKQUOTE>
<PRE>
<B>NAMELIST</B> / <I>namelist-group-name</I> / <I>namelist-group-object-list</I> [ [ , ] / <I>namelist-group-name</I> /
<B>namelist-group-object-list</B> ] . . .
<BLOCKQUOTE>
</PRE>
<TABLE cellpadding=3><!-- tsb: <B>NAMELIST</B> / <I>namelist-group-name</I> / <I>namelist-group-object-list</I> [ [ , ] / <I>namelist-group-name</I> /
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
<B>namelist-group-object</B>
<I>is</I>   <I>variable-name</I>
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
</BLOCKQUOTE>
<A name=2>

     <H3>DESCRIPTION</H3>

</A>
<BLOCKQUOTE>
<I>.</I> <B>NAMELIST</B> statement specifies <I>.</I> group of named data objects, which
may be referred to by <I>.</I> single name for the purpose of data transfer.
<P>
The order in which the variables are specified in the <B>NAMELIST</B>
statement determines the order in which the values appear on output.
<BLOCKQUOTE>
<P>
<I>.</I> The <I>namelist-group-name</I> shall not be <I>.</I> name accessed by use association.
<I>.</I> <I>.</I> <B>namelist-group-object</B> shall not be an assumed-size array.
<I>.</I> <I>.</I> <B>namelist-group-object</B> shall not have the PRIVATE attribute if the <I>namelist-group-name</I> has the PUBLIC attribute.
</BLOCKQUOTE>
<P>
Any <I>namelist-group-name</I> may occur more than once in the <B>NAMELIST</B> statements in <I>.</I> scoping unit. The
<B>namelist-group-object-list</B> following each successive appearance of the same <I>namelist-group-name</I> in <I>.</I> scoping
unit <I>is</I> treated as <I>.</I> continuation of the list for that <I>namelist-group-name</I>.
<P>
<I>.</I> namelist group object may be <I>.</I> member of more than one namelist group.
<P>
<I>.</I> namelist group object shall either be accessed by use or host association or shall have its type, type parameters,
and shape specified by previous specification statements or the procedure heading in the same scoping unit or
by the implicit typing rules in effect for the scoping unit. If <I>.</I> namelist group object <I>is</I> typed by the implicit
typing rules, its appearance in any subsequent type declaration statement shall confirm the implied type and
type parameters.
</BLOCKQUOTE>
<A name=3>

     <H3>OPTIONS</H3>

</A>
<BLOCKQUOTE>
</BLOCKQUOTE>
<A name=4>

     <H3>RESULTS</H3>

</A>
<BLOCKQUOTE>
</BLOCKQUOTE>
<A name=5>

     <H3>EXAMPLE</H3>

</A>
<BLOCKQUOTE>
An example of <I>.</I> <B>NAMELIST</B> statement <I>is</I>:
<P>
<PRE>
     NAMELIST /NLIST/ A, B, C
<P>
</PRE>
or <I>.</I> group may be defined by multiple statements using the same group name in <I>.</I> scoping unit:
<P>
<PRE>
     NAMELIST /NLIST/ A, B
     NAMELIST /NLIST/ C
<P>
     ! READ/WRITE EXAMPLES: [ NML = ] namelist-group-name
     READ(*,NML=NLIST)
     WRITE(*,NLIST)
     WRITE(*,NML=NLIST)
<P>
      program demo_namelist
      implicit none
      logical           :: l=.true.
      character(len=10) :: c=&#146;XXXXXXXXXX&#146;
      real              :: r=12.3456
      integer           :: i=789
      complex           :: x=(12345.6789,9876.54321)
      doubleprecision   :: d= 123456789.123456789d0
      namelist /nlist/ l,c,r,i,x,d
         write(*,nlist)
      end program demo_namelist
<P>
</PRE>
Results:
<P>
<PRE>
      &NLIST
       L=T,
       C="XXXXXXXXXX",
       R=  12.3456001    ,
       I=        789,
       X=(  12345.6787    ,  9876.54297    ),
       D=  123456789.12345679     ,
       /
<P>
</PRE>
<I>.</I> Scanning on input till group name <I>is</I> found
<I>.</I> reading partial lists
<I>.</I> string quoting
<I>.</I> <B>NAMELIST</B> in internal read and write. See
<P>
<PRE>
    ./arguments/namelist
<P>
</PRE>
</BLOCKQUOTE>
Why <I>is</I> <B>NAMELIST</B> not allowed in <I>.</I> BLOCK unit?
Would be handy for quick writes, like list-directed output
<P>
<PRE>
    block
       namelist /nlist/ a,b,c,d
       write(nlist)
    endblock
<P>
</PRE>
<A name=6>

     <H3>OTHER</H3>

</A>
<BLOCKQUOTE>
<P>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
C915
(R913) <I>.</I> <I>namelist-group-name</I> shall be the name of <I>.</I> namelist group.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
C916
(R913) <I>.</I> <I>namelist-group-name</I> shall not appear if <I>.</I> REC= specifier, format, input-item-list, or an
output-item-list appears in the data transfer statement.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
C917
(R913) An io-control-spec-list shall not contain both <I>.</I> format and <I>.</I> <I>namelist-group-name</I>.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
C919
(R913) If <I>namelist-group-name</I> appears without <I>.</I> preceding NML=, it shall be the second item in the
io-control-spec-list and the first item shall be io-unit.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
C928
(R913) If <I>.</I> DECIMAL=, BLANK=, PAD=, SIGN=, or ROUND= specifier appears, <I>.</I> format or
<I>namelist-group-name</I> shall also appear.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
C929
(R913) If <I>.</I> DELIM= specifier appears, either format shall be an asterisk or <I>namelist-group-name</I> shall
appear.
<I>.</I> If the data transfer statement contains <I>.</I> format or <I>namelist-group-name</I>, the statement <I>is</I> <I>.</I> formatted in-
put/output statement; otherwise, it <I>is</I> an unformatted input/output statement.
<I>.</I> The NML= specifier supplies the <I>namelist-group-name</I> (5.6). This name identifies <I>.</I> particular collection of data
objects on which transfer <I>is</I> to be performed.
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<I>.</I> If <I>.</I> <I>namelist-group-name</I> appears, the statement <I>is</I> <I>.</I> namelist input/output statement.
<I>.</I> All values following the name= part of the namelist entity (10.11) within the input records are transmitted to
the matching entity specified in the <B>namelist-group-object-list</B> prior to processing any succeeding entity within
the input record for namelist input statements. If an entity <I>is</I> specified more than once within the input record
during <I>.</I> namelist formatted data transfer input statement, the last occurrence of the entity specifies the value or
values to be used for that entity.
<P>
<PRE>
    9.6.4.6     Namelist formatting
<P>
</PRE>
<BLOCKQUOTE>
<I>.</I> If namelist formatting has been established, editing <I>is</I> performed as described in 10.11.
<P>
<I>.</I> Every allocatable <B>namelist-group-object</B> in the namelist group shall be allocated and every <B>namelist-group-object</B>
that <I>is</I> <I>.</I> pointer shall be associated with <I>.</I> target. If <I>.</I> <B>namelist-group-object</B> <I>is</I> polymorphic or has an ultimate
component that <I>is</I> allocatable or <I>.</I> pointer, that object shall be processed by <I>.</I> defined input/output procedure
(9.6.4.7).
<BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: <I>.</I> Every allocatable <B>namelist-group-object</B> in the namelist group shall be allocated and every <B>namelist-group-object</B>
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
9.6.5
Termination of data transfer statements
<I>.</I> Termination of an input/output data transfer statement occurs when
</TD></TR>
<TR><TD colspan=2>
<PRE>
      · format processing encounters a colon or data edit descriptor and there are no remaining elements in the
        input-item-list or output-item-list,
      · unformatted or list-directed data transfer exhausts the input-item-list or output-item-list,
      · namelist output exhausts the namelist-group-object-list,
      · an error condition occurs,
      · an end-of-file condition occurs,
<P>
      · a slash (/) is encountered as a value separator (10.10, 10.11) in the record being read during list-directed
        or namelist input, or
      · an end-of-record condition occurs during execution of a nonadvancing input statement (9.11).
</PRE>
<I>.</I> If an error condition occurs during execution of an input/output statement that contains neither an ERR= nor
IOSTAT= specifier, error termination of the program <I>is</I> initiated. If an error condition occurs during execution
of an input/output statement that contains either an ERR= specifier or an IOSTAT= specifier then:
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
(<I>.</I>)
processing of the input/output list, if any, terminates;
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
(<I>.</I>)
if the statement <I>is</I> <I>.</I> data transfer statement or the error occurs during <I>.</I> wait operation, all do-
variables in the statement that initiated the transfer become undefined;
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
(<I>.</I>)
if an IOSTAT= specifier appears, the scalar-int-variable in the IOSTAT= specifier becomes defined
as specified in 9.11.5;
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
(<I>.</I>)
if an IOMSG= specifier appears, the iomsg-variable becomes defined as specified in 9.11.6;
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
(<I>.</I>)
if the statement <I>is</I> <I>.</I> READ statement and it contains <I>.</I> SIZE= specifier, the scalar-int-variable in
the SIZE= specifier becomes defined as specified in 9.6.2.15;
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
(<I>.</I>)
if the statement <I>is</I> <I>.</I> READ statement or the error condition occurs in <I>.</I> wait operation for <I>.</I> transfer
initiated by <I>.</I> READ statement, all input items or namelist group objects in the statement that
initiated the transfer become undefined;
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
(<I>.</I>)
if an ERR= specifier appears, <I>.</I> branch to the statement labeled by the label in the ERR= specifier
occurs.
<I>.</I> In <I>.</I> data transfer statement, the variable specified in an IOSTAT=, IOMSG=, or SIZE= specifier, if any, shall
not be associated with any entity in the data transfer input/output list (9.6.3) or <B>namelist-group-object-list</B>, nor
with <I>.</I> do-variable of an io-implied-do in the data transfer input/output list.
</TD></TR>
<TR></TR></TABLE><!-- .TP -->
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
10.11
Namelist formatting
<TABLE width=100% cellpadding=3><!-- tsb: 10.11
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
10.11.1
General
<I>.</I> Namelist input/output allows data editing with NAME=value subsequences. This facilitates documentation of
input and output files and more flexibility on input.
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
10.11.2
Name-value subsequences
<I>.</I> The characters in one or more namelist records constitute <I>.</I> sequence of name-value subsequences, each of
which consists of an object designator followed by an equals and followed by one or more values and value
separators. The equals may optionally be preceded or followed by one or more contiguous blanks. The end of <I>.</I>
record has the same effect as <I>.</I> blank character, unless it <I>is</I> within <I>.</I> character constant. Any sequence of two or
more consecutive blanks <I>is</I> treated as <I>.</I> single blank, unless it <I>is</I> within <I>.</I> character constant.
</TD></TR>
<TR></TR></TABLE><!-- .RE -->
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<I>.</I> The name may be any name in the <B>namelist-group-object-list</B> (5.6).
<P>
<I>.</I> <I>.</I> value separator for namelist formatting <I>is</I> the same as for list-directed formatting (10.10).
<P>
<PRE>
    10.11.3      Namelist input
    10.11.3.1    Overall syntax
<P>
</PRE>
<I>.</I> Input for <I>.</I> namelist input statement consists of
<P>
<PRE>
           (1)   optional blanks and namelist comments,
           (2)   the character & followed immediately by the namelist-group-name as specified in the NAMELIST
                 statement,
           (3)   one or more blanks,
           (4)   a sequence of zero or more name-value subsequences separated by value separators, and
           (5)   a slash to terminate the namelist input.
<P>
</PRE>
<BLOCKQUOTE>
NOTE 10.34
<I>.</I> slash encountered in <I>.</I> namelist input record causes the input statement to terminate. <I>.</I> slash cannot be
used to separate two values in <I>.</I> namelist input statement.
</BLOCKQUOTE>
<P>
<I>.</I> In each name-value subsequence, the name shall be the name of <I>.</I> namelist group object list item with an optional
qualification and the name with the optional qualification shall not be <I>.</I> zero-sized array, <I>.</I> zero-sized array section,
or <I>.</I> zero-length character string. The optional qualification, if any, shall not contain <I>.</I> vector subscript.
<P>
<I>.</I> <I>.</I> group name or object name <I>is</I> without regard to case.
<P>
<PRE>
   10.11.3.2    Namelist group object names
<P>
</PRE>
</BLOCKQUOTE>
<I>.</I> Within the input data, each name shall correspond to <I>.</I> particular namelist group object name. Subscripts,
strides, and substring range expressions used to qualify group object names shall be optionally signed integer
literal constants with no kind type parameters specified. If <I>.</I> namelist group object <I>is</I> an array, the input record
corresponding to it may contain either the array name or the designator of <I>.</I> subobject of that array, using the
syntax of object designators (R601). If the namelist group object name <I>is</I> the name of <I>.</I> variable of derived type,
the name in the input record may be either the name of the variable or the designator of one of its components,
indicated by qualifying the variable name with the appropriate component name. Successive qualifications may
be applied as appropriate to the shape and type of the variable represented.
<BLOCKQUOTE>
<P>
<I>.</I> The order of names in the input records need not match the order of the namelist group object items. The input
records need not contain all the names of the namelist group object items. The definition status of any names
from the <B>namelist-group-object-list</B> that do not occur in the input record remains unchanged. In the input record,
each object name or subobject designator may be preceded and followed by one or more optional blanks but shall
not contain embedded blanks.
<BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: <I>.</I> The order of names in the input records need not match the order of the namelist group object items. The input
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
10.11.3.3
Namelist group object list items
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<I>.</I> The name-value subsequences are evaluated serially, in left-to-right order. <I>.</I> namelist group object designator
may appear in more than one name-value sequence.
<P>
<I>.</I> When the name in the input record represents an array variable or <I>.</I> variable of derived type, the effect <I>is</I> as
if the variable represented were expanded into <I>.</I> sequence of scalar list items, in the same way that formatted
input/output list items are expanded (9.6.3). Each input value following the equals shall then be acceptable to
format specifications for the type of the list item in the corresponding position in the expanded sequence, except
as noted in this subclause. The number of values following the equals shall not exceed the number of list items
in the expanded sequence, but may be less; in the latter case, the effect <I>is</I> as if sufficient null values had been
appended to match any remaining list items in the expanded sequence.
<P>
<PRE>
        NOTE 10.35
        For example, if the name in the input record is the name of an integer array of size 100, at most 100 values,
        each of which is either a digit string or a null value, may follow the equals; these values would then be
        assigned to the elements of the array in array element order.
<P>
</PRE>
<I>.</I> <I>.</I> slash encountered as <I>.</I> value separator during the execution of <I>.</I> namelist input statement causes termination
of execution of that input statement after transference of the previous value. If there are additional items in the
namelist group object being transferred, the effect <I>is</I> as if null values had been supplied for them.
<P>
<I>.</I> <I>.</I> namelist comment may appear after any value separator except <I>.</I> slash. <I>.</I> namelist comment <I>is</I> also permitted
to start in the first nonblank position of an input record except within <I>.</I> character literal constant.
<P>
<I>.</I> Successive namelist records are read by namelist input until <I>.</I> slash <I>is</I> encountered; the remainder of the record
<I>is</I> ignored and need not follow the rules for namelist input values.
<BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: <I>.</I> Successive namelist records are read by namelist input until <I>.</I> slash <I>is</I> encountered; the remainder of the record
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
10.11.3.4
Namelist input values
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<I>.</I> Each value <I>is</I> either <I>.</I> null value (10.11.3.5), <I>.</I>, <I>.</I> *<I>.</I>, or <I>.</I> *, where <I>.</I> <I>is</I> <I>.</I> literal constant, optionally signed if integer
or real, and <I>.</I> <I>is</I> an unsigned, nonzero, integer literal constant. <I>.</I> kind type parameter shall not be specified for <I>.</I>
or <I>.</I>. The constant <I>.</I> <I>is</I> interpreted as though it had the same kind type parameter as the corresponding effective
item. The <I>.</I> *<I>.</I> form <I>is</I> equivalent to <I>.</I> successive appearances of the constant <I>.</I>, and the <I>.</I> * form <I>is</I> equivalent to
<I>.</I> successive null values. Neither of these forms may contain embedded blanks, except where permitted within
the constant <I>.</I>.
<P>
<I>.</I> The datum <I>.</I> (10.11) <I>is</I> any input value acceptable to format specifications for <I>.</I> given type, except for <I>.</I> restriction
on the form of input values corresponding to list items of types logical, integer, and character as specified in this
subclause. The form of <I>.</I> real or complex value <I>is</I> dependent on the decimal edit mode in effect (10.6). The form
<BLOCKQUOTE>
<P>
of an input value shall be acceptable for the type of the namelist group object list item. The number and forms
of the input values that may follow the equals in <I>.</I> name-value subsequence depend on the shape and type of
the object represented by the name in the input record. When the name in the input record <I>is</I> that of <I>.</I> scalar
variable of an intrinsic type, the equals shall not be followed by more than one value. Blanks are never used
as zeros, and embedded blanks are not permitted in constants except within character constants and complex
constants as specified in this subclause.
</BLOCKQUOTE>
<P>
<I>.</I> When the next effective item <I>is</I> of type real, the input form of the input value <I>is</I> that of <I>.</I> numeric input field. <I>.</I>
numeric input field <I>is</I> <I>.</I> field suitable for <I>.</I> editing (10.7.2.3.2) that <I>is</I> assumed to have no fractional digits unless
<I>.</I> decimal symbol appears within the field.
<P>
<I>.</I> When the next effective item <I>is</I> of type complex, the input form of the input value consists of <I>.</I> left parenthesis
followed by an ordered pair of numeric input fields separated by <I>.</I> comma (if the decimal edit mode <I>is</I> POINT) or
<I>.</I> semicolon (if the decimal edit mode <I>is</I> COMMA), and followed by <I>.</I> right parenthesis. The first numeric input
field <I>is</I> the real part of the complex constant and the second part <I>is</I> the imaginary part. Each of the numeric
input fields may be preceded or followed by any number of blanks and ends of records. The end of <I>.</I> record may
occur between the real part and the comma or semicolon, or between the comma or semicolon and the imaginary
part.
<P>
<I>.</I> When the next effective item <I>is</I> of type logical, the input form of the input value shall not include equals or value
separators among the optional characters permitted for <I>.</I> editing (10.7.3).
<P>
<I>.</I> When the next effective item <I>is</I> of type integer, the value in the input record <I>is</I> interpreted as if an Iw edit
descriptor with <I>.</I> suitable value of <I>.</I> were used.
<P>
<I>.</I> When the next effective item <I>is</I> of type character, the input form consists of <I>.</I> delimited sequence of zero or more
rep-char <I>.</I> whose kind type parameter <I>is</I> implied by the kind of the corresponding list item. Such <I>.</I> sequence
may be continued from the end of one record to the beginning of the next record, but the end of record shall
not occur between <I>.</I> doubled apostrophe in an apostrophe-delimited sequence, nor between <I>.</I> doubled quote in <I>.</I>
quote-delimited sequence. The end of the record does not cause <I>.</I> blank or any other character to become part
of the sequence. The sequence may be continued on as many records as needed. The characters blank, comma,
semicolon, and slash may appear in such character sequences.
<P>
<PRE>
          NOTE 10.36
          A character sequence corresponding to a namelist input item of character type shall be delimited either with
          apostrophes or with quotes. The delimiter is required to avoid ambiguity between undelimited character
          sequences and object names. The value of the DELIM= specifier, if any, in the OPEN statement for an
          external file is ignored during namelist input (9.5.6.8).
<P>
</PRE>
<I>.</I> Let len be the length of the next effective item, and let <I>.</I> be the length of the character sequence. If len <I>is</I> less
than or equal to <I>.</I>, the leftmost len characters of the sequence are transmitted to the next effective item. If len
<I>is</I> greater than <I>.</I>, the constant <I>is</I> transmitted to the leftmost <I>.</I> characters of the next effective item and the
remaining len-<I>.</I> characters of the next effective item are filled with blanks. The effect <I>is</I> as though the sequence
were assigned to the next effective item in an intrinsic assignment statement (7.2.1.3).
<BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: <I>.</I> Let len be the length of the next effective item, and let <I>.</I> be the length of the character sequence. If len <I>is</I> less
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
10.11.3.5
Null values
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<I>.</I> <I>.</I> null value <I>is</I> specified by
<P>
<PRE>
      ·   the r * form,
      ·   blanks between two consecutive nonblank value separators following an equals,
      ·   zero or more blanks preceding the first value separator and following an equals, or
      ·   two consecutive nonblank value separators.
<P>
</PRE>
<I>.</I> <I>.</I> null value has no effect on the definition status of the corresponding input list item. If the namelist group
object list item <I>is</I> defined, it retains its previous value; if it <I>is</I> undefined, it remains undefined. <I>.</I> null value shall
<BLOCKQUOTE>
<P>
not be used as either the real or imaginary part of <I>.</I> complex constant, but <I>.</I> single null value may represent an
entire complex constant.
<P>
<PRE>
        NOTE 10.37
        The end of a record following a value separator, with or without intervening blanks, does not specify a null
        value in namelist input.
<P>
</PRE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
10.11.3.6
Blanks
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<I>.</I> All blanks in <I>.</I> namelist input record are considered to be part of some value separator except for
<P>
<PRE>
      · blanks embedded in a character constant,
      · embedded blanks surrounding the real or imaginary part of a complex constant,
      · leading blanks following the equals unless followed immediately by a slash or comma, or a semicolon if the
        decimal edit mode is comma, and
      · blanks between a name and the following equals.
<P>
</PRE>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
10.11.3.7
Namelist Comments
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<P>
<I>.</I> Except within <I>.</I> character literal constant, <I>.</I> "!" character after <I>.</I> value separator or in the first nonblank position
of <I>.</I> namelist input record initiates <I>.</I> comment. The comment extends to the end of the current input record and
may contain any graphic character in the processor-dependent character set. The comment <I>is</I> ignored. <I>.</I> slash
within the namelist comment does not terminate execution of the namelist input statement. Namelist comments
are not allowed in stream input because comments depend on record structure.
<P>
<PRE>
        NOTE 10.38
        Namelist input example:
<P>
        INTEGER I; REAL X (8); CHARACTER (11) P; COMPLEX Z;
</PRE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; LOGICAL G</H4>
</A>
<BLOCKQUOTE>
<B>NAMELIST</B> / TODAY / <I>.</I>, <I>.</I>, <I>.</I>, <I>.</I>, <I>.</I>
READ (*, NML = TODAY)
<P>
The input data records are:
<P>
&TODAY <I>.</I> = 12345, <I>.</I>(<I>.</I>) = 12345, <I>.</I>(<I>.</I>:<I>.</I>) = <I>.</I>*1.5, <I>.</I>=<I>.</I>, ! This <I>is</I> <I>.</I> comment.
<I>.</I> = &#146;&#146;ISN&#146;T_BOB&#146;<I>.</I>&#146;&#146;, <I>.</I> = (123,<I>.</I>)/
<P>
The results stored are:
<BLOCKQUOTE>
<TABLE cellpadding=3><!-- tsb: The results stored are:
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
Variable
Value
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
<I>.</I>
<I>.</I>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
<I>.</I> (<I>.</I>)
12345.0
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
<I>.</I> (<I>.</I>)
unchanged
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
<I>.</I> (<I>.</I>)
1.5
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
<I>.</I> (<I>.</I>)
1.5
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
<I>.</I> (<I>.</I>) ­ <I>.</I> (<I>.</I>)
unchanged
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
<I>.</I>
ISN&#146;<I>.</I> BOB&#146;<I>.</I>
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
<I>.</I>
(123.0,0.0)
</TD></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
<I>.</I>
unchanged
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
</BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
10.11.4
Namelist output
<TABLE width=100% cellpadding=3><!-- tsb: 10.11.4
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
10.11.4.1
Form of namelist output
</TD></TR>
<TR></TR></TABLE><!-- .PP -->
</TD></TR>
<TR><TD colspan=2>
<I>.</I> The form of the output produced <I>is</I> the same as that required for input, except for the forms of real, character,
and logical values. The name in the output <I>is</I> in upper case. With the exception of adjacent undelimited character
values, the values are separated by one or more blanks or by <I>.</I> comma, or <I>.</I> semicolon if the decimal edit mode
<I>is</I> COMMA, optionally preceded by one or more blanks and optionally followed by one or more blanks.
</TD></TR>
<TR><TD width=6%>&nbsp;</TD><TD>
<P>
<I>.</I> Namelist output shall not include namelist comments.
<P>
<I>.</I> The processor may begin new records as necessary. However, except for complex constants and character values,
the end of <I>.</I> record shall not occur within <I>.</I> constant, character value, or name, and blanks shall not appear
within <I>.</I> constant, character value, or name.
<P>
<PRE>
        NOTE 10.39
        The length of the output records is not specified exactly and may be processor dependent.
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
10.11.4.2
Namelist output editing
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .PP -->
<P>
<I>.</I> Values in namelist output records are edited as for list-directed output (10.10.4).
<P>
<PRE>
        NOTE 10.40
        Namelist output records produced with a DELIM= specifier with a value of NONE and which contain a
        character sequence might not be acceptable as namelist input records.
<P>
</PRE>
<TABLE width=100% cellpadding=3>
<TR><TD width=6%>&nbsp;</TD><TD>
<TABLE width=100% cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
10.11.4.3
Namelist output records
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><!-- .PP -->
<P>
<I>.</I> If two or more successive values for the same namelist group item in an output record produced have identical
values, the processor has the option of producing <I>.</I> repeated constant of the form <I>.</I> *<I>.</I> instead of the sequence of
identical values.
<P>
<I>.</I> The name of each namelist group object list item <I>is</I> placed in the output record followed by an equals and <I>.</I> list
of values of the namelist group object list item.
<P>
<I>.</I> An ampersand character followed immediately by <I>.</I> <I>namelist-group-name</I> will be produced by namelist formatting
at the start of the first output record to indicate which particular group of data objects <I>is</I> being output. <I>.</I> slash
<I>is</I> produced by namelist formatting to indicate the end of the namelist formatting.
<P>
<I>.</I> <I>.</I> null value <I>is</I> not produced by namelist formatting.
<P>
<I>.</I> Except for new records created by explicit formatting within <I>.</I> defined output procedure or by continuation of
delimited character sequences, each output record begins with <I>.</I> blank character.
<TABLE width=100% cellpadding=3><!-- tsb: <I>.</I> Except for new records created by explicit formatting within <I>.</I> defined output procedure or by continuation of
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=6% nowrap>
<B></B> </TD><TD valign=bottom>
C806
(R807) The specification-part of <I>.</I> BLOCK construct shall not contain <I>.</I> COMMON, EQUIVALENCE,
IMPLICIT, INTENT, <B>NAMELIST</B>, or OPTIONAL statement.
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE><P><HR>
<TABLE width=100%><TR> <TD width=33%><I></I></TD> <TD width=33% align=center>namelist (7)</TD> <TD align=right width=33%><I>April 23, 2018</I></TD> </TR></TABLE><FONT SIZE=-1>Generated by <A HREF="http://www.squarebox.co.uk/download/manServer.shtml">manServer 1.08</A> from 77c25177-e90a-4d06-bf26-ca8d83f27de8 using man macros.</FONT>
</div>
</div>
<center><img src="images/namelist.7.gif"></center> 
</body>
</HTML>
