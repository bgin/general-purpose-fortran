<html>
<head>
<title></title>
<meta name="keywords" content="Fortran, Fortran code, Fortran source code repository, Fortran library, Fortran archive,         " />
<meta name="keywords" content="General Purpose Fortran, Fortran modules, Fortran examples                                       " />
<meta name="keywords" content="Fortran Repository" />
<meta name="keywords" content="Fortran Collection" />
<style>
body { background-color:#FFF; color:#333; font-family:Verdana, Arial, Helvetica, sans-serif; font-size:1em; line-height:1.3em; }

a,li span { color:#000; }
a:visited { color:#666; }
a:hover, a.nav:hover, a:hover math { background-color:#000; color:#FFF; }
a.nav,a:link.nav, a:visited.nav { background-color:#FFF; color:#000; }

h1,h2,h3,h4,h5,h6 { color:#333; font-family:georgia, verdana, sans-serif; }
h1 { font-size:200%; line-height: 1.1em;color:#F33}
h2 { font-size:173%; }
h3 { font-size:144%; }
h4 { font-size:120%; }
h5,h6 { font-size:100% }
table { border:double #000; border-collapse:collapse; }
td { border:thin solid #888; margin: auto; padding: auto; border: auto;}
td { padding-left: 1em; padding-right: 1em;}
li { margin-bottom:0.5em; }
blockquote { display:block; font-size:90%; line-height:1.5em; margin:0 0 1.5em; padding:0 2.5em; }
pre { background-color:#DDD; font-size:90%; overflow:auto; padding:1em; }
xmp { background-color:#DCC; font-size:80%; display: block; font-family: monospace; white-space: pre; margin: 1em 0; }

#Container { margin:0 10px; text-align:center; }
#Content { border-top:none; margin:auto; padding:0.3em; text-align:left; width:100%; max-width:55em; }
span.webName { font-size:.5em; }
textarea#content { font-size: 1em; line-height: 1.125; }
h1#pageName { line-height:1em; margin:0.2em 0 0.2em 0; padding:0; }
.property { color:#666; font-size:80%; }
a.existingWikiWord[title]{ //border: 1px dashed #BBB; }
.byline { color:#666; font-size:.8em; font-style:italic; margin-bottom:1em; padding-top:1px; }
</style>
</head>
<body>
<a href="http://www.urbanjost.altervista.org/LIBRARY/libGPF/GPF.html">[GPF Home Page]</a>
<div id="Container">
<div id="Content">
<!-- ======================================================================= -->
<h2>NAME</h2>
<pre>
M_calculator_Example(5f) - [M_calculator] Example program for module M_calculator(3fm)
</pre>

<h2>DESCRIPTION</h2>
<p>
   Any program that calls JUCALC directly or indirectly (via JUCALX(),
   STRGAR2(), INUM0(), RNUM0(), SNUM0()) must supply two routines:
</p>

<ol>
  <li> JUOWN1() - This routine is a hook for programmers to add
           their own functions to JUCALC without having to change
           JUCALC directly. It is passed the name of unknown
           functions and their parameter lists if the expression
           'ownmode(1)' is passed to the calculator.
           If you do not need to add custom functions to the
           calculator use the stub routine shown in the example.
  <li> C - This is here to optimize performance of a particular
           program and everyone else should just use a stub routine
           as shown. In a special case a non-standard function
           needed added that was called so heavily that it was
           important that it be called more efficiently than a
           user defined function placed in JUOWN1 is.
</ol>

<p>
   The following program shows a simple but complete line-mode calculator
   program.
</p>

<p>
   The administrator of libGPF.a should have the scripts html2F and
   ccall in his search path. To build and execute this program enter
   the directly where this document resides and enter:
</p>

<pre>
   html2F Example.html >compute.f90 # extract source from document
   ccall compute.f90  # compile and load example program
   ./compute        # run example program
   a=10
   a/2
   3**4
   sin(3.1416/4)
   PI=2*asin(1)
   diameter=20.3+8/4
   circumference=PI*diameter
   funcs
   dump
   # use end-of-file (typically control-D) to exit program
   ctrl-D
</pre>

<!--FORTRAN90--><xmp>

   !program demo_M_calculator
   program show_M_calculator

      !     line mode calculator that calls jucalc
      !
      use M_calculator, only: jucalc,iclen_calc
      use M_calculator, only : rnum0
      implicit none
      integer, parameter        :: k_dbl = SELECTED_REAL_KIND(15,300) ! real*8
      character(len=iclen_calc) :: event, line
      character(len=iclen_calc) :: outlin
      integer                   :: ios
      integer                   :: ierr
      real(kind=k_dbl)          :: rvalue
      character(len=80)         :: string
      INFINITE: do
         read(*,'(a)',iostat=ios)line
         if(ios.ne.0)exit INFINITE
         call jucalc(line,outlin,event,rvalue,ierr)
         ! line   -- input expression
         ! outlin -- result as a string
         ! event  --
         ! rvalue -- result as a numeric value
         ! ierr   -- return status
         !
         ! several different meaning to the status flag ...
         select case(ierr)
         case(0)  ! a numeric value was returned without error
           write(6,'(a,a,a)')trim(outlin),' = ',trim(line)
         case(2)  ! a string value was returned without error
           write(6,'(a)')trim(event)
         case(1)  ! a request for a message has been returned
                  ! (from DUMP or FUNC)
           write(6,'(a,a)')'message===>',trim(event)
         case(-1) ! an error has occurred
           write(6,'(a,a)')'error===>',trim(event)
         case default ! this should not occur
           write(6,'(a)')'warning===> unexpected ierr value from jucalc'
         end select
      enddo INFINITE

      string='A=sind(30)'
      rvalue=rnum0(string,ierr)
      if(ierr.eq.0)then
         write(*,*) rvalue
      else
         write(*,*) 'error evaluating '//trim(string)
      endif
      rvalue=rnum0('A',ierr)
      write(*,*) rvalue

      end program show_M_calculator
      !#cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine juown1(func,iflen,args,iargstp,n,fval,ctmp,ier)
      ! extend functions available to the calculator routine
      !
      !  if the function ownmode(1) is called this subroutine
      !  will be accessed to do user-written functions.
      !
      !  func(iend-1)=procedure name.  func should not be changed.
      !  iflen=length of procedure name.
      !  args=array of 100 elements containing procedure arguments.
      !  iargstp=type of argument(1=value,2=position of string value)
      !  n=integer number of parameters
      !  x=array of 55555 x values
      !  y=array of 55555 y values
      !  fval=value to replace function call
      !  ctmp=string to return when returning a string value
      !  ier=returned error flag value.
      !      set to -1 if an error occurs.
      !      set to  0 if a number is returned
      !      set to  2 if a string is returned
      !
      use M_calculator, only: x,y,values,values_len,iclen_calc
      ! values: the values of string variables
      ! values_len: the lengths of the string variable values
      character(len=*)          :: func

      character(len=*)          :: ctmp
      character(len=iclen_calc) :: temp1
      integer iflen ,n, ier, iargstp(100)
      integer, parameter        :: k_dbl = SELECTED_REAL_KIND(15,300) ! real*8
      real(kind=k_dbl)  :: args(100)
      real(kind=k_dbl)  :: fval
      integer           :: iwhich
         fval=0.0d0
      !-----------------------------------------------------------------------
         write(*,*)'*juown1* unknown function ', func(1:iflen)
         write(*,*)'function name length is..',iflen
         write(*,*)'number of arguments .....',n
         do i10=1,n
            if(iargstp(i10).eq.0)then
               write(*,*)i10,' VALUE=',args(i10)
            elseif(iargstp(i10).eq.2)then
               iwhich=int(args(i10))
               ilen=values_len(iwhich)
               write(*,*)i10,' STRING='//values(iwhich)(:ilen)
            else
               write(*,*)'unknown parameter type is ',iargstp(i10)
            endif
         enddo
      end subroutine juown1
      !ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      real function c(fval,n)
      implicit none
      !  a built-in calculator function called c must be satisfied.
      !  write whatever you want here as a function
      integer, parameter          :: k_dbl = SELECTED_REAL_KIND(15,300) ! real*8
      real(kind=k_dbl),intent(in) :: fval
      integer,intent(in)          :: n
         c=0.0
      end function c
      !end program demo_M_calculator
</xmp>

</div>
</div>
</body>
</html>
