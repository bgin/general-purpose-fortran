<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GeneralPurposeFortran: LIBRARY/libGPF/download/tmp/PROGRAMS/intrinsics.f90 File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GeneralPurposeFortran
   </div>
   <div id="projectbrief">Fortran CLI (Command Line Interfaces)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d905967c2d1c5cf0b1f529a03a6ed089.html">LIBRARY</a></li><li class="navelem"><a class="el" href="dir_fdd95f4373abe2a5646e7fc14bfe06c3.html">libGPF</a></li><li class="navelem"><a class="el" href="dir_7c85a46b200ac67d56812e190c568c9b.html">download</a></li><li class="navelem"><a class="el" href="dir_98e8b70809d7c709475c6f9b591ea3d6.html">tmp</a></li><li class="navelem"><a class="el" href="dir_6fea218b944cf81b9ef907c598006215.html">PROGRAMS</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions/Subroutines</a>  </div>
  <div class="headertitle">
<div class="title">intrinsics.f90 File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions/Subroutines</h2></td></tr>
<tr class="memitem:a39c21619b08a3c22f19e2306efd7f766"><td class="memItemLeft" align="right" valign="top"><a class="el" href="M__stopwatch_83_8txt.html#acfbcff50169d691ff02d4a123ed70482">subroutine</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intrinsics_8f90.html#a39c21619b08a3c22f19e2306efd7f766">help_version</a> (l_version)</td></tr>
<tr class="memdesc:a39c21619b08a3c22f19e2306efd7f766"><td class="mdescLeft">&#160;</td><td class="mdescRight"><h2>NAME</h2>
INTRINSIC(3f) - intrinsic man(1) pages  <a href="#a39c21619b08a3c22f19e2306efd7f766">More...</a><br /></td></tr>
<tr class="separator:a39c21619b08a3c22f19e2306efd7f766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e09a3b52ee8fb04eeb93fe5761626a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="M__stopwatch_83_8txt.html#acfbcff50169d691ff02d4a123ed70482">subroutine</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intrinsics_8f90.html#a3e09a3b52ee8fb04eeb93fe5761626a8">help_usage</a> (l_help)</td></tr>
<tr class="separator:a3e09a3b52ee8fb04eeb93fe5761626a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ddb3e494b21f6cf5e2853dc6d266b0"><td class="memItemLeft" align="right" valign="top">program&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="intrinsics_8f90.html#a47ddb3e494b21f6cf5e2853dc6d266b0">intrinsics_man_pages</a></td></tr>
<tr class="memdesc:a47ddb3e494b21f6cf5e2853dc6d266b0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><h2>NAME</h2>
intrinsics(1f) - [FUNIX] output text versions of Fortran intrinsic man(1) pages  <a href="#a47ddb3e494b21f6cf5e2853dc6d266b0">More...</a><br /></td></tr>
<tr class="separator:a47ddb3e494b21f6cf5e2853dc6d266b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function/Subroutine Documentation</h2>
<a id="a3e09a3b52ee8fb04eeb93fe5761626a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e09a3b52ee8fb04eeb93fe5761626a8">&#9670;&nbsp;</a></span>help_usage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="M__stopwatch_83_8txt.html#acfbcff50169d691ff02d4a123ed70482">subroutine</a> help_usage </td>
          <td>(</td>
          <td class="paramtype">logical, intent(<a class="el" href="M__journal_83_8txt.html#afce72651d1eed785a2132bee863b2f38">in</a>)&#160;</td>
          <td class="paramname"><em>l_help</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="__false_8f90.html#ac39cd9fe2012c31749944aa6b20b6c05">false()</a>.</p>

</div>
</div>
<a id="a39c21619b08a3c22f19e2306efd7f766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39c21619b08a3c22f19e2306efd7f766">&#9670;&nbsp;</a></span>help_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="M__stopwatch_83_8txt.html#acfbcff50169d691ff02d4a123ed70482">subroutine</a> help_version </td>
          <td>(</td>
          <td class="paramtype">logical, intent(<a class="el" href="M__journal_83_8txt.html#afce72651d1eed785a2132bee863b2f38">in</a>)&#160;</td>
          <td class="paramname"><em>l_version</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><h2>NAME</h2>
INTRINSIC(3f) - intrinsic man(1) pages </p>
<h2>DESCRIPTION</h2>
<pre class="fragment">This is a project to provide a standard set of man(1) pages for Fortran
and the Fortran intrinsics, ultimately with a working example program
for each intrinsic.

The manpage source is maintained as a single flat-text file (intrinsics.ff) which is
run thru ufpp(1) and txt2man(1) to create the program intrinsics(1f).
That program generates all the text as plain text as well as being used
as the source for the man(1) pages. The program intrinsics(1f) is
very useful for scanning for keywords.

Note that the vim(1) editor will call up a man(1) page for a word if
the letter "K" is pressed over the word.

Integration with the editor is a powerful tool when inspecting code
that uses unfamiliar procedures and to verify correct usage when
creating code.

*Note*: In many cases the descriptions of these intrinsics were
originally taken from the [[GFortran|GNU Fortran]] manual to make
descriptions on the Fortran Wiki by Jason Blevins (which were then
used to start this collection). Like the Fortran Wiki itself, the
[[GFortran|GNU Fortran]] manual is licensed under the [[GNU Free
Documentation License]].

These documents are at the state of "good enough considering the
alternative is nothing", but are still actively being completed. </pre> 
<p class="reference">References <a class="el" href="__false_8f90.html#ac39cd9fe2012c31749944aa6b20b6c05">false()</a>.</p>

</div>
</div>
<a id="a47ddb3e494b21f6cf5e2853dc6d266b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ddb3e494b21f6cf5e2853dc6d266b0">&#9670;&nbsp;</a></span>intrinsics_man_pages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">program intrinsics_man_pages </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><h2>NAME</h2>
intrinsics(1f) - [FUNIX] output text versions of Fortran intrinsic man(1) pages </p>
<h2>SYNOPSIS</h2>
<pre class="fragment"> intrinsics [--help|--version]
</pre><h2>DESCRIPTION</h2>
<p>This program outputs all the source of the man(1) pages of the Fortran intrinsics procedures.</p>
<h2>OPTIONS</h2>
<p>&ndash;help display this help and exit &ndash;version output version information and exit</p>
<h2>EXAMPLES</h2>
<pre class="fragment"> Sample commands

    intrinsics &gt;x;vi x </pre><h2>NAME</h2>
<p>include(7f) - [FORTRAN] including source text </p><h2>SYNOPSIS</h2>
<pre class="fragment"> INCLUDE char-literal-constant
</pre> <h2>DESCRIPTION</h2>
<p>Additional text may be incorporated into the source text of a program unit during processing. This is accomplished with the INCLUDE line, which has the form </p><pre class="fragment">   INCLUDE char-literal-constant
</pre><p>An INCLUDE line is not a Fortran statement.</p>
<p>The char-literal-constant shall not have a kind type parameter value that is a named-constant. The interpretation of char-literal-constant is processor dependent. An example of a possible valid interpretation is that char-literal-constant is the name of a file that contains the source text to be included.</p>
<p>An INCLUDE line shall appear on a single source line where a statement may appear; it shall be the only nonblank text on this line other than an optional trailing comment. Thus, a statement label is not allowed.</p>
<p>The effect of the INCLUDE line is as if the referenced source text physically replaced the INCLUDE line prior to program processing. Included text may contain any source text, including additional INCLUDE lines; such nested INCLUDE lines are similarly replaced with the specified source text. The maximum depth of nesting of any nested INCLUDE lines is processor dependent. Inclusion of the source text referenced by an INCLUDE line shall not, at any level of nesting, result in inclusion of the same source text.</p>
<p>When an INCLUDE line is resolved, the first included statement line shall not be a continuation line and the last included statement line shall not be continued.</p>
<p>NOTE </p><pre class="fragment">    In some circumstances, for example where source code is
    maintained in an INCLUDE file for use in programs whose source
    form might be either fixed or free, observing the following
    rules allows the code to be used with either source form.

    *   Confine statement labels to character positions 1 to
        5 and statements to character positions 7 to 72.
    *   Treat blanks as being significant.
    *   Use only the exclamation mark (!) to indicate
        a comment, but do not start the comment in character
        position 6.
    *   For continued statements, place an ampersand (&amp;) in
        both character position 73 of a continued line and character
        position 6 of a continuation line.
</pre> <h2>EXAMPLE</h2>
<h2>NAME</h2>
<p>scratch(7f) - [FORTRAN:OPEN] where scratch files are typically written by OPEN(3f) </p><h2>SYNOPSIS</h2>
<pre class="fragment"> open( .... status='scratch')
</pre> <h2>DESCRIPTION</h2>
<p>Where files opened with status='scratch' are written is implementation-dependent. Often the file is unlinked so that it goes away unconditionally when the program starts, so in many *nix environments you cannot see the scratch file that is often used. So the compiler documentation should be referred to, but typically a scratch file is opened with a unique filename in one of the following directories:</p>
<p>o in the directory pointed to by the environment variable $TMPDIR, if defined. o next directories pointed to by $TMP and $TEMP are used if the variables are defined. o if none of the variables are defined, then the /tmp directory is typically used on *nix systems, and the current directory is often used on other systems.</p>
<p>This can be important if you are generating large scratch files, as you may want to specify they are created in a secure directory or on a high-speed server such as a Lustre file server or memory-resident file system. Consider</p>
<p>o Scratch files are often opened using the current permission mask (umask) combined with possible operating-system or kernel defaults and file-system-dependent attributes, so make sure scratch files are properly secure o files are written in an area that you can write to and have sufficient space in o that the scratch space provides optimal performance o make sure the system cleans up properly when programs are aborted.</p>
<p>The behavior is very system-dependent.</p>
<h2>EXAMPLE:</h2>
<p>System-dependent example:</p>
<p>open(newunit=lun,status='scratch') inquire(unit=lun,file=filename) write(*,*)'filename=',filename) end </p><h2>NAME</h2>
<p>initialize_arrays(7f) - [FORTRAN:FAQ] Initializing small 2D numeric arrays with array constructors </p><h2>DESCRIPTION</h2>
<p>Intuitively, one might assume that if one wants to initialize a small array by rows that something like the following will work:</p>
<p>! DOES NOT WORK integer :: xx(3,5)= [ 1, 2, 3, 4, 5], &amp; [10,20,30,40,50], &amp; [11,22,33,44,55]</p>
<p>or perhaps</p>
<p>! DOES NOT WORK integer :: xx(3,5)= [ [ 1, 2, 3, 4, 5], &amp; [10,20,30,40,50], &amp; [11,22,33,44,55] ]</p>
<p>Someday something simpler might work, but currently the following syntax is required to specify the values in an intuitive row-column sequence using an array constructor:</p>
<p>integer,save :: xx(3,5)= reshape([&amp; </p><pre class="fragment">1, 2, 3, 4, 5, &amp;
</pre><p> 10,20,30,40,50, &amp; 11,22,33,44,55 &amp;</p>
<p>],shape(xx),order[2,1])</p>
<p>This is because an array constructor can be used to create and assign values only to rank-one arrays. To define arrays of more than one dimension with an array constructor, you must use the RESHAPE(3f) intrinsic function.</p>
<p>Note that the ORDER= option on RESHAPE(3f) is used to allow the values to be specified in row-column order instead of the default behavior, which fills columns first.</p>
<p>Also note that if the expressions are of type character, Fortran 95/90 requires each expression to have the same character length (there is a common compiler extension that extends all strings to the length of the longest value specified, but depending on it reduces portability).</p>
<h2>Printing small arrays in row-column format</h2>
<p>When working with small arrays the issue that there is no default Fortran routine for printing an array in row-column order becomes apparent. So lets create a simple solution for integer arrays (PRINT_MATRIX_INT(3f)):</p>
<p>program demo_array_constructor ! initializing small arrays implicit none integer,save :: xx(3,5)= reshape([&amp; </p><pre class="fragment">1, 2, 3, 4, 5, &amp;
</pre><p> 10,20,30,40,50, &amp; 11,22,33,44,-1055 &amp;</p>
<p>],shape(xx),order=[2,1])</p>
<p>call print_matrix_int('xx array:',xx)</p>
<p>contains</p>
<p>subroutine print_matrix_int(title,arr) implicit none</p>
<p>character(len=*),parameter::ident= "@(#)print_matrix_int(3f) - print small 2d integer arrays in row-column format"</p>
<p>character(len=*),intent(in) :: title integer,intent(in) :: arr(:,:) integer :: i character(len=:),allocatable :: biggest</p>
<p>write(*,*)trim(title) ! print title biggest=' ' ! make buffer to write integer into write(biggest,'(i0)')ceiling(log10(real(maxval(abs(arr)))))+1 ! find how many characters to use for integers biggest='(" &gt; [",*(i'//trim(biggest)//':,","))' ! use this format to write a row do i=1,size(arr,dim=1) ! print one row of array at a time write(*,fmt=biggest,advance='no')arr(i,:) write(*,'(" ]")') enddo</p>
<p>end subroutine print_matrix_int</p>
<p>end program demo_array_constructor</p>
<p>Results:</p>
<p>xx array: &gt; [ 1, 2, 3, 4, 5 ] &gt; [ 10, 20, 30, 40, 50 ] &gt; [ 11, 22, 33, 44, 55 ]</p>
<p>We could do a more robust version that handles REAL and COMPLEX values as well as NaN values, but it has already been done. If you need to print a variety of small matrices see:</p>
<p>dispmodule(3f), "A Fortran 95 module for pretty-printing matrices". Kristjan Jonasson, Department of Computer Science, School of Science and Engineering, University of Iceland, Hjardarhaga 4, 107 Reykjavik, Iceland (<a href="#" onclick="location.href='mai'+'lto:'+'jon'+'as'+'son'+'@h'+'i.i'+'s'; return false;">jonas<span style="display: none;">.nosp@m.</span>son@<span style="display: none;">.nosp@m.</span>hi.is</a>).</p>
<p>#Initializing a 2D array using DATA statements</p>
<p>Note that DATA statements are very flexible, and allow for perhaps the most intelligible way of specifying small arrays row by row. For example:</p>
<p>! fill rows using DATA statements integer,save,dimension(3,5) :: gg data gg(1,:)/ 1, 2, 3, 4, 5 / data gg(2,:)/ 10, 20, 30, 40, 50 / data gg(3,:)/ 11, 22, 33, 44, 55 /</p>
<p>There are other ways to use a DATA statement to fill in row-column order, including use of the SIZE(3f) function and an implied-DO:</p>
<p>! use implied-DO so data can be declared in row-column order integer, dimension(3,5) :: ff DATA (( ff(J,I), I=1,size(ff,dim=2)), J=1,size(ff,dim=1)) / &amp; 01,02,03,04,05, &amp; 10,20,30,40,50, &amp; 11,22,33,44,55 /</p>
<h2>Initializing a 2D array from a vector using EQUIVALENCE</h2>
<p>Sometimes instead of using RESHAPE(3f) you will see someone initialize a vector and then equivalence it to a multi-dimensional array; especially if the code has a reason to access the data as both a vector and a matrix:</p>
<p>! multi-dimensional row1, row2, .... by equivalence integer,parameter :: d1=3,d2=5 integer :: ee(d1,d2) ! note that the DATA statements could be used to initialize the array instead integer :: e(d1*d2) =[1,10,11, 2,20,22, 3,30,33, 4,40,44, 5,50,55] equivalence (e(1),ee(1,1))</p>
<h2>Notes</h2>
<p>Remember that for simple initializations vector statements can be used</p>
<p>real :: arr(10,20)=0.0 ! array constructors can be used to define constants, not just vectors integer,parameter :: ii(10,10)=[(i,i=1,size(ii))] ! odd numbers using implied-DO</p>
<p>and that if things are too complicated you can just set the values in the executable body of the code. </p>

<p class="reference">References <a class="el" href="intro__blas1_83_8txt.html#a4489874c67983d0920f222267b4a4839">arguments</a>, <a class="el" href="__echo_8f90.html#a7b58d66872f4cd7b2249cc9d9996f08a">echo()</a>, <a class="el" href="__cmp_8f90.html#a3e09a3b52ee8fb04eeb93fe5761626a8">help_usage()</a>, <a class="el" href="__cmp_8f90.html#a39c21619b08a3c22f19e2306efd7f766">help_version()</a>, <a class="el" href="namespacem__kracken.html#a850dce381e1cfe18a4ebcaa214995e39">m_kracken::kracken()</a>, <a class="el" href="namespacem__kracken.html#a7141acd7a00c1a5aa5f90612a0414b63">m_kracken::lget()</a>, <a class="el" href="M__stopwatch_83_8txt.html#a0f266597de2e57eb3aa964927bb30e14">the()</a>, and <a class="el" href="M__stopwatch_83_8txt.html#a97209fd3e34ef701c0a9734280779cbb">to</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
